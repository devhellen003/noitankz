function __vite__mapDeps(indexes) {
    if (!__vite__mapDeps.viteFileDeps) {
        __vite__mapDeps.viteFileDeps = ["./DveOF59V.js", "./BCVtaz4E.js", "./entry.max4AEHW.css"]
    }
    return indexes.map((i) => __vite__mapDeps.viteFileDeps[i])
}
import {
    bH as wi,
    bI as ea,
    bJ as Os,
    bK as Un,
    bL as zo,
    bM as Gr,
    g as Au,
    f as Ib
} from "./BCVtaz4E.js";
import {
    e as Ur,
    U as Ru
} from "./CABdlt05.js";
var Nu = {},
    ta = {};
Object.defineProperty(ta, "__esModule", {
    value: !0
});
var Xt = ea,
    nu = wi,
    xb = 20;

function Ob(i, e, t) {
    for (var s = 1634760805, o = 857760878, c = 2036477234, l = 1797285236, f = t[3] << 24 | t[2] << 16 | t[1] << 8 | t[0], y = t[7] << 24 | t[6] << 16 | t[5] << 8 | t[4], p = t[11] << 24 | t[10] << 16 | t[9] << 8 | t[8], v = t[15] << 24 | t[14] << 16 | t[13] << 8 | t[12], D = t[19] << 24 | t[18] << 16 | t[17] << 8 | t[16], S = t[23] << 24 | t[22] << 16 | t[21] << 8 | t[20], x = t[27] << 24 | t[26] << 16 | t[25] << 8 | t[24], O = t[31] << 24 | t[30] << 16 | t[29] << 8 | t[28], F = e[3] << 24 | e[2] << 16 | e[1] << 8 | e[0], K = e[7] << 24 | e[6] << 16 | e[5] << 8 | e[4], ne = e[11] << 24 | e[10] << 16 | e[9] << 8 | e[8], $ = e[15] << 24 | e[14] << 16 | e[13] << 8 | e[12], U = s, C = o, A = c, E = l, u = f, b = y, G = p, W = v, se = D, ue = S, de = x, w = O, T = F, ee = K, Q = ne, k = $, V = 0; V < xb; V += 2) U = U + u | 0, T ^= U, T = T >>> 16 | T << 16, se = se + T | 0, u ^= se, u = u >>> 20 | u << 12, C = C + b | 0, ee ^= C, ee = ee >>> 16 | ee << 16, ue = ue + ee | 0, b ^= ue, b = b >>> 20 | b << 12, A = A + G | 0, Q ^= A, Q = Q >>> 16 | Q << 16, de = de + Q | 0, G ^= de, G = G >>> 20 | G << 12, E = E + W | 0, k ^= E, k = k >>> 16 | k << 16, w = w + k | 0, W ^= w, W = W >>> 20 | W << 12, A = A + G | 0, Q ^= A, Q = Q >>> 24 | Q << 8, de = de + Q | 0, G ^= de, G = G >>> 25 | G << 7, E = E + W | 0, k ^= E, k = k >>> 24 | k << 8, w = w + k | 0, W ^= w, W = W >>> 25 | W << 7, C = C + b | 0, ee ^= C, ee = ee >>> 24 | ee << 8, ue = ue + ee | 0, b ^= ue, b = b >>> 25 | b << 7, U = U + u | 0, T ^= U, T = T >>> 24 | T << 8, se = se + T | 0, u ^= se, u = u >>> 25 | u << 7, U = U + b | 0, k ^= U, k = k >>> 16 | k << 16, de = de + k | 0, b ^= de, b = b >>> 20 | b << 12, C = C + G | 0, T ^= C, T = T >>> 16 | T << 16, w = w + T | 0, G ^= w, G = G >>> 20 | G << 12, A = A + W | 0, ee ^= A, ee = ee >>> 16 | ee << 16, se = se + ee | 0, W ^= se, W = W >>> 20 | W << 12, E = E + u | 0, Q ^= E, Q = Q >>> 16 | Q << 16, ue = ue + Q | 0, u ^= ue, u = u >>> 20 | u << 12, A = A + W | 0, ee ^= A, ee = ee >>> 24 | ee << 8, se = se + ee | 0, W ^= se, W = W >>> 25 | W << 7, E = E + u | 0, Q ^= E, Q = Q >>> 24 | Q << 8, ue = ue + Q | 0, u ^= ue, u = u >>> 25 | u << 7, C = C + G | 0, T ^= C, T = T >>> 24 | T << 8, w = w + T | 0, G ^= w, G = G >>> 25 | G << 7, U = U + b | 0, k ^= U, k = k >>> 24 | k << 8, de = de + k | 0, b ^= de, b = b >>> 25 | b << 7;
    Xt.writeUint32LE(U + s | 0, i, 0), Xt.writeUint32LE(C + o | 0, i, 4), Xt.writeUint32LE(A + c | 0, i, 8), Xt.writeUint32LE(E + l | 0, i, 12), Xt.writeUint32LE(u + f | 0, i, 16), Xt.writeUint32LE(b + y | 0, i, 20), Xt.writeUint32LE(G + p | 0, i, 24), Xt.writeUint32LE(W + v | 0, i, 28), Xt.writeUint32LE(se + D | 0, i, 32), Xt.writeUint32LE(ue + S | 0, i, 36), Xt.writeUint32LE(de + x | 0, i, 40), Xt.writeUint32LE(w + O | 0, i, 44), Xt.writeUint32LE(T + F | 0, i, 48), Xt.writeUint32LE(ee + K | 0, i, 52), Xt.writeUint32LE(Q + ne | 0, i, 56), Xt.writeUint32LE(k + $ | 0, i, 60)
}

function Md(i, e, t, s, o) {
    if (o === void 0 && (o = 0), i.length !== 32) throw new Error("ChaCha: key size must be 32 bytes");
    if (s.length < t.length) throw new Error("ChaCha: destination is shorter than source");
    var c, l;
    if (o === 0) {
        if (e.length !== 8 && e.length !== 12) throw new Error("ChaCha nonce must be 8 or 12 bytes");
        c = new Uint8Array(16), l = c.length - e.length, c.set(e, l)
    } else {
        if (e.length !== 16) throw new Error("ChaCha nonce with counter must be 16 bytes");
        c = e, l = o
    }
    for (var f = new Uint8Array(64), y = 0; y < t.length; y += 64) {
        Ob(f, c, i);
        for (var p = y; p < y + 64 && p < t.length; p++) s[p] = t[p] ^ f[p - y];
        Cb(c, 0, l)
    }
    return nu.wipe(f), o === 0 && nu.wipe(c), s
}
ta.streamXOR = Md;

function Pb(i, e, t, s) {
    return s === void 0 && (s = 0), nu.wipe(t), Md(i, e, t, t, s)
}
ta.stream = Pb;

function Cb(i, e, t) {
    for (var s = 1; t--;) s = s + (i[e] & 255) | 0, i[e] = s & 255, s >>>= 8, e++;
    if (s > 0) throw new Error("ChaCha: counter overflow")
}
var Ud = {},
    Ui = {};
Object.defineProperty(Ui, "__esModule", {
    value: !0
});

function Tb(i, e, t) {
    return ~(i - 1) & e | i - 1 & t
}
Ui.select = Tb;

function Ab(i, e) {
    return (i | 0) - (e | 0) - 1 >>> 31 & 1
}
Ui.lessOrEqual = Ab;

function qd(i, e) {
    if (i.length !== e.length) return 0;
    for (var t = 0, s = 0; s < i.length; s++) t |= i[s] ^ e[s];
    return 1 & t - 1 >>> 8
}
Ui.compare = qd;

function Rb(i, e) {
    return i.length === 0 || e.length === 0 ? !1 : qd(i, e) !== 0
}
Ui.equal = Rb;
(function(i) {
    Object.defineProperty(i, "__esModule", {
        value: !0
    });
    var e = Ui,
        t = wi;
    i.DIGEST_LENGTH = 16;
    var s = function() {
        function l(f) {
            this.digestLength = i.DIGEST_LENGTH, this._buffer = new Uint8Array(16), this._r = new Uint16Array(10), this._h = new Uint16Array(10), this._pad = new Uint16Array(8), this._leftover = 0, this._fin = 0, this._finished = !1;
            var y = f[0] | f[1] << 8;
            this._r[0] = y & 8191;
            var p = f[2] | f[3] << 8;
            this._r[1] = (y >>> 13 | p << 3) & 8191;
            var v = f[4] | f[5] << 8;
            this._r[2] = (p >>> 10 | v << 6) & 7939;
            var D = f[6] | f[7] << 8;
            this._r[3] = (v >>> 7 | D << 9) & 8191;
            var S = f[8] | f[9] << 8;
            this._r[4] = (D >>> 4 | S << 12) & 255, this._r[5] = S >>> 1 & 8190;
            var x = f[10] | f[11] << 8;
            this._r[6] = (S >>> 14 | x << 2) & 8191;
            var O = f[12] | f[13] << 8;
            this._r[7] = (x >>> 11 | O << 5) & 8065;
            var F = f[14] | f[15] << 8;
            this._r[8] = (O >>> 8 | F << 8) & 8191, this._r[9] = F >>> 5 & 127, this._pad[0] = f[16] | f[17] << 8, this._pad[1] = f[18] | f[19] << 8, this._pad[2] = f[20] | f[21] << 8, this._pad[3] = f[22] | f[23] << 8, this._pad[4] = f[24] | f[25] << 8, this._pad[5] = f[26] | f[27] << 8, this._pad[6] = f[28] | f[29] << 8, this._pad[7] = f[30] | f[31] << 8
        }
        return l.prototype._blocks = function(f, y, p) {
            for (var v = this._fin ? 0 : 2048, D = this._h[0], S = this._h[1], x = this._h[2], O = this._h[3], F = this._h[4], K = this._h[5], ne = this._h[6], $ = this._h[7], U = this._h[8], C = this._h[9], A = this._r[0], E = this._r[1], u = this._r[2], b = this._r[3], G = this._r[4], W = this._r[5], se = this._r[6], ue = this._r[7], de = this._r[8], w = this._r[9]; p >= 16;) {
                var T = f[y + 0] | f[y + 1] << 8;
                D += T & 8191;
                var ee = f[y + 2] | f[y + 3] << 8;
                S += (T >>> 13 | ee << 3) & 8191;
                var Q = f[y + 4] | f[y + 5] << 8;
                x += (ee >>> 10 | Q << 6) & 8191;
                var k = f[y + 6] | f[y + 7] << 8;
                O += (Q >>> 7 | k << 9) & 8191;
                var V = f[y + 8] | f[y + 9] << 8;
                F += (k >>> 4 | V << 12) & 8191, K += V >>> 1 & 8191;
                var J = f[y + 10] | f[y + 11] << 8;
                ne += (V >>> 14 | J << 2) & 8191;
                var re = f[y + 12] | f[y + 13] << 8;
                $ += (J >>> 11 | re << 5) & 8191;
                var be = f[y + 14] | f[y + 15] << 8;
                U += (re >>> 8 | be << 8) & 8191, C += be >>> 5 | v;
                var oe = 0,
                    we = oe;
                we += D * A, we += S * (5 * w), we += x * (5 * de), we += O * (5 * ue), we += F * (5 * se), oe = we >>> 13, we &= 8191, we += K * (5 * W), we += ne * (5 * G), we += $ * (5 * b), we += U * (5 * u), we += C * (5 * E), oe += we >>> 13, we &= 8191;
                var le = oe;
                le += D * E, le += S * A, le += x * (5 * w), le += O * (5 * de), le += F * (5 * ue), oe = le >>> 13, le &= 8191, le += K * (5 * se), le += ne * (5 * W), le += $ * (5 * G), le += U * (5 * b), le += C * (5 * u), oe += le >>> 13, le &= 8191;
                var _e = oe;
                _e += D * u, _e += S * E, _e += x * A, _e += O * (5 * w), _e += F * (5 * de), oe = _e >>> 13, _e &= 8191, _e += K * (5 * ue), _e += ne * (5 * se), _e += $ * (5 * W), _e += U * (5 * G), _e += C * (5 * b), oe += _e >>> 13, _e &= 8191;
                var H = oe;
                H += D * b, H += S * u, H += x * E, H += O * A, H += F * (5 * w), oe = H >>> 13, H &= 8191, H += K * (5 * de), H += ne * (5 * ue), H += $ * (5 * se), H += U * (5 * W), H += C * (5 * G), oe += H >>> 13, H &= 8191;
                var z = oe;
                z += D * G, z += S * b, z += x * u, z += O * E, z += F * A, oe = z >>> 13, z &= 8191, z += K * (5 * w), z += ne * (5 * de), z += $ * (5 * ue), z += U * (5 * se), z += C * (5 * W), oe += z >>> 13, z &= 8191;
                var j = oe;
                j += D * W, j += S * G, j += x * b, j += O * u, j += F * E, oe = j >>> 13, j &= 8191, j += K * A, j += ne * (5 * w), j += $ * (5 * de), j += U * (5 * ue), j += C * (5 * se), oe += j >>> 13, j &= 8191;
                var d = oe;
                d += D * se, d += S * W, d += x * G, d += O * b, d += F * u, oe = d >>> 13, d &= 8191, d += K * E, d += ne * A, d += $ * (5 * w), d += U * (5 * de), d += C * (5 * ue), oe += d >>> 13, d &= 8191;
                var R = oe;
                R += D * ue, R += S * se, R += x * W, R += O * G, R += F * b, oe = R >>> 13, R &= 8191, R += K * u, R += ne * E, R += $ * A, R += U * (5 * w), R += C * (5 * de), oe += R >>> 13, R &= 8191;
                var ae = oe;
                ae += D * de, ae += S * ue, ae += x * se, ae += O * W, ae += F * G, oe = ae >>> 13, ae &= 8191, ae += K * b, ae += ne * u, ae += $ * E, ae += U * A, ae += C * (5 * w), oe += ae >>> 13, ae &= 8191;
                var fe = oe;
                fe += D * w, fe += S * de, fe += x * ue, fe += O * se, fe += F * W, oe = fe >>> 13, fe &= 8191, fe += K * G, fe += ne * b, fe += $ * u, fe += U * E, fe += C * A, oe += fe >>> 13, fe &= 8191, oe = (oe << 2) + oe | 0, oe = oe + we | 0, we = oe & 8191, oe = oe >>> 13, le += oe, D = we, S = le, x = _e, O = H, F = z, K = j, ne = d, $ = R, U = ae, C = fe, y += 16, p -= 16
            }
            this._h[0] = D, this._h[1] = S, this._h[2] = x, this._h[3] = O, this._h[4] = F, this._h[5] = K, this._h[6] = ne, this._h[7] = $, this._h[8] = U, this._h[9] = C
        }, l.prototype.finish = function(f, y) {
            y === void 0 && (y = 0);
            var p = new Uint16Array(10),
                v, D, S, x;
            if (this._leftover) {
                for (x = this._leftover, this._buffer[x++] = 1; x < 16; x++) this._buffer[x] = 0;
                this._fin = 1, this._blocks(this._buffer, 0, 16)
            }
            for (v = this._h[1] >>> 13, this._h[1] &= 8191, x = 2; x < 10; x++) this._h[x] += v, v = this._h[x] >>> 13, this._h[x] &= 8191;
            for (this._h[0] += v * 5, v = this._h[0] >>> 13, this._h[0] &= 8191, this._h[1] += v, v = this._h[1] >>> 13, this._h[1] &= 8191, this._h[2] += v, p[0] = this._h[0] + 5, v = p[0] >>> 13, p[0] &= 8191, x = 1; x < 10; x++) p[x] = this._h[x] + v, v = p[x] >>> 13, p[x] &= 8191;
            for (p[9] -= 8192, D = (v ^ 1) - 1, x = 0; x < 10; x++) p[x] &= D;
            for (D = ~D, x = 0; x < 10; x++) this._h[x] = this._h[x] & D | p[x];
            for (this._h[0] = (this._h[0] | this._h[1] << 13) & 65535, this._h[1] = (this._h[1] >>> 3 | this._h[2] << 10) & 65535, this._h[2] = (this._h[2] >>> 6 | this._h[3] << 7) & 65535, this._h[3] = (this._h[3] >>> 9 | this._h[4] << 4) & 65535, this._h[4] = (this._h[4] >>> 12 | this._h[5] << 1 | this._h[6] << 14) & 65535, this._h[5] = (this._h[6] >>> 2 | this._h[7] << 11) & 65535, this._h[6] = (this._h[7] >>> 5 | this._h[8] << 8) & 65535, this._h[7] = (this._h[8] >>> 8 | this._h[9] << 5) & 65535, S = this._h[0] + this._pad[0], this._h[0] = S & 65535, x = 1; x < 8; x++) S = (this._h[x] + this._pad[x] | 0) + (S >>> 16) | 0, this._h[x] = S & 65535;
            return f[y + 0] = this._h[0] >>> 0, f[y + 1] = this._h[0] >>> 8, f[y + 2] = this._h[1] >>> 0, f[y + 3] = this._h[1] >>> 8, f[y + 4] = this._h[2] >>> 0, f[y + 5] = this._h[2] >>> 8, f[y + 6] = this._h[3] >>> 0, f[y + 7] = this._h[3] >>> 8, f[y + 8] = this._h[4] >>> 0, f[y + 9] = this._h[4] >>> 8, f[y + 10] = this._h[5] >>> 0, f[y + 11] = this._h[5] >>> 8, f[y + 12] = this._h[6] >>> 0, f[y + 13] = this._h[6] >>> 8, f[y + 14] = this._h[7] >>> 0, f[y + 15] = this._h[7] >>> 8, this._finished = !0, this
        }, l.prototype.update = function(f) {
            var y = 0,
                p = f.length,
                v;
            if (this._leftover) {
                v = 16 - this._leftover, v > p && (v = p);
                for (var D = 0; D < v; D++) this._buffer[this._leftover + D] = f[y + D];
                if (p -= v, y += v, this._leftover += v, this._leftover < 16) return this;
                this._blocks(this._buffer, 0, 16), this._leftover = 0
            }
            if (p >= 16 && (v = p - p % 16, this._blocks(f, y, v), y += v, p -= v), p) {
                for (var D = 0; D < p; D++) this._buffer[this._leftover + D] = f[y + D];
                this._leftover += p
            }
            return this
        }, l.prototype.digest = function() {
            if (this._finished) throw new Error("Poly1305 was finished");
            var f = new Uint8Array(16);
            return this.finish(f), f
        }, l.prototype.clean = function() {
            return t.wipe(this._buffer), t.wipe(this._r), t.wipe(this._h), t.wipe(this._pad), this._leftover = 0, this._fin = 0, this._finished = !0, this
        }, l
    }();
    i.Poly1305 = s;

    function o(l, f) {
        var y = new s(l);
        y.update(f);
        var p = y.digest();
        return y.clean(), p
    }
    i.oneTimeAuth = o;

    function c(l, f) {
        return l.length !== i.DIGEST_LENGTH || f.length !== i.DIGEST_LENGTH ? !1 : e.equal(l, f)
    }
    i.equal = c
})(Ud);
(function(i) {
    Object.defineProperty(i, "__esModule", {
        value: !0
    });
    var e = ta,
        t = Ud,
        s = wi,
        o = ea,
        c = Ui;
    i.KEY_LENGTH = 32, i.NONCE_LENGTH = 12, i.TAG_LENGTH = 16;
    var l = new Uint8Array(16),
        f = function() {
            function y(p) {
                if (this.nonceLength = i.NONCE_LENGTH, this.tagLength = i.TAG_LENGTH, p.length !== i.KEY_LENGTH) throw new Error("ChaCha20Poly1305 needs 32-byte key");
                this._key = new Uint8Array(p)
            }
            return y.prototype.seal = function(p, v, D, S) {
                if (p.length > 16) throw new Error("ChaCha20Poly1305: incorrect nonce length");
                var x = new Uint8Array(16);
                x.set(p, x.length - p.length);
                var O = new Uint8Array(32);
                e.stream(this._key, x, O, 4);
                var F = v.length + this.tagLength,
                    K;
                if (S) {
                    if (S.length !== F) throw new Error("ChaCha20Poly1305: incorrect destination length");
                    K = S
                } else K = new Uint8Array(F);
                return e.streamXOR(this._key, x, v, K, 4), this._authenticate(K.subarray(K.length - this.tagLength, K.length), O, K.subarray(0, K.length - this.tagLength), D), s.wipe(x), K
            }, y.prototype.open = function(p, v, D, S) {
                if (p.length > 16) throw new Error("ChaCha20Poly1305: incorrect nonce length");
                if (v.length < this.tagLength) return null;
                var x = new Uint8Array(16);
                x.set(p, x.length - p.length);
                var O = new Uint8Array(32);
                e.stream(this._key, x, O, 4);
                var F = new Uint8Array(this.tagLength);
                if (this._authenticate(F, O, v.subarray(0, v.length - this.tagLength), D), !c.equal(F, v.subarray(v.length - this.tagLength, v.length))) return null;
                var K = v.length - this.tagLength,
                    ne;
                if (S) {
                    if (S.length !== K) throw new Error("ChaCha20Poly1305: incorrect destination length");
                    ne = S
                } else ne = new Uint8Array(K);
                return e.streamXOR(this._key, x, v.subarray(0, v.length - this.tagLength), ne, 4), s.wipe(x), ne
            }, y.prototype.clean = function() {
                return s.wipe(this._key), this
            }, y.prototype._authenticate = function(p, v, D, S) {
                var x = new t.Poly1305(v);
                S && (x.update(S), S.length % 16 > 0 && x.update(l.subarray(S.length % 16))), x.update(D), D.length % 16 > 0 && x.update(l.subarray(D.length % 16));
                var O = new Uint8Array(8);
                S && o.writeUint64LE(S.length, O), x.update(O), o.writeUint64LE(D.length, O), x.update(O);
                for (var F = x.digest(), K = 0; K < F.length; K++) p[K] = F[K];
                x.clean(), s.wipe(F), s.wipe(O)
            }, y
        }();
    i.ChaCha20Poly1305 = f
})(Nu);
var zd = {},
    Ps = {},
    $u = {};
Object.defineProperty($u, "__esModule", {
    value: !0
});

function Nb(i) {
    return typeof i.saveState < "u" && typeof i.restoreState < "u" && typeof i.cleanSavedState < "u"
}
$u.isSerializableHash = Nb;
Object.defineProperty(Ps, "__esModule", {
    value: !0
});
var ei = $u,
    $b = Ui,
    jb = wi,
    Fd = function() {
        function i(e, t) {
            this._finished = !1, this._inner = new e, this._outer = new e, this.blockSize = this._outer.blockSize, this.digestLength = this._outer.digestLength;
            var s = new Uint8Array(this.blockSize);
            t.length > this.blockSize ? this._inner.update(t).finish(s).clean() : s.set(t);
            for (var o = 0; o < s.length; o++) s[o] ^= 54;
            this._inner.update(s);
            for (var o = 0; o < s.length; o++) s[o] ^= 106;
            this._outer.update(s), ei.isSerializableHash(this._inner) && ei.isSerializableHash(this._outer) && (this._innerKeyedState = this._inner.saveState(), this._outerKeyedState = this._outer.saveState()), jb.wipe(s)
        }
        return i.prototype.reset = function() {
            if (!ei.isSerializableHash(this._inner) || !ei.isSerializableHash(this._outer)) throw new Error("hmac: can't reset() because hash doesn't implement restoreState()");
            return this._inner.restoreState(this._innerKeyedState), this._outer.restoreState(this._outerKeyedState), this._finished = !1, this
        }, i.prototype.clean = function() {
            ei.isSerializableHash(this._inner) && this._inner.cleanSavedState(this._innerKeyedState), ei.isSerializableHash(this._outer) && this._outer.cleanSavedState(this._outerKeyedState), this._inner.clean(), this._outer.clean()
        }, i.prototype.update = function(e) {
            return this._inner.update(e), this
        }, i.prototype.finish = function(e) {
            return this._finished ? (this._outer.finish(e), this) : (this._inner.finish(e), this._outer.update(e.subarray(0, this.digestLength)).finish(e), this._finished = !0, this)
        }, i.prototype.digest = function() {
            var e = new Uint8Array(this.digestLength);
            return this.finish(e), e
        }, i.prototype.saveState = function() {
            if (!ei.isSerializableHash(this._inner)) throw new Error("hmac: can't saveState() because hash doesn't implement it");
            return this._inner.saveState()
        }, i.prototype.restoreState = function(e) {
            if (!ei.isSerializableHash(this._inner) || !ei.isSerializableHash(this._outer)) throw new Error("hmac: can't restoreState() because hash doesn't implement it");
            return this._inner.restoreState(e), this._outer.restoreState(this._outerKeyedState), this._finished = !1, this
        }, i.prototype.cleanSavedState = function(e) {
            if (!ei.isSerializableHash(this._inner)) throw new Error("hmac: can't cleanSavedState() because hash doesn't implement it");
            this._inner.cleanSavedState(e)
        }, i
    }();
Ps.HMAC = Fd;

function Lb(i, e, t) {
    var s = new Fd(i, e);
    s.update(t);
    var o = s.digest();
    return s.clean(), o
}
Ps.hmac = Lb;
Ps.equal = $b.equal;
Object.defineProperty(zd, "__esModule", {
    value: !0
});
var Zl = Ps,
    ef = wi,
    Mb = function() {
        function i(e, t, s, o) {
            s === void 0 && (s = new Uint8Array(0)), this._counter = new Uint8Array(1), this._hash = e, this._info = o;
            var c = Zl.hmac(this._hash, s, t);
            this._hmac = new Zl.HMAC(e, c), this._buffer = new Uint8Array(this._hmac.digestLength), this._bufpos = this._buffer.length
        }
        return i.prototype._fillBuffer = function() {
            this._counter[0]++;
            var e = this._counter[0];
            if (e === 0) throw new Error("hkdf: cannot expand more");
            this._hmac.reset(), e > 1 && this._hmac.update(this._buffer), this._info && this._hmac.update(this._info), this._hmac.update(this._counter), this._hmac.finish(this._buffer), this._bufpos = 0
        }, i.prototype.expand = function(e) {
            for (var t = new Uint8Array(e), s = 0; s < t.length; s++) this._bufpos === this._buffer.length && this._fillBuffer(), t[s] = this._buffer[this._bufpos++];
            return t
        }, i.prototype.clean = function() {
            this._hmac.clean(), ef.wipe(this._buffer), ef.wipe(this._counter), this._bufpos = 0
        }, i
    }(),
    Ub = zd.HKDF = Mb,
    ra = {};
(function(i) {
    Object.defineProperty(i, "__esModule", {
        value: !0
    });
    var e = ea,
        t = wi;
    i.DIGEST_LENGTH = 32, i.BLOCK_SIZE = 64;
    var s = function() {
        function f() {
            this.digestLength = i.DIGEST_LENGTH, this.blockSize = i.BLOCK_SIZE, this._state = new Int32Array(8), this._temp = new Int32Array(64), this._buffer = new Uint8Array(128), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this.reset()
        }
        return f.prototype._initState = function() {
            this._state[0] = 1779033703, this._state[1] = 3144134277, this._state[2] = 1013904242, this._state[3] = 2773480762, this._state[4] = 1359893119, this._state[5] = 2600822924, this._state[6] = 528734635, this._state[7] = 1541459225
        }, f.prototype.reset = function() {
            return this._initState(), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this
        }, f.prototype.clean = function() {
            t.wipe(this._buffer), t.wipe(this._temp), this.reset()
        }, f.prototype.update = function(y, p) {
            if (p === void 0 && (p = y.length), this._finished) throw new Error("SHA256: can't update because hash was finished.");
            var v = 0;
            if (this._bytesHashed += p, this._bufferLength > 0) {
                for (; this._bufferLength < this.blockSize && p > 0;) this._buffer[this._bufferLength++] = y[v++], p--;
                this._bufferLength === this.blockSize && (c(this._temp, this._state, this._buffer, 0, this.blockSize), this._bufferLength = 0)
            }
            for (p >= this.blockSize && (v = c(this._temp, this._state, y, v, p), p %= this.blockSize); p > 0;) this._buffer[this._bufferLength++] = y[v++], p--;
            return this
        }, f.prototype.finish = function(y) {
            if (!this._finished) {
                var p = this._bytesHashed,
                    v = this._bufferLength,
                    D = p / 536870912 | 0,
                    S = p << 3,
                    x = p % 64 < 56 ? 64 : 128;
                this._buffer[v] = 128;
                for (var O = v + 1; O < x - 8; O++) this._buffer[O] = 0;
                e.writeUint32BE(D, this._buffer, x - 8), e.writeUint32BE(S, this._buffer, x - 4), c(this._temp, this._state, this._buffer, 0, x), this._finished = !0
            }
            for (var O = 0; O < this.digestLength / 4; O++) e.writeUint32BE(this._state[O], y, O * 4);
            return this
        }, f.prototype.digest = function() {
            var y = new Uint8Array(this.digestLength);
            return this.finish(y), y
        }, f.prototype.saveState = function() {
            if (this._finished) throw new Error("SHA256: cannot save finished state");
            return {
                state: new Int32Array(this._state),
                buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
                bufferLength: this._bufferLength,
                bytesHashed: this._bytesHashed
            }
        }, f.prototype.restoreState = function(y) {
            return this._state.set(y.state), this._bufferLength = y.bufferLength, y.buffer && this._buffer.set(y.buffer), this._bytesHashed = y.bytesHashed, this._finished = !1, this
        }, f.prototype.cleanSavedState = function(y) {
            t.wipe(y.state), y.buffer && t.wipe(y.buffer), y.bufferLength = 0, y.bytesHashed = 0
        }, f
    }();
    i.SHA256 = s;
    var o = new Int32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);

    function c(f, y, p, v, D) {
        for (; D >= 64;) {
            for (var S = y[0], x = y[1], O = y[2], F = y[3], K = y[4], ne = y[5], $ = y[6], U = y[7], C = 0; C < 16; C++) {
                var A = v + C * 4;
                f[C] = e.readUint32BE(p, A)
            }
            for (var C = 16; C < 64; C++) {
                var E = f[C - 2],
                    u = (E >>> 17 | E << 15) ^ (E >>> 19 | E << 13) ^ E >>> 10;
                E = f[C - 15];
                var b = (E >>> 7 | E << 25) ^ (E >>> 18 | E << 14) ^ E >>> 3;
                f[C] = (u + f[C - 7] | 0) + (b + f[C - 16] | 0)
            }
            for (var C = 0; C < 64; C++) {
                var u = (((K >>> 6 | K << 26) ^ (K >>> 11 | K << 21) ^ (K >>> 25 | K << 7)) + (K & ne ^ ~K & $) | 0) + (U + (o[C] + f[C] | 0) | 0) | 0,
                    b = ((S >>> 2 | S << 30) ^ (S >>> 13 | S << 19) ^ (S >>> 22 | S << 10)) + (S & x ^ S & O ^ x & O) | 0;
                U = $, $ = ne, ne = K, K = F + u | 0, F = O, O = x, x = S, S = u + b | 0
            }
            y[0] += S, y[1] += x, y[2] += O, y[3] += F, y[4] += K, y[5] += ne, y[6] += $, y[7] += U, v += 64, D -= 64
        }
        return v
    }

    function l(f) {
        var y = new s;
        y.update(f);
        var p = y.digest();
        return y.clean(), p
    }
    i.hash = l
})(ra);
var ju = {};
(function(i) {
    Object.defineProperty(i, "__esModule", {
        value: !0
    }), i.sharedKey = i.generateKeyPair = i.generateKeyPairFromSeed = i.scalarMultBase = i.scalarMult = i.SHARED_KEY_LENGTH = i.SECRET_KEY_LENGTH = i.PUBLIC_KEY_LENGTH = void 0;
    const e = Os,
        t = wi;
    i.PUBLIC_KEY_LENGTH = 32, i.SECRET_KEY_LENGTH = 32, i.SHARED_KEY_LENGTH = 32;

    function s(C) {
        const A = new Float64Array(16);
        if (C)
            for (let E = 0; E < C.length; E++) A[E] = C[E];
        return A
    }
    const o = new Uint8Array(32);
    o[0] = 9;
    const c = s([56129, 1]);

    function l(C) {
        let A = 1;
        for (let E = 0; E < 16; E++) {
            let u = C[E] + A + 65535;
            A = Math.floor(u / 65536), C[E] = u - A * 65536
        }
        C[0] += A - 1 + 37 * (A - 1)
    }

    function f(C, A, E) {
        const u = ~(E - 1);
        for (let b = 0; b < 16; b++) {
            const G = u & (C[b] ^ A[b]);
            C[b] ^= G, A[b] ^= G
        }
    }

    function y(C, A) {
        const E = s(),
            u = s();
        for (let b = 0; b < 16; b++) u[b] = A[b];
        l(u), l(u), l(u);
        for (let b = 0; b < 2; b++) {
            E[0] = u[0] - 65517;
            for (let W = 1; W < 15; W++) E[W] = u[W] - 65535 - (E[W - 1] >> 16 & 1), E[W - 1] &= 65535;
            E[15] = u[15] - 32767 - (E[14] >> 16 & 1);
            const G = E[15] >> 16 & 1;
            E[14] &= 65535, f(u, E, 1 - G)
        }
        for (let b = 0; b < 16; b++) C[2 * b] = u[b] & 255, C[2 * b + 1] = u[b] >> 8
    }

    function p(C, A) {
        for (let E = 0; E < 16; E++) C[E] = A[2 * E] + (A[2 * E + 1] << 8);
        C[15] &= 32767
    }

    function v(C, A, E) {
        for (let u = 0; u < 16; u++) C[u] = A[u] + E[u]
    }

    function D(C, A, E) {
        for (let u = 0; u < 16; u++) C[u] = A[u] - E[u]
    }

    function S(C, A, E) {
        let u, b, G = 0,
            W = 0,
            se = 0,
            ue = 0,
            de = 0,
            w = 0,
            T = 0,
            ee = 0,
            Q = 0,
            k = 0,
            V = 0,
            J = 0,
            re = 0,
            be = 0,
            oe = 0,
            we = 0,
            le = 0,
            _e = 0,
            H = 0,
            z = 0,
            j = 0,
            d = 0,
            R = 0,
            ae = 0,
            fe = 0,
            Ie = 0,
            Fe = 0,
            Ke = 0,
            Le = 0,
            dt = 0,
            pt = 0,
            Ue = E[0],
            xe = E[1],
            Ne = E[2],
            $e = E[3],
            qe = E[4],
            Pe = E[5],
            je = E[6],
            Se = E[7],
            Ce = E[8],
            He = E[9],
            Oe = E[10],
            ke = E[11],
            Ge = E[12],
            Ze = E[13],
            et = E[14],
            Je = E[15];
        u = A[0], G += u * Ue, W += u * xe, se += u * Ne, ue += u * $e, de += u * qe, w += u * Pe, T += u * je, ee += u * Se, Q += u * Ce, k += u * He, V += u * Oe, J += u * ke, re += u * Ge, be += u * Ze, oe += u * et, we += u * Je, u = A[1], W += u * Ue, se += u * xe, ue += u * Ne, de += u * $e, w += u * qe, T += u * Pe, ee += u * je, Q += u * Se, k += u * Ce, V += u * He, J += u * Oe, re += u * ke, be += u * Ge, oe += u * Ze, we += u * et, le += u * Je, u = A[2], se += u * Ue, ue += u * xe, de += u * Ne, w += u * $e, T += u * qe, ee += u * Pe, Q += u * je, k += u * Se, V += u * Ce, J += u * He, re += u * Oe, be += u * ke, oe += u * Ge, we += u * Ze, le += u * et, _e += u * Je, u = A[3], ue += u * Ue, de += u * xe, w += u * Ne, T += u * $e, ee += u * qe, Q += u * Pe, k += u * je, V += u * Se, J += u * Ce, re += u * He, be += u * Oe, oe += u * ke, we += u * Ge, le += u * Ze, _e += u * et, H += u * Je, u = A[4], de += u * Ue, w += u * xe, T += u * Ne, ee += u * $e, Q += u * qe, k += u * Pe, V += u * je, J += u * Se, re += u * Ce, be += u * He, oe += u * Oe, we += u * ke, le += u * Ge, _e += u * Ze, H += u * et, z += u * Je, u = A[5], w += u * Ue, T += u * xe, ee += u * Ne, Q += u * $e, k += u * qe, V += u * Pe, J += u * je, re += u * Se, be += u * Ce, oe += u * He, we += u * Oe, le += u * ke, _e += u * Ge, H += u * Ze, z += u * et, j += u * Je, u = A[6], T += u * Ue, ee += u * xe, Q += u * Ne, k += u * $e, V += u * qe, J += u * Pe, re += u * je, be += u * Se, oe += u * Ce, we += u * He, le += u * Oe, _e += u * ke, H += u * Ge, z += u * Ze, j += u * et, d += u * Je, u = A[7], ee += u * Ue, Q += u * xe, k += u * Ne, V += u * $e, J += u * qe, re += u * Pe, be += u * je, oe += u * Se, we += u * Ce, le += u * He, _e += u * Oe, H += u * ke, z += u * Ge, j += u * Ze, d += u * et, R += u * Je, u = A[8], Q += u * Ue, k += u * xe, V += u * Ne, J += u * $e, re += u * qe, be += u * Pe, oe += u * je, we += u * Se, le += u * Ce, _e += u * He, H += u * Oe, z += u * ke, j += u * Ge, d += u * Ze, R += u * et, ae += u * Je, u = A[9], k += u * Ue, V += u * xe, J += u * Ne, re += u * $e, be += u * qe, oe += u * Pe, we += u * je, le += u * Se, _e += u * Ce, H += u * He, z += u * Oe, j += u * ke, d += u * Ge, R += u * Ze, ae += u * et, fe += u * Je, u = A[10], V += u * Ue, J += u * xe, re += u * Ne, be += u * $e, oe += u * qe, we += u * Pe, le += u * je, _e += u * Se, H += u * Ce, z += u * He, j += u * Oe, d += u * ke, R += u * Ge, ae += u * Ze, fe += u * et, Ie += u * Je, u = A[11], J += u * Ue, re += u * xe, be += u * Ne, oe += u * $e, we += u * qe, le += u * Pe, _e += u * je, H += u * Se, z += u * Ce, j += u * He, d += u * Oe, R += u * ke, ae += u * Ge, fe += u * Ze, Ie += u * et, Fe += u * Je, u = A[12], re += u * Ue, be += u * xe, oe += u * Ne, we += u * $e, le += u * qe, _e += u * Pe, H += u * je, z += u * Se, j += u * Ce, d += u * He, R += u * Oe, ae += u * ke, fe += u * Ge, Ie += u * Ze, Fe += u * et, Ke += u * Je, u = A[13], be += u * Ue, oe += u * xe, we += u * Ne, le += u * $e, _e += u * qe, H += u * Pe, z += u * je, j += u * Se, d += u * Ce, R += u * He, ae += u * Oe, fe += u * ke, Ie += u * Ge, Fe += u * Ze, Ke += u * et, Le += u * Je, u = A[14], oe += u * Ue, we += u * xe, le += u * Ne, _e += u * $e, H += u * qe, z += u * Pe, j += u * je, d += u * Se, R += u * Ce, ae += u * He, fe += u * Oe, Ie += u * ke, Fe += u * Ge, Ke += u * Ze, Le += u * et, dt += u * Je, u = A[15], we += u * Ue, le += u * xe, _e += u * Ne, H += u * $e, z += u * qe, j += u * Pe, d += u * je, R += u * Se, ae += u * Ce, fe += u * He, Ie += u * Oe, Fe += u * ke, Ke += u * Ge, Le += u * Ze, dt += u * et, pt += u * Je, G += 38 * le, W += 38 * _e, se += 38 * H, ue += 38 * z, de += 38 * j, w += 38 * d, T += 38 * R, ee += 38 * ae, Q += 38 * fe, k += 38 * Ie, V += 38 * Fe, J += 38 * Ke, re += 38 * Le, be += 38 * dt, oe += 38 * pt, b = 1, u = G + b + 65535, b = Math.floor(u / 65536), G = u - b * 65536, u = W + b + 65535, b = Math.floor(u / 65536), W = u - b * 65536, u = se + b + 65535, b = Math.floor(u / 65536), se = u - b * 65536, u = ue + b + 65535, b = Math.floor(u / 65536), ue = u - b * 65536, u = de + b + 65535, b = Math.floor(u / 65536), de = u - b * 65536, u = w + b + 65535, b = Math.floor(u / 65536), w = u - b * 65536, u = T + b + 65535, b = Math.floor(u / 65536), T = u - b * 65536, u = ee + b + 65535, b = Math.floor(u / 65536), ee = u - b * 65536, u = Q + b + 65535, b = Math.floor(u / 65536), Q = u - b * 65536, u = k + b + 65535, b = Math.floor(u / 65536), k = u - b * 65536, u = V + b + 65535, b = Math.floor(u / 65536), V = u - b * 65536, u = J + b + 65535, b = Math.floor(u / 65536), J = u - b * 65536, u = re + b + 65535, b = Math.floor(u / 65536), re = u - b * 65536, u = be + b + 65535, b = Math.floor(u / 65536), be = u - b * 65536, u = oe + b + 65535, b = Math.floor(u / 65536), oe = u - b * 65536, u = we + b + 65535, b = Math.floor(u / 65536), we = u - b * 65536, G += b - 1 + 37 * (b - 1), b = 1, u = G + b + 65535, b = Math.floor(u / 65536), G = u - b * 65536, u = W + b + 65535, b = Math.floor(u / 65536), W = u - b * 65536, u = se + b + 65535, b = Math.floor(u / 65536), se = u - b * 65536, u = ue + b + 65535, b = Math.floor(u / 65536), ue = u - b * 65536, u = de + b + 65535, b = Math.floor(u / 65536), de = u - b * 65536, u = w + b + 65535, b = Math.floor(u / 65536), w = u - b * 65536, u = T + b + 65535, b = Math.floor(u / 65536), T = u - b * 65536, u = ee + b + 65535, b = Math.floor(u / 65536), ee = u - b * 65536, u = Q + b + 65535, b = Math.floor(u / 65536), Q = u - b * 65536, u = k + b + 65535, b = Math.floor(u / 65536), k = u - b * 65536, u = V + b + 65535, b = Math.floor(u / 65536), V = u - b * 65536, u = J + b + 65535, b = Math.floor(u / 65536), J = u - b * 65536, u = re + b + 65535, b = Math.floor(u / 65536), re = u - b * 65536, u = be + b + 65535, b = Math.floor(u / 65536), be = u - b * 65536, u = oe + b + 65535, b = Math.floor(u / 65536), oe = u - b * 65536, u = we + b + 65535, b = Math.floor(u / 65536), we = u - b * 65536, G += b - 1 + 37 * (b - 1), C[0] = G, C[1] = W, C[2] = se, C[3] = ue, C[4] = de, C[5] = w, C[6] = T, C[7] = ee, C[8] = Q, C[9] = k, C[10] = V, C[11] = J, C[12] = re, C[13] = be, C[14] = oe, C[15] = we
    }

    function x(C, A) {
        S(C, A, A)
    }

    function O(C, A) {
        const E = s();
        for (let u = 0; u < 16; u++) E[u] = A[u];
        for (let u = 253; u >= 0; u--) x(E, E), u !== 2 && u !== 4 && S(E, E, A);
        for (let u = 0; u < 16; u++) C[u] = E[u]
    }

    function F(C, A) {
        const E = new Uint8Array(32),
            u = new Float64Array(80),
            b = s(),
            G = s(),
            W = s(),
            se = s(),
            ue = s(),
            de = s();
        for (let Q = 0; Q < 31; Q++) E[Q] = C[Q];
        E[31] = C[31] & 127 | 64, E[0] &= 248, p(u, A);
        for (let Q = 0; Q < 16; Q++) G[Q] = u[Q];
        b[0] = se[0] = 1;
        for (let Q = 254; Q >= 0; --Q) {
            const k = E[Q >>> 3] >>> (Q & 7) & 1;
            f(b, G, k), f(W, se, k), v(ue, b, W), D(b, b, W), v(W, G, se), D(G, G, se), x(se, ue), x(de, b), S(b, W, b), S(W, G, ue), v(ue, b, W), D(b, b, W), x(G, b), D(W, se, de), S(b, W, c), v(b, b, se), S(W, W, b), S(b, se, de), S(se, G, u), x(G, ue), f(b, G, k), f(W, se, k)
        }
        for (let Q = 0; Q < 16; Q++) u[Q + 16] = b[Q], u[Q + 32] = W[Q], u[Q + 48] = G[Q], u[Q + 64] = se[Q];
        const w = u.subarray(32),
            T = u.subarray(16);
        O(w, w), S(T, T, w);
        const ee = new Uint8Array(32);
        return y(ee, T), ee
    }
    i.scalarMult = F;

    function K(C) {
        return F(C, o)
    }
    i.scalarMultBase = K;

    function ne(C) {
        if (C.length !== i.SECRET_KEY_LENGTH) throw new Error(`x25519: seed must be ${i.SECRET_KEY_LENGTH} bytes`);
        const A = new Uint8Array(C);
        return {
            publicKey: K(A),
            secretKey: A
        }
    }
    i.generateKeyPairFromSeed = ne;

    function $(C) {
        const A = (0, e.randomBytes)(32, C),
            E = ne(A);
        return (0, t.wipe)(A), E
    }
    i.generateKeyPair = $;

    function U(C, A, E = !1) {
        if (C.length !== i.PUBLIC_KEY_LENGTH) throw new Error("X25519: incorrect secret key length");
        if (A.length !== i.PUBLIC_KEY_LENGTH) throw new Error("X25519: incorrect public key length");
        const u = F(C, A);
        if (E) {
            let b = 0;
            for (let G = 0; G < u.length; G++) b |= u[G];
            if (b === 0) throw new Error("X25519: invalid shared key")
        }
        return u
    }
    i.sharedKey = U
})(ju);

function Lu(i) {
    return globalThis.Buffer != null ? new Uint8Array(i.buffer, i.byteOffset, i.byteLength) : i
}

function Hd(i = 0) {
    return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? Lu(globalThis.Buffer.allocUnsafe(i)) : new Uint8Array(i)
}

function su(i, e) {
    e || (e = i.reduce((o, c) => o + c.length, 0));
    const t = Hd(e);
    let s = 0;
    for (const o of i) t.set(o, s), s += o.length;
    return Lu(t)
}

function qb(i, e) {
    if (i.length >= 255) throw new TypeError("Alphabet too long");
    for (var t = new Uint8Array(256), s = 0; s < t.length; s++) t[s] = 255;
    for (var o = 0; o < i.length; o++) {
        var c = i.charAt(o),
            l = c.charCodeAt(0);
        if (t[l] !== 255) throw new TypeError(c + " is ambiguous");
        t[l] = o
    }
    var f = i.length,
        y = i.charAt(0),
        p = Math.log(f) / Math.log(256),
        v = Math.log(256) / Math.log(f);

    function D(O) {
        if (O instanceof Uint8Array || (ArrayBuffer.isView(O) ? O = new Uint8Array(O.buffer, O.byteOffset, O.byteLength) : Array.isArray(O) && (O = Uint8Array.from(O))), !(O instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
        if (O.length === 0) return "";
        for (var F = 0, K = 0, ne = 0, $ = O.length; ne !== $ && O[ne] === 0;) ne++, F++;
        for (var U = ($ - ne) * v + 1 >>> 0, C = new Uint8Array(U); ne !== $;) {
            for (var A = O[ne], E = 0, u = U - 1;
                (A !== 0 || E < K) && u !== -1; u--, E++) A += 256 * C[u] >>> 0, C[u] = A % f >>> 0, A = A / f >>> 0;
            if (A !== 0) throw new Error("Non-zero carry");
            K = E, ne++
        }
        for (var b = U - K; b !== U && C[b] === 0;) b++;
        for (var G = y.repeat(F); b < U; ++b) G += i.charAt(C[b]);
        return G
    }

    function S(O) {
        if (typeof O != "string") throw new TypeError("Expected String");
        if (O.length === 0) return new Uint8Array;
        var F = 0;
        if (O[F] !== " ") {
            for (var K = 0, ne = 0; O[F] === y;) K++, F++;
            for (var $ = (O.length - F) * p + 1 >>> 0, U = new Uint8Array($); O[F];) {
                var C = t[O.charCodeAt(F)];
                if (C === 255) return;
                for (var A = 0, E = $ - 1;
                    (C !== 0 || A < ne) && E !== -1; E--, A++) C += f * U[E] >>> 0, U[E] = C % 256 >>> 0, C = C / 256 >>> 0;
                if (C !== 0) throw new Error("Non-zero carry");
                ne = A, F++
            }
            if (O[F] !== " ") {
                for (var u = $ - ne; u !== $ && U[u] === 0;) u++;
                for (var b = new Uint8Array(K + ($ - u)), G = K; u !== $;) b[G++] = U[u++];
                return b
            }
        }
    }

    function x(O) {
        var F = S(O);
        if (F) return F;
        throw new Error(`Non-${e} character`)
    }
    return {
        encode: D,
        decodeUnsafe: S,
        decode: x
    }
}
var zb = qb,
    Fb = zb;
const Hb = i => {
        if (i instanceof Uint8Array && i.constructor.name === "Uint8Array") return i;
        if (i instanceof ArrayBuffer) return new Uint8Array(i);
        if (ArrayBuffer.isView(i)) return new Uint8Array(i.buffer, i.byteOffset, i.byteLength);
        throw new Error("Unknown type, must be binary type")
    },
    Bb = i => new TextEncoder().encode(i),
    Kb = i => new TextDecoder().decode(i);
class kb {
    constructor(e, t, s) {
        this.name = e, this.prefix = t, this.baseEncode = s
    }
    encode(e) {
        if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;
        throw Error("Unknown type, must be binary type")
    }
}
class Vb {
    constructor(e, t, s) {
        if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
        this.prefixCodePoint = t.codePointAt(0), this.baseDecode = s
    }
    decode(e) {
        if (typeof e == "string") {
            if (e.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
            return this.baseDecode(e.slice(this.prefix.length))
        } else throw Error("Can only multibase decode strings")
    }
    or(e) {
        return Bd(this, e)
    }
}
class Gb {
    constructor(e) {
        this.decoders = e
    }
    or(e) {
        return Bd(this, e)
    }
    decode(e) {
        const t = e[0],
            s = this.decoders[t];
        if (s) return s.decode(e);
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)
    }
}
const Bd = (i, e) => new Gb({ ...i.decoders || {
        [i.prefix]: i
    },
    ...e.decoders || {
        [e.prefix]: e
    }
});
class Wb {
    constructor(e, t, s, o) {
        this.name = e, this.prefix = t, this.baseEncode = s, this.baseDecode = o, this.encoder = new kb(e, t, s), this.decoder = new Vb(e, t, o)
    }
    encode(e) {
        return this.encoder.encode(e)
    }
    decode(e) {
        return this.decoder.decode(e)
    }
}
const ia = ({
        name: i,
        prefix: e,
        encode: t,
        decode: s
    }) => new Wb(i, e, t, s),
    Cs = ({
        prefix: i,
        name: e,
        alphabet: t
    }) => {
        const {
            encode: s,
            decode: o
        } = Fb(t, e);
        return ia({
            prefix: i,
            name: e,
            encode: s,
            decode: c => Hb(o(c))
        })
    },
    Yb = (i, e, t, s) => {
        const o = {};
        for (let v = 0; v < e.length; ++v) o[e[v]] = v;
        let c = i.length;
        for (; i[c - 1] === "=";) --c;
        const l = new Uint8Array(c * t / 8 | 0);
        let f = 0,
            y = 0,
            p = 0;
        for (let v = 0; v < c; ++v) {
            const D = o[i[v]];
            if (D === void 0) throw new SyntaxError(`Non-${s} character`);
            y = y << t | D, f += t, f >= 8 && (f -= 8, l[p++] = 255 & y >> f)
        }
        if (f >= t || 255 & y << 8 - f) throw new SyntaxError("Unexpected end of data");
        return l
    },
    Jb = (i, e, t) => {
        const s = e[e.length - 1] === "=",
            o = (1 << t) - 1;
        let c = "",
            l = 0,
            f = 0;
        for (let y = 0; y < i.length; ++y)
            for (f = f << 8 | i[y], l += 8; l > t;) l -= t, c += e[o & f >> l];
        if (l && (c += e[o & f << t - l]), s)
            for (; c.length * t & 7;) c += "=";
        return c
    },
    Wt = ({
        name: i,
        prefix: e,
        bitsPerChar: t,
        alphabet: s
    }) => ia({
        prefix: e,
        name: i,
        encode(o) {
            return Jb(o, s, t)
        },
        decode(o) {
            return Yb(o, s, t, i)
        }
    }),
    Qb = ia({
        prefix: "\0",
        name: "identity",
        encode: i => Kb(i),
        decode: i => Bb(i)
    }),
    Xb = Object.freeze(Object.defineProperty({
        __proto__: null,
        identity: Qb
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    Zb = Wt({
        prefix: "0",
        name: "base2",
        alphabet: "01",
        bitsPerChar: 1
    }),
    ew = Object.freeze(Object.defineProperty({
        __proto__: null,
        base2: Zb
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    tw = Wt({
        prefix: "7",
        name: "base8",
        alphabet: "01234567",
        bitsPerChar: 3
    }),
    rw = Object.freeze(Object.defineProperty({
        __proto__: null,
        base8: tw
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    iw = Cs({
        prefix: "9",
        name: "base10",
        alphabet: "0123456789"
    }),
    nw = Object.freeze(Object.defineProperty({
        __proto__: null,
        base10: iw
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    sw = Wt({
        prefix: "f",
        name: "base16",
        alphabet: "0123456789abcdef",
        bitsPerChar: 4
    }),
    ow = Wt({
        prefix: "F",
        name: "base16upper",
        alphabet: "0123456789ABCDEF",
        bitsPerChar: 4
    }),
    aw = Object.freeze(Object.defineProperty({
        __proto__: null,
        base16: sw,
        base16upper: ow
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    cw = Wt({
        prefix: "b",
        name: "base32",
        alphabet: "abcdefghijklmnopqrstuvwxyz234567",
        bitsPerChar: 5
    }),
    uw = Wt({
        prefix: "B",
        name: "base32upper",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
        bitsPerChar: 5
    }),
    hw = Wt({
        prefix: "c",
        name: "base32pad",
        alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
        bitsPerChar: 5
    }),
    lw = Wt({
        prefix: "C",
        name: "base32padupper",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
        bitsPerChar: 5
    }),
    fw = Wt({
        prefix: "v",
        name: "base32hex",
        alphabet: "0123456789abcdefghijklmnopqrstuv",
        bitsPerChar: 5
    }),
    dw = Wt({
        prefix: "V",
        name: "base32hexupper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
        bitsPerChar: 5
    }),
    pw = Wt({
        prefix: "t",
        name: "base32hexpad",
        alphabet: "0123456789abcdefghijklmnopqrstuv=",
        bitsPerChar: 5
    }),
    gw = Wt({
        prefix: "T",
        name: "base32hexpadupper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
        bitsPerChar: 5
    }),
    yw = Wt({
        prefix: "h",
        name: "base32z",
        alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
        bitsPerChar: 5
    }),
    vw = Object.freeze(Object.defineProperty({
        __proto__: null,
        base32: cw,
        base32hex: fw,
        base32hexpad: pw,
        base32hexpadupper: gw,
        base32hexupper: dw,
        base32pad: hw,
        base32padupper: lw,
        base32upper: uw,
        base32z: yw
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    _w = Cs({
        prefix: "k",
        name: "base36",
        alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
    }),
    mw = Cs({
        prefix: "K",
        name: "base36upper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    }),
    bw = Object.freeze(Object.defineProperty({
        __proto__: null,
        base36: _w,
        base36upper: mw
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    ww = Cs({
        name: "base58btc",
        prefix: "z",
        alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    }),
    Ew = Cs({
        name: "base58flickr",
        prefix: "Z",
        alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
    }),
    Dw = Object.freeze(Object.defineProperty({
        __proto__: null,
        base58btc: ww,
        base58flickr: Ew
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    Sw = Wt({
        prefix: "m",
        name: "base64",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
        bitsPerChar: 6
    }),
    Iw = Wt({
        prefix: "M",
        name: "base64pad",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
        bitsPerChar: 6
    }),
    xw = Wt({
        prefix: "u",
        name: "base64url",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
        bitsPerChar: 6
    }),
    Ow = Wt({
        prefix: "U",
        name: "base64urlpad",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
        bitsPerChar: 6
    }),
    Pw = Object.freeze(Object.defineProperty({
        __proto__: null,
        base64: Sw,
        base64pad: Iw,
        base64url: xw,
        base64urlpad: Ow
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    Kd = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"),
    Cw = Kd.reduce((i, e, t) => (i[t] = e, i), []),
    Tw = Kd.reduce((i, e, t) => (i[e.codePointAt(0)] = t, i), []);

function Aw(i) {
    return i.reduce((e, t) => (e += Cw[t], e), "")
}

function Rw(i) {
    const e = [];
    for (const t of i) {
        const s = Tw[t.codePointAt(0)];
        if (s === void 0) throw new Error(`Non-base256emoji character: ${t}`);
        e.push(s)
    }
    return new Uint8Array(e)
}
const Nw = ia({
        prefix: "🚀",
        name: "base256emoji",
        encode: Aw,
        decode: Rw
    }),
    $w = Object.freeze(Object.defineProperty({
        __proto__: null,
        base256emoji: Nw
    }, Symbol.toStringTag, {
        value: "Module"
    }));
new TextEncoder;
new TextDecoder;
const tf = { ...Xb,
    ...ew,
    ...rw,
    ...nw,
    ...aw,
    ...vw,
    ...bw,
    ...Dw,
    ...Pw,
    ...$w
};

function kd(i, e, t, s) {
    return {
        name: i,
        prefix: e,
        encoder: {
            name: i,
            prefix: e,
            encode: t
        },
        decoder: {
            decode: s
        }
    }
}
const rf = kd("utf8", "u", i => "u" + new TextDecoder("utf8").decode(i), i => new TextEncoder().encode(i.substring(1))),
    jc = kd("ascii", "a", i => {
        let e = "a";
        for (let t = 0; t < i.length; t++) e += String.fromCharCode(i[t]);
        return e
    }, i => {
        i = i.substring(1);
        const e = Hd(i.length);
        for (let t = 0; t < i.length; t++) e[t] = i.charCodeAt(t);
        return e
    }),
    Vd = {
        utf8: rf,
        "utf-8": rf,
        hex: tf.base16,
        latin1: jc,
        ascii: jc,
        binary: jc,
        ...tf
    };

function mr(i, e = "utf8") {
    const t = Vd[e];
    if (!t) throw new Error(`Unsupported encoding "${e}"`);
    return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? Lu(globalThis.Buffer.from(i, "utf-8")) : t.decoder.decode(`${t.prefix}${i}`)
}

function hr(i, e = "utf8") {
    const t = Vd[e];
    if (!t) throw new Error(`Unsupported encoding "${e}"`);
    return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(i.buffer, i.byteOffset, i.byteLength).toString("utf8") : t.encoder.encode(i).substring(1)
}
var nf = function(i, e, t) {
        if (t || arguments.length === 2)
            for (var s = 0, o = e.length, c; s < o; s++)(c || !(s in e)) && (c || (c = Array.prototype.slice.call(e, 0, s)), c[s] = e[s]);
        return i.concat(c || Array.prototype.slice.call(e))
    },
    jw = function() {
        function i(e, t, s) {
            this.name = e, this.version = t, this.os = s, this.type = "browser"
        }
        return i
    }(),
    Lw = function() {
        function i(e) {
            this.version = e, this.type = "node", this.name = "node", this.os = process.platform
        }
        return i
    }(),
    Mw = function() {
        function i(e, t, s, o) {
            this.name = e, this.version = t, this.os = s, this.bot = o, this.type = "bot-device"
        }
        return i
    }(),
    Uw = function() {
        function i() {
            this.type = "bot", this.bot = !0, this.name = "bot", this.version = null, this.os = null
        }
        return i
    }(),
    qw = function() {
        function i() {
            this.type = "react-native", this.name = "react-native", this.version = null, this.os = null
        }
        return i
    }(),
    zw = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/,
    Fw = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/,
    sf = 3,
    Hw = [
        ["aol", /AOLShield\/([0-9\._]+)/],
        ["edge", /Edge\/([0-9\._]+)/],
        ["edge-ios", /EdgiOS\/([0-9\._]+)/],
        ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
        ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
        ["samsung", /SamsungBrowser\/([0-9\.]+)/],
        ["silk", /\bSilk\/([0-9._-]+)\b/],
        ["miui", /MiuiBrowser\/([0-9\.]+)$/],
        ["beaker", /BeakerBrowser\/([0-9\.]+)/],
        ["edge-chromium", /EdgA?\/([0-9\.]+)/],
        ["chromium-webview", /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
        ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
        ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
        ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
        ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
        ["fxios", /FxiOS\/([0-9\.]+)/],
        ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
        ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
        ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
        ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
        ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
        ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
        ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
        ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
        ["ie", /MSIE\s(7\.0)/],
        ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
        ["android", /Android\s([0-9\.]+)/],
        ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
        ["safari", /Version\/([0-9\._]+).*Safari/],
        ["facebook", /FB[AS]V\/([0-9\.]+)/],
        ["instagram", /Instagram\s([0-9\.]+)/],
        ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
        ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
        ["curl", /^curl\/([0-9\.]+)$/],
        ["searchbot", zw]
    ],
    of = [
        ["iOS", /iP(hone|od|ad)/],
        ["Android OS", /Android/],
        ["BlackBerry OS", /BlackBerry|BB10/],
        ["Windows Mobile", /IEMobile/],
        ["Amazon OS", /Kindle/],
        ["Windows 3.11", /Win16/],
        ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
        ["Windows 98", /(Windows 98)|(Win98)/],
        ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
        ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
        ["Windows Server 2003", /(Windows NT 5.2)/],
        ["Windows Vista", /(Windows NT 6.0)/],
        ["Windows 7", /(Windows NT 6.1)/],
        ["Windows 8", /(Windows NT 6.2)/],
        ["Windows 8.1", /(Windows NT 6.3)/],
        ["Windows 10", /(Windows NT 10.0)/],
        ["Windows ME", /Windows ME/],
        ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
        ["Open BSD", /OpenBSD/],
        ["Sun OS", /SunOS/],
        ["Chrome OS", /CrOS/],
        ["Linux", /(Linux)|(X11)/],
        ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
        ["QNX", /QNX/],
        ["BeOS", /BeOS/],
        ["OS/2", /OS\/2/]
    ];

function Bw(i) {
    return i ? af(i) : typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative" ? new qw : typeof navigator < "u" ? af(navigator.userAgent) : Vw()
}

function Kw(i) {
    return i !== "" && Hw.reduce(function(e, t) {
        var s = t[0],
            o = t[1];
        if (e) return e;
        var c = o.exec(i);
        return !!c && [s, c]
    }, !1)
}

function af(i) {
    var e = Kw(i);
    if (!e) return null;
    var t = e[0],
        s = e[1];
    if (t === "searchbot") return new Uw;
    var o = s[1] && s[1].split(".").join("_").split("_").slice(0, 3);
    o ? o.length < sf && (o = nf(nf([], o, !0), Gw(sf - o.length), !0)) : o = [];
    var c = o.join("."),
        l = kw(i),
        f = Fw.exec(i);
    return f && f[1] ? new Mw(t, c, l, f[1]) : new jw(t, c, l)
}

function kw(i) {
    for (var e = 0, t = of .length; e < t; e++) {
        var s = of [e],
            o = s[0],
            c = s[1],
            l = c.exec(i);
        if (l) return o
    }
    return null
}

function Vw() {
    var i = typeof process < "u" && process.version;
    return i ? new Lw(process.version.slice(1)) : null
}

function Gw(i) {
    for (var e = [], t = 0; t < i; t++) e.push("0");
    return e
}
var ve = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var ou = function(i, e) {
    return ou = Object.setPrototypeOf || {
        __proto__: []
    }
    instanceof Array && function(t, s) {
        t.__proto__ = s
    } || function(t, s) {
        for (var o in s) s.hasOwnProperty(o) && (t[o] = s[o])
    }, ou(i, e)
};

function Ww(i, e) {
    ou(i, e);

    function t() {
        this.constructor = i
    }
    i.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t)
}
var au = function() {
    return au = Object.assign || function(e) {
        for (var t, s = 1, o = arguments.length; s < o; s++) {
            t = arguments[s];
            for (var c in t) Object.prototype.hasOwnProperty.call(t, c) && (e[c] = t[c])
        }
        return e
    }, au.apply(this, arguments)
};

function Yw(i, e) {
    var t = {};
    for (var s in i) Object.prototype.hasOwnProperty.call(i, s) && e.indexOf(s) < 0 && (t[s] = i[s]);
    if (i != null && typeof Object.getOwnPropertySymbols == "function")
        for (var o = 0, s = Object.getOwnPropertySymbols(i); o < s.length; o++) e.indexOf(s[o]) < 0 && Object.prototype.propertyIsEnumerable.call(i, s[o]) && (t[s[o]] = i[s[o]]);
    return t
}

function Jw(i, e, t, s) {
    var o = arguments.length,
        c = o < 3 ? e : s === null ? s = Object.getOwnPropertyDescriptor(e, t) : s,
        l;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") c = Reflect.decorate(i, e, t, s);
    else
        for (var f = i.length - 1; f >= 0; f--)(l = i[f]) && (c = (o < 3 ? l(c) : o > 3 ? l(e, t, c) : l(e, t)) || c);
    return o > 3 && c && Object.defineProperty(e, t, c), c
}

function Qw(i, e) {
    return function(t, s) {
        e(t, s, i)
    }
}

function Xw(i, e) {
    if (typeof Reflect == "object" && typeof Reflect.metadata == "function") return Reflect.metadata(i, e)
}

function Zw(i, e, t, s) {
    function o(c) {
        return c instanceof t ? c : new t(function(l) {
            l(c)
        })
    }
    return new(t || (t = Promise))(function(c, l) {
        function f(v) {
            try {
                p(s.next(v))
            } catch (D) {
                l(D)
            }
        }

        function y(v) {
            try {
                p(s.throw(v))
            } catch (D) {
                l(D)
            }
        }

        function p(v) {
            v.done ? c(v.value) : o(v.value).then(f, y)
        }
        p((s = s.apply(i, e || [])).next())
    })
}

function e1(i, e) {
    var t = {
            label: 0,
            sent: function() {
                if (c[0] & 1) throw c[1];
                return c[1]
            },
            trys: [],
            ops: []
        },
        s, o, c, l;
    return l = {
        next: f(0),
        throw: f(1),
        return: f(2)
    }, typeof Symbol == "function" && (l[Symbol.iterator] = function() {
        return this
    }), l;

    function f(p) {
        return function(v) {
            return y([p, v])
        }
    }

    function y(p) {
        if (s) throw new TypeError("Generator is already executing.");
        for (; t;) try {
            if (s = 1, o && (c = p[0] & 2 ? o.return : p[0] ? o.throw || ((c = o.return) && c.call(o), 0) : o.next) && !(c = c.call(o, p[1])).done) return c;
            switch (o = 0, c && (p = [p[0] & 2, c.value]), p[0]) {
                case 0:
                case 1:
                    c = p;
                    break;
                case 4:
                    return t.label++, {
                        value: p[1],
                        done: !1
                    };
                case 5:
                    t.label++, o = p[1], p = [0];
                    continue;
                case 7:
                    p = t.ops.pop(), t.trys.pop();
                    continue;
                default:
                    if (c = t.trys, !(c = c.length > 0 && c[c.length - 1]) && (p[0] === 6 || p[0] === 2)) {
                        t = 0;
                        continue
                    }
                    if (p[0] === 3 && (!c || p[1] > c[0] && p[1] < c[3])) {
                        t.label = p[1];
                        break
                    }
                    if (p[0] === 6 && t.label < c[1]) {
                        t.label = c[1], c = p;
                        break
                    }
                    if (c && t.label < c[2]) {
                        t.label = c[2], t.ops.push(p);
                        break
                    }
                    c[2] && t.ops.pop(), t.trys.pop();
                    continue
            }
            p = e.call(i, t)
        } catch (v) {
            p = [6, v], o = 0
        } finally {
            s = c = 0
        }
        if (p[0] & 5) throw p[1];
        return {
            value: p[0] ? p[1] : void 0,
            done: !0
        }
    }
}

function t1(i, e, t, s) {
    s === void 0 && (s = t), i[s] = e[t]
}

function r1(i, e) {
    for (var t in i) t !== "default" && !e.hasOwnProperty(t) && (e[t] = i[t])
}

function cu(i) {
    var e = typeof Symbol == "function" && Symbol.iterator,
        t = e && i[e],
        s = 0;
    if (t) return t.call(i);
    if (i && typeof i.length == "number") return {
        next: function() {
            return i && s >= i.length && (i = void 0), {
                value: i && i[s++],
                done: !i
            }
        }
    };
    throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.")
}

function Gd(i, e) {
    var t = typeof Symbol == "function" && i[Symbol.iterator];
    if (!t) return i;
    var s = t.call(i),
        o, c = [],
        l;
    try {
        for (;
            (e === void 0 || e-- > 0) && !(o = s.next()).done;) c.push(o.value)
    } catch (f) {
        l = {
            error: f
        }
    } finally {
        try {
            o && !o.done && (t = s.return) && t.call(s)
        } finally {
            if (l) throw l.error
        }
    }
    return c
}

function i1() {
    for (var i = [], e = 0; e < arguments.length; e++) i = i.concat(Gd(arguments[e]));
    return i
}

function n1() {
    for (var i = 0, e = 0, t = arguments.length; e < t; e++) i += arguments[e].length;
    for (var s = Array(i), o = 0, e = 0; e < t; e++)
        for (var c = arguments[e], l = 0, f = c.length; l < f; l++, o++) s[o] = c[l];
    return s
}

function bs(i) {
    return this instanceof bs ? (this.v = i, this) : new bs(i)
}

function s1(i, e, t) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var s = t.apply(i, e || []),
        o, c = [];
    return o = {}, l("next"), l("throw"), l("return"), o[Symbol.asyncIterator] = function() {
        return this
    }, o;

    function l(S) {
        s[S] && (o[S] = function(x) {
            return new Promise(function(O, F) {
                c.push([S, x, O, F]) > 1 || f(S, x)
            })
        })
    }

    function f(S, x) {
        try {
            y(s[S](x))
        } catch (O) {
            D(c[0][3], O)
        }
    }

    function y(S) {
        S.value instanceof bs ? Promise.resolve(S.value.v).then(p, v) : D(c[0][2], S)
    }

    function p(S) {
        f("next", S)
    }

    function v(S) {
        f("throw", S)
    }

    function D(S, x) {
        S(x), c.shift(), c.length && f(c[0][0], c[0][1])
    }
}

function o1(i) {
    var e, t;
    return e = {}, s("next"), s("throw", function(o) {
        throw o
    }), s("return"), e[Symbol.iterator] = function() {
        return this
    }, e;

    function s(o, c) {
        e[o] = i[o] ? function(l) {
            return (t = !t) ? {
                value: bs(i[o](l)),
                done: o === "return"
            } : c ? c(l) : l
        } : c
    }
}

function a1(i) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var e = i[Symbol.asyncIterator],
        t;
    return e ? e.call(i) : (i = typeof cu == "function" ? cu(i) : i[Symbol.iterator](), t = {}, s("next"), s("throw"), s("return"), t[Symbol.asyncIterator] = function() {
        return this
    }, t);

    function s(c) {
        t[c] = i[c] && function(l) {
            return new Promise(function(f, y) {
                l = i[c](l), o(f, y, l.done, l.value)
            })
        }
    }

    function o(c, l, f, y) {
        Promise.resolve(y).then(function(p) {
            c({
                value: p,
                done: f
            })
        }, l)
    }
}

function c1(i, e) {
    return Object.defineProperty ? Object.defineProperty(i, "raw", {
        value: e
    }) : i.raw = e, i
}

function u1(i) {
    if (i && i.__esModule) return i;
    var e = {};
    if (i != null)
        for (var t in i) Object.hasOwnProperty.call(i, t) && (e[t] = i[t]);
    return e.default = i, e
}

function h1(i) {
    return i && i.__esModule ? i : {
        default: i
    }
}

function l1(i, e) {
    if (!e.has(i)) throw new TypeError("attempted to get private field on non-instance");
    return e.get(i)
}

function f1(i, e, t) {
    if (!e.has(i)) throw new TypeError("attempted to set private field on non-instance");
    return e.set(i, t), t
}
const d1 = Object.freeze(Object.defineProperty({
        __proto__: null,
        get __assign() {
            return au
        },
        __asyncDelegator: o1,
        __asyncGenerator: s1,
        __asyncValues: a1,
        __await: bs,
        __awaiter: Zw,
        __classPrivateFieldGet: l1,
        __classPrivateFieldSet: f1,
        __createBinding: t1,
        __decorate: Jw,
        __exportStar: r1,
        __extends: Ww,
        __generator: e1,
        __importDefault: h1,
        __importStar: u1,
        __makeTemplateObject: c1,
        __metadata: Xw,
        __param: Qw,
        __read: Gd,
        __rest: Yw,
        __spread: i1,
        __spreadArrays: n1,
        __values: cu
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    na = Un(d1);
var Lc = {},
    us = {},
    cf;

function p1() {
    if (cf) return us;
    cf = 1, Object.defineProperty(us, "__esModule", {
        value: !0
    }), us.delay = void 0;

    function i(e) {
        return new Promise(t => {
            setTimeout(() => {
                t(!0)
            }, e)
        })
    }
    return us.delay = i, us
}
var en = {},
    Mc = {},
    tn = {},
    uf;

function g1() {
    return uf || (uf = 1, Object.defineProperty(tn, "__esModule", {
        value: !0
    }), tn.ONE_THOUSAND = tn.ONE_HUNDRED = void 0, tn.ONE_HUNDRED = 100, tn.ONE_THOUSAND = 1e3), tn
}
var Uc = {},
    hf;

function y1() {
    return hf || (hf = 1, function(i) {
        Object.defineProperty(i, "__esModule", {
            value: !0
        }), i.ONE_YEAR = i.FOUR_WEEKS = i.THREE_WEEKS = i.TWO_WEEKS = i.ONE_WEEK = i.THIRTY_DAYS = i.SEVEN_DAYS = i.FIVE_DAYS = i.THREE_DAYS = i.ONE_DAY = i.TWENTY_FOUR_HOURS = i.TWELVE_HOURS = i.SIX_HOURS = i.THREE_HOURS = i.ONE_HOUR = i.SIXTY_MINUTES = i.THIRTY_MINUTES = i.TEN_MINUTES = i.FIVE_MINUTES = i.ONE_MINUTE = i.SIXTY_SECONDS = i.THIRTY_SECONDS = i.TEN_SECONDS = i.FIVE_SECONDS = i.ONE_SECOND = void 0, i.ONE_SECOND = 1, i.FIVE_SECONDS = 5, i.TEN_SECONDS = 10, i.THIRTY_SECONDS = 30, i.SIXTY_SECONDS = 60, i.ONE_MINUTE = i.SIXTY_SECONDS, i.FIVE_MINUTES = i.ONE_MINUTE * 5, i.TEN_MINUTES = i.ONE_MINUTE * 10, i.THIRTY_MINUTES = i.ONE_MINUTE * 30, i.SIXTY_MINUTES = i.ONE_MINUTE * 60, i.ONE_HOUR = i.SIXTY_MINUTES, i.THREE_HOURS = i.ONE_HOUR * 3, i.SIX_HOURS = i.ONE_HOUR * 6, i.TWELVE_HOURS = i.ONE_HOUR * 12, i.TWENTY_FOUR_HOURS = i.ONE_HOUR * 24, i.ONE_DAY = i.TWENTY_FOUR_HOURS, i.THREE_DAYS = i.ONE_DAY * 3, i.FIVE_DAYS = i.ONE_DAY * 5, i.SEVEN_DAYS = i.ONE_DAY * 7, i.THIRTY_DAYS = i.ONE_DAY * 30, i.ONE_WEEK = i.SEVEN_DAYS, i.TWO_WEEKS = i.ONE_WEEK * 2, i.THREE_WEEKS = i.ONE_WEEK * 3, i.FOUR_WEEKS = i.ONE_WEEK * 4, i.ONE_YEAR = i.ONE_DAY * 365
    }(Uc)), Uc
}
var lf;

function Wd() {
    return lf || (lf = 1, function(i) {
        Object.defineProperty(i, "__esModule", {
            value: !0
        });
        const e = na;
        e.__exportStar(g1(), i), e.__exportStar(y1(), i)
    }(Mc)), Mc
}
var ff;

function v1() {
    if (ff) return en;
    ff = 1, Object.defineProperty(en, "__esModule", {
        value: !0
    }), en.fromMiliseconds = en.toMiliseconds = void 0;
    const i = Wd();

    function e(s) {
        return s * i.ONE_THOUSAND
    }
    en.toMiliseconds = e;

    function t(s) {
        return Math.floor(s / i.ONE_THOUSAND)
    }
    return en.fromMiliseconds = t, en
}
var df;

function _1() {
    return df || (df = 1, function(i) {
        Object.defineProperty(i, "__esModule", {
            value: !0
        });
        const e = na;
        e.__exportStar(p1(), i), e.__exportStar(v1(), i)
    }(Lc)), Lc
}
var Rn = {},
    pf;

function m1() {
    if (pf) return Rn;
    pf = 1, Object.defineProperty(Rn, "__esModule", {
        value: !0
    }), Rn.Watch = void 0;
    class i {
        constructor() {
            this.timestamps = new Map
        }
        start(t) {
            if (this.timestamps.has(t)) throw new Error(`Watch already started for label: ${t}`);
            this.timestamps.set(t, {
                started: Date.now()
            })
        }
        stop(t) {
            const s = this.get(t);
            if (typeof s.elapsed < "u") throw new Error(`Watch already stopped for label: ${t}`);
            const o = Date.now() - s.started;
            this.timestamps.set(t, {
                started: s.started,
                elapsed: o
            })
        }
        get(t) {
            const s = this.timestamps.get(t);
            if (typeof s > "u") throw new Error(`No timestamp found for label: ${t}`);
            return s
        }
        elapsed(t) {
            const s = this.get(t);
            return s.elapsed || Date.now() - s.started
        }
    }
    return Rn.Watch = i, Rn.default = i, Rn
}
var qc = {},
    hs = {},
    gf;

function b1() {
    if (gf) return hs;
    gf = 1, Object.defineProperty(hs, "__esModule", {
        value: !0
    }), hs.IWatch = void 0;
    class i {}
    return hs.IWatch = i, hs
}
var yf;

function w1() {
    return yf || (yf = 1, function(i) {
        Object.defineProperty(i, "__esModule", {
            value: !0
        }), na.__exportStar(b1(), i)
    }(qc)), qc
}(function(i) {
    Object.defineProperty(i, "__esModule", {
        value: !0
    });
    const e = na;
    e.__exportStar(_1(), i), e.__exportStar(m1(), i), e.__exportStar(w1(), i), e.__exportStar(Wd(), i)
})(ve);
var ht = {};
Object.defineProperty(ht, "__esModule", {
    value: !0
});
ht.getLocalStorage = ht.getLocalStorageOrThrow = ht.getCrypto = ht.getCryptoOrThrow = Yd = ht.getLocation = ht.getLocationOrThrow = Uu = ht.getNavigator = ht.getNavigatorOrThrow = Mu = ht.getDocument = ht.getDocumentOrThrow = ht.getFromWindowOrThrow = ht.getFromWindow = void 0;

function an(i) {
    let e;
    return typeof window < "u" && typeof window[i] < "u" && (e = window[i]), e
}
ht.getFromWindow = an;

function qn(i) {
    const e = an(i);
    if (!e) throw new Error(`${i} is not defined in Window`);
    return e
}
ht.getFromWindowOrThrow = qn;

function E1() {
    return qn("document")
}
ht.getDocumentOrThrow = E1;

function D1() {
    return an("document")
}
var Mu = ht.getDocument = D1;

function S1() {
    return qn("navigator")
}
ht.getNavigatorOrThrow = S1;

function I1() {
    return an("navigator")
}
var Uu = ht.getNavigator = I1;

function x1() {
    return qn("location")
}
ht.getLocationOrThrow = x1;

function O1() {
    return an("location")
}
var Yd = ht.getLocation = O1;

function P1() {
    return qn("crypto")
}
ht.getCryptoOrThrow = P1;

function C1() {
    return an("crypto")
}
ht.getCrypto = C1;

function T1() {
    return qn("localStorage")
}
ht.getLocalStorageOrThrow = T1;

function A1() {
    return an("localStorage")
}
ht.getLocalStorage = A1;
var qu = {};
Object.defineProperty(qu, "__esModule", {
    value: !0
});
var Jd = qu.getWindowMetadata = void 0;
const vf = ht;

function R1() {
    let i, e;
    try {
        i = vf.getDocumentOrThrow(), e = vf.getLocationOrThrow()
    } catch {
        return null
    }

    function t() {
        const D = i.getElementsByTagName("link"),
            S = [];
        for (let x = 0; x < D.length; x++) {
            const O = D[x],
                F = O.getAttribute("rel");
            if (F && F.toLowerCase().indexOf("icon") > -1) {
                const K = O.getAttribute("href");
                if (K)
                    if (K.toLowerCase().indexOf("https:") === -1 && K.toLowerCase().indexOf("http:") === -1 && K.indexOf("//") !== 0) {
                        let ne = e.protocol + "//" + e.host;
                        if (K.indexOf("/") === 0) ne += K;
                        else {
                            const $ = e.pathname.split("/");
                            $.pop();
                            const U = $.join("/");
                            ne += U + "/" + K
                        }
                        S.push(ne)
                    } else if (K.indexOf("//") === 0) {
                    const ne = e.protocol + K;
                    S.push(ne)
                } else S.push(K)
            }
        }
        return S
    }

    function s(...D) {
        const S = i.getElementsByTagName("meta");
        for (let x = 0; x < S.length; x++) {
            const O = S[x],
                F = ["itemprop", "property", "name"].map(K => O.getAttribute(K)).filter(K => K ? D.includes(K) : !1);
            if (F.length && F) {
                const K = O.getAttribute("content");
                if (K) return K
            }
        }
        return ""
    }

    function o() {
        let D = s("name", "og:site_name", "og:title", "twitter:title");
        return D || (D = i.title), D
    }

    function c() {
        return s("description", "og:description", "twitter:description", "keywords")
    }
    const l = o(),
        f = c(),
        y = e.origin,
        p = t();
    return {
        description: f,
        url: y,
        icons: p,
        name: l
    }
}
Jd = qu.getWindowMetadata = R1;
var ws = {},
    N1 = i => encodeURIComponent(i).replace(/[!'()*]/g, e => `%${e.charCodeAt(0).toString(16).toUpperCase()}`),
    Qd = "%[a-f0-9]{2}",
    _f = new RegExp("(" + Qd + ")|([^%]+?)", "gi"),
    mf = new RegExp("(" + Qd + ")+", "gi");

function uu(i, e) {
    try {
        return [decodeURIComponent(i.join(""))]
    } catch {}
    if (i.length === 1) return i;
    e = e || 1;
    var t = i.slice(0, e),
        s = i.slice(e);
    return Array.prototype.concat.call([], uu(t), uu(s))
}

function $1(i) {
    try {
        return decodeURIComponent(i)
    } catch {
        for (var e = i.match(_f) || [], t = 1; t < e.length; t++) i = uu(e, t).join(""), e = i.match(_f) || [];
        return i
    }
}

function j1(i) {
    for (var e = {
            "%FE%FF": "��",
            "%FF%FE": "��"
        }, t = mf.exec(i); t;) {
        try {
            e[t[0]] = decodeURIComponent(t[0])
        } catch {
            var s = $1(t[0]);
            s !== t[0] && (e[t[0]] = s)
        }
        t = mf.exec(i)
    }
    e["%C2"] = "�";
    for (var o = Object.keys(e), c = 0; c < o.length; c++) {
        var l = o[c];
        i = i.replace(new RegExp(l, "g"), e[l])
    }
    return i
}
var L1 = function(i) {
        if (typeof i != "string") throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof i + "`");
        try {
            return i = i.replace(/\+/g, " "), decodeURIComponent(i)
        } catch {
            return j1(i)
        }
    },
    M1 = (i, e) => {
        if (!(typeof i == "string" && typeof e == "string")) throw new TypeError("Expected the arguments to be of type `string`");
        if (e === "") return [i];
        const t = i.indexOf(e);
        return t === -1 ? [i] : [i.slice(0, t), i.slice(t + e.length)]
    },
    U1 = function(i, e) {
        for (var t = {}, s = Object.keys(i), o = Array.isArray(e), c = 0; c < s.length; c++) {
            var l = s[c],
                f = i[l];
            (o ? e.indexOf(l) !== -1 : e(l, f, i)) && (t[l] = f)
        }
        return t
    };
(function(i) {
    const e = N1,
        t = L1,
        s = M1,
        o = U1,
        c = $ => $ == null,
        l = Symbol("encodeFragmentIdentifier");

    function f($) {
        switch ($.arrayFormat) {
            case "index":
                return U => (C, A) => {
                    const E = C.length;
                    return A === void 0 || $.skipNull && A === null || $.skipEmptyString && A === "" ? C : A === null ? [...C, [v(U, $), "[", E, "]"].join("")] : [...C, [v(U, $), "[", v(E, $), "]=", v(A, $)].join("")]
                };
            case "bracket":
                return U => (C, A) => A === void 0 || $.skipNull && A === null || $.skipEmptyString && A === "" ? C : A === null ? [...C, [v(U, $), "[]"].join("")] : [...C, [v(U, $), "[]=", v(A, $)].join("")];
            case "colon-list-separator":
                return U => (C, A) => A === void 0 || $.skipNull && A === null || $.skipEmptyString && A === "" ? C : A === null ? [...C, [v(U, $), ":list="].join("")] : [...C, [v(U, $), ":list=", v(A, $)].join("")];
            case "comma":
            case "separator":
            case "bracket-separator":
                {
                    const U = $.arrayFormat === "bracket-separator" ? "[]=" : "=";
                    return C => (A, E) => E === void 0 || $.skipNull && E === null || $.skipEmptyString && E === "" ? A : (E = E === null ? "" : E, A.length === 0 ? [
                        [v(C, $), U, v(E, $)].join("")
                    ] : [
                        [A, v(E, $)].join($.arrayFormatSeparator)
                    ])
                }
            default:
                return U => (C, A) => A === void 0 || $.skipNull && A === null || $.skipEmptyString && A === "" ? C : A === null ? [...C, v(U, $)] : [...C, [v(U, $), "=", v(A, $)].join("")]
        }
    }

    function y($) {
        let U;
        switch ($.arrayFormat) {
            case "index":
                return (C, A, E) => {
                    if (U = /\[(\d*)\]$/.exec(C), C = C.replace(/\[\d*\]$/, ""), !U) {
                        E[C] = A;
                        return
                    }
                    E[C] === void 0 && (E[C] = {}), E[C][U[1]] = A
                };
            case "bracket":
                return (C, A, E) => {
                    if (U = /(\[\])$/.exec(C), C = C.replace(/\[\]$/, ""), !U) {
                        E[C] = A;
                        return
                    }
                    if (E[C] === void 0) {
                        E[C] = [A];
                        return
                    }
                    E[C] = [].concat(E[C], A)
                };
            case "colon-list-separator":
                return (C, A, E) => {
                    if (U = /(:list)$/.exec(C), C = C.replace(/:list$/, ""), !U) {
                        E[C] = A;
                        return
                    }
                    if (E[C] === void 0) {
                        E[C] = [A];
                        return
                    }
                    E[C] = [].concat(E[C], A)
                };
            case "comma":
            case "separator":
                return (C, A, E) => {
                    const u = typeof A == "string" && A.includes($.arrayFormatSeparator),
                        b = typeof A == "string" && !u && D(A, $).includes($.arrayFormatSeparator);
                    A = b ? D(A, $) : A;
                    const G = u || b ? A.split($.arrayFormatSeparator).map(W => D(W, $)) : A === null ? A : D(A, $);
                    E[C] = G
                };
            case "bracket-separator":
                return (C, A, E) => {
                    const u = /(\[\])$/.test(C);
                    if (C = C.replace(/\[\]$/, ""), !u) {
                        E[C] = A && D(A, $);
                        return
                    }
                    const b = A === null ? [] : A.split($.arrayFormatSeparator).map(G => D(G, $));
                    if (E[C] === void 0) {
                        E[C] = b;
                        return
                    }
                    E[C] = [].concat(E[C], b)
                };
            default:
                return (C, A, E) => {
                    if (E[C] === void 0) {
                        E[C] = A;
                        return
                    }
                    E[C] = [].concat(E[C], A)
                }
        }
    }

    function p($) {
        if (typeof $ != "string" || $.length !== 1) throw new TypeError("arrayFormatSeparator must be single character string")
    }

    function v($, U) {
        return U.encode ? U.strict ? e($) : encodeURIComponent($) : $
    }

    function D($, U) {
        return U.decode ? t($) : $
    }

    function S($) {
        return Array.isArray($) ? $.sort() : typeof $ == "object" ? S(Object.keys($)).sort((U, C) => Number(U) - Number(C)).map(U => $[U]) : $
    }

    function x($) {
        const U = $.indexOf("#");
        return U !== -1 && ($ = $.slice(0, U)), $
    }

    function O($) {
        let U = "";
        const C = $.indexOf("#");
        return C !== -1 && (U = $.slice(C)), U
    }

    function F($) {
        $ = x($);
        const U = $.indexOf("?");
        return U === -1 ? "" : $.slice(U + 1)
    }

    function K($, U) {
        return U.parseNumbers && !Number.isNaN(Number($)) && typeof $ == "string" && $.trim() !== "" ? $ = Number($) : U.parseBooleans && $ !== null && ($.toLowerCase() === "true" || $.toLowerCase() === "false") && ($ = $.toLowerCase() === "true"), $
    }

    function ne($, U) {
        U = Object.assign({
            decode: !0,
            sort: !0,
            arrayFormat: "none",
            arrayFormatSeparator: ",",
            parseNumbers: !1,
            parseBooleans: !1
        }, U), p(U.arrayFormatSeparator);
        const C = y(U),
            A = Object.create(null);
        if (typeof $ != "string" || ($ = $.trim().replace(/^[?#&]/, ""), !$)) return A;
        for (const E of $.split("&")) {
            if (E === "") continue;
            let [u, b] = s(U.decode ? E.replace(/\+/g, " ") : E, "=");
            b = b === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(U.arrayFormat) ? b : D(b, U), C(D(u, U), b, A)
        }
        for (const E of Object.keys(A)) {
            const u = A[E];
            if (typeof u == "object" && u !== null)
                for (const b of Object.keys(u)) u[b] = K(u[b], U);
            else A[E] = K(u, U)
        }
        return U.sort === !1 ? A : (U.sort === !0 ? Object.keys(A).sort() : Object.keys(A).sort(U.sort)).reduce((E, u) => {
            const b = A[u];
            return b && typeof b == "object" && !Array.isArray(b) ? E[u] = S(b) : E[u] = b, E
        }, Object.create(null))
    }
    i.extract = F, i.parse = ne, i.stringify = ($, U) => {
        if (!$) return "";
        U = Object.assign({
            encode: !0,
            strict: !0,
            arrayFormat: "none",
            arrayFormatSeparator: ","
        }, U), p(U.arrayFormatSeparator);
        const C = b => U.skipNull && c($[b]) || U.skipEmptyString && $[b] === "",
            A = f(U),
            E = {};
        for (const b of Object.keys($)) C(b) || (E[b] = $[b]);
        const u = Object.keys(E);
        return U.sort !== !1 && u.sort(U.sort), u.map(b => {
            const G = $[b];
            return G === void 0 ? "" : G === null ? v(b, U) : Array.isArray(G) ? G.length === 0 && U.arrayFormat === "bracket-separator" ? v(b, U) + "[]" : G.reduce(A(b), []).join("&") : v(b, U) + "=" + v(G, U)
        }).filter(b => b.length > 0).join("&")
    }, i.parseUrl = ($, U) => {
        U = Object.assign({
            decode: !0
        }, U);
        const [C, A] = s($, "#");
        return Object.assign({
            url: C.split("?")[0] || "",
            query: ne(F($), U)
        }, U && U.parseFragmentIdentifier && A ? {
            fragmentIdentifier: D(A, U)
        } : {})
    }, i.stringifyUrl = ($, U) => {
        U = Object.assign({
            encode: !0,
            strict: !0,
            [l]: !0
        }, U);
        const C = x($.url).split("?")[0] || "",
            A = i.extract($.url),
            E = i.parse(A, {
                sort: !1
            }),
            u = Object.assign(E, $.query);
        let b = i.stringify(u, U);
        b && (b = `?${b}`);
        let G = O($.url);
        return $.fragmentIdentifier && (G = `#${U[l]?v($.fragmentIdentifier,U):$.fragmentIdentifier}`), `${C}${b}${G}`
    }, i.pick = ($, U, C) => {
        C = Object.assign({
            parseFragmentIdentifier: !0,
            [l]: !1
        }, C);
        const {
            url: A,
            query: E,
            fragmentIdentifier: u
        } = i.parseUrl($, C);
        return i.stringifyUrl({
            url: A,
            query: o(E, U),
            fragmentIdentifier: u
        }, C)
    }, i.exclude = ($, U, C) => {
        const A = Array.isArray(U) ? E => !U.includes(E) : (E, u) => !U(E, u);
        return i.pick($, A, C)
    }
})(ws);
const q1 = {
        waku: {
            publish: "waku_publish",
            batchPublish: "waku_batchPublish",
            subscribe: "waku_subscribe",
            batchSubscribe: "waku_batchSubscribe",
            subscription: "waku_subscription",
            unsubscribe: "waku_unsubscribe",
            batchUnsubscribe: "waku_batchUnsubscribe"
        },
        irn: {
            publish: "irn_publish",
            batchPublish: "irn_batchPublish",
            subscribe: "irn_subscribe",
            batchSubscribe: "irn_batchSubscribe",
            subscription: "irn_subscription",
            unsubscribe: "irn_unsubscribe",
            batchUnsubscribe: "irn_batchUnsubscribe"
        },
        iridium: {
            publish: "iridium_publish",
            batchPublish: "iridium_batchPublish",
            subscribe: "iridium_subscribe",
            batchSubscribe: "iridium_batchSubscribe",
            subscription: "iridium_subscription",
            unsubscribe: "iridium_unsubscribe",
            batchUnsubscribe: "iridium_batchUnsubscribe"
        }
    },
    z1 = ":";

function F1(i) {
    const [e, t] = i.split(z1);
    return {
        namespace: e,
        reference: t
    }
}

function H1(i, e = []) {
    const t = [];
    return Object.keys(i).forEach(s => {
        if (e.length && !e.includes(s)) return;
        const o = i[s];
        t.push(...o.accounts)
    }), t
}

function Xd(i, e) {
    return i.includes(":") ? [i] : e.chains || []
}
const Zd = "base10",
    ur = "base16",
    hu = "base64pad",
    zu = "utf8",
    ep = 0,
    cn = 1,
    B1 = 0,
    bf = 1,
    lu = 12,
    Fu = 32;

function K1() {
    const i = ju.generateKeyPair();
    return {
        privateKey: hr(i.secretKey, ur),
        publicKey: hr(i.publicKey, ur)
    }
}

function fu() {
    const i = Os.randomBytes(Fu);
    return hr(i, ur)
}

function k1(i, e) {
    const t = ju.sharedKey(mr(i, ur), mr(e, ur), !0),
        s = new Ub(ra.SHA256, t).expand(Fu);
    return hr(s, ur)
}

function V1(i) {
    const e = ra.hash(mr(i, ur));
    return hr(e, ur)
}

function Ln(i) {
    const e = ra.hash(mr(i, zu));
    return hr(e, ur)
}

function G1(i) {
    return mr(`${i}`, Zd)
}

function Ts(i) {
    return Number(hr(i, Zd))
}

function W1(i) {
    const e = G1(typeof i.type < "u" ? i.type : ep);
    if (Ts(e) === cn && typeof i.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
    const t = typeof i.senderPublicKey < "u" ? mr(i.senderPublicKey, ur) : void 0,
        s = typeof i.iv < "u" ? mr(i.iv, ur) : Os.randomBytes(lu),
        o = new Nu.ChaCha20Poly1305(mr(i.symKey, ur)).seal(s, mr(i.message, zu));
    return J1({
        type: e,
        sealed: o,
        iv: s,
        senderPublicKey: t
    })
}

function Y1(i) {
    const e = new Nu.ChaCha20Poly1305(mr(i.symKey, ur)),
        {
            sealed: t,
            iv: s
        } = Yo(i.encoded),
        o = e.open(s, t);
    if (o === null) throw new Error("Failed to decrypt");
    return hr(o, zu)
}

function J1(i) {
    if (Ts(i.type) === cn) {
        if (typeof i.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
        return hr(su([i.type, i.senderPublicKey, i.iv, i.sealed]), hu)
    }
    return hr(su([i.type, i.iv, i.sealed]), hu)
}

function Yo(i) {
    const e = mr(i, hu),
        t = e.slice(B1, bf),
        s = bf;
    if (Ts(t) === cn) {
        const f = s + Fu,
            y = f + lu,
            p = e.slice(s, f),
            v = e.slice(f, y),
            D = e.slice(y);
        return {
            type: t,
            sealed: D,
            iv: v,
            senderPublicKey: p
        }
    }
    const o = s + lu,
        c = e.slice(s, o),
        l = e.slice(o);
    return {
        type: t,
        sealed: l,
        iv: c
    }
}

function Q1(i, e) {
    const t = Yo(i);
    return tp({
        type: Ts(t.type),
        senderPublicKey: typeof t.senderPublicKey < "u" ? hr(t.senderPublicKey, ur) : void 0,
        receiverPublicKey: e == null ? void 0 : e.receiverPublicKey
    })
}

function tp(i) {
    const e = (i == null ? void 0 : i.type) || ep;
    if (e === cn) {
        if (typeof(i == null ? void 0 : i.senderPublicKey) > "u") throw new Error("missing sender public key");
        if (typeof(i == null ? void 0 : i.receiverPublicKey) > "u") throw new Error("missing receiver public key")
    }
    return {
        type: e,
        senderPublicKey: i == null ? void 0 : i.senderPublicKey,
        receiverPublicKey: i == null ? void 0 : i.receiverPublicKey
    }
}

function wf(i) {
    return i.type === cn && typeof i.senderPublicKey == "string" && typeof i.receiverPublicKey == "string"
}
var X1 = Object.defineProperty,
    Ef = Object.getOwnPropertySymbols,
    Z1 = Object.prototype.hasOwnProperty,
    eE = Object.prototype.propertyIsEnumerable,
    Df = (i, e, t) => e in i ? X1(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t,
    Sf = (i, e) => {
        for (var t in e || (e = {})) Z1.call(e, t) && Df(i, t, e[t]);
        if (Ef)
            for (var t of Ef(e)) eE.call(e, t) && Df(i, t, e[t]);
        return i
    };
const tE = "ReactNative",
    Or = {
        reactNative: "react-native",
        node: "node",
        browser: "browser",
        unknown: "unknown"
    },
    rE = "js";

function Hu() {
    return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u"
}

function zn() {
    return !Mu() && !!Uu() && navigator.product === tE
}

function Fn() {
    return !Hu() && !!Uu() && !!Mu()
}

function As() {
    return zn() ? Or.reactNative : Hu() ? Or.node : Fn() ? Or.browser : Or.unknown
}

function iE() {
    var i;
    try {
        return zn() && typeof global < "u" && typeof(global == null ? void 0 : global.Application) < "u" ? (i = global.Application) == null ? void 0 : i.applicationId : void 0
    } catch {
        return
    }
}

function nE(i, e) {
    let t = ws.parse(i);
    return t = Sf(Sf({}, t), e), i = ws.stringify(t), i
}

function sE() {
    return Jd() || {
        name: "",
        description: "",
        url: "",
        icons: [""]
    }
}

function oE() {
    if (As() === Or.reactNative && typeof global < "u" && typeof(global == null ? void 0 : global.Platform) < "u") {
        const {
            OS: t,
            Version: s
        } = global.Platform;
        return [t, s].join("-")
    }
    const i = Bw();
    if (i === null) return "unknown";
    const e = i.os ? i.os.replace(" ", "").toLowerCase() : "unknown";
    return i.type === "browser" ? [e, i.name, i.version].join("-") : [e, i.version].join("-")
}

function aE() {
    var i;
    const e = As();
    return e === Or.browser ? [e, ((i = Yd()) == null ? void 0 : i.host) || "unknown"].join(":") : e
}

function cE(i, e, t) {
    const s = oE(),
        o = aE();
    return [
        [i, e].join("-"), [rE, t].join("-"), s, o
    ].join("/")
}

function uE({
    protocol: i,
    version: e,
    relayUrl: t,
    sdkVersion: s,
    auth: o,
    projectId: c,
    useOnCloseEvent: l,
    bundleId: f
}) {
    const y = t.split("?"),
        p = cE(i, e, s),
        v = {
            auth: o,
            ua: p,
            projectId: c,
            useOnCloseEvent: l || void 0,
            origin: f || void 0
        },
        D = nE(y[1] || "", v);
    return y[0] + "?" + D
}

function sn(i, e) {
    return i.filter(t => e.includes(t)).length === i.length
}

function rp(i) {
    return Object.fromEntries(i.entries())
}

function ip(i) {
    return new Map(Object.entries(i))
}

function $n(i = ve.FIVE_MINUTES, e) {
    const t = ve.toMiliseconds(i || ve.FIVE_MINUTES);
    let s, o, c;
    return {
        resolve: l => {
            c && s && (clearTimeout(c), s(l))
        },
        reject: l => {
            c && o && (clearTimeout(c), o(l))
        },
        done: () => new Promise((l, f) => {
            c = setTimeout(() => {
                f(new Error(e))
            }, t), s = l, o = f
        })
    }
}

function Es(i, e, t) {
    return new Promise(async (s, o) => {
        const c = setTimeout(() => o(new Error(t)), e);
        try {
            const l = await i;
            s(l)
        } catch (l) {
            o(l)
        }
        clearTimeout(c)
    })
}

function np(i, e) {
    if (typeof e == "string" && e.startsWith(`${i}:`)) return e;
    if (i.toLowerCase() === "topic") {
        if (typeof e != "string") throw new Error('Value must be "string" for expirer target type: topic');
        return `topic:${e}`
    } else if (i.toLowerCase() === "id") {
        if (typeof e != "number") throw new Error('Value must be "number" for expirer target type: id');
        return `id:${e}`
    }
    throw new Error(`Unknown expirer target type: ${i}`)
}

function hE(i) {
    return np("topic", i)
}

function lE(i) {
    return np("id", i)
}

function sp(i) {
    const [e, t] = i.split(":"), s = {
        id: void 0,
        topic: void 0
    };
    if (e === "topic" && typeof t == "string") s.topic = t;
    else if (e === "id" && Number.isInteger(Number(t))) s.id = Number(t);
    else throw new Error(`Invalid target, expected id:number or topic:string, got ${e}:${t}`);
    return s
}

function xr(i, e) {
    return ve.fromMiliseconds((e || Date.now()) + ve.toMiliseconds(i))
}

function ji(i) {
    return Date.now() >= ve.toMiliseconds(i)
}

function Nt(i, e) {
    return `${i}${e?`:${e}`:""}`
}

function zc(i = [], e = []) {
    return [...new Set([...i, ...e])]
}
async function fE({
    id: i,
    topic: e,
    wcDeepLink: t
}) {
    try {
        if (!t) return;
        const s = typeof t == "string" ? JSON.parse(t) : t;
        let o = s == null ? void 0 : s.href;
        if (typeof o != "string") return;
        o.endsWith("/") && (o = o.slice(0, -1));
        const c = `${o}/wc?requestId=${i}&sessionTopic=${e}`,
            l = As();
        l === Or.browser ? c.startsWith("https://") ? window.open(c, "_blank", "noreferrer noopener") : window.open(c, "_self", "noreferrer noopener") : l === Or.reactNative && typeof(global == null ? void 0 : global.Linking) < "u" && await globalThis.Linking.openURL(c)
    } catch (s) {
        console.error(s)
    }
}
async function dE(i, e) {
    try {
        return await i.getItem(e) || (Fn() ? localStorage.getItem(e) : void 0)
    } catch (t) {
        console.error(t)
    }
}
const pE = "irn";

function du(i) {
    return (i == null ? void 0 : i.relay) || {
        protocol: pE
    }
}

function Vo(i) {
    const e = q1[i];
    if (typeof e > "u") throw new Error(`Relay Protocol not supported: ${i}`);
    return e
}
var gE = Object.defineProperty,
    yE = Object.defineProperties,
    vE = Object.getOwnPropertyDescriptors,
    If = Object.getOwnPropertySymbols,
    _E = Object.prototype.hasOwnProperty,
    mE = Object.prototype.propertyIsEnumerable,
    xf = (i, e, t) => e in i ? gE(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t,
    bE = (i, e) => {
        for (var t in e || (e = {})) _E.call(e, t) && xf(i, t, e[t]);
        if (If)
            for (var t of If(e)) mE.call(e, t) && xf(i, t, e[t]);
        return i
    },
    wE = (i, e) => yE(i, vE(e));

function EE(i, e = "-") {
    const t = {},
        s = "relay" + e;
    return Object.keys(i).forEach(o => {
        if (o.startsWith(s)) {
            const c = o.replace(s, ""),
                l = i[o];
            t[c] = l
        }
    }), t
}

function Of(i) {
    i = i.includes("wc://") ? i.replace("wc://", "") : i, i = i.includes("wc:") ? i.replace("wc:", "") : i;
    const e = i.indexOf(":"),
        t = i.indexOf("?") !== -1 ? i.indexOf("?") : void 0,
        s = i.substring(0, e),
        o = i.substring(e + 1, t).split("@"),
        c = typeof t < "u" ? i.substring(t) : "",
        l = ws.parse(c);
    return {
        protocol: s,
        topic: DE(o[0]),
        version: parseInt(o[1], 10),
        symKey: l.symKey,
        relay: EE(l),
        expiryTimestamp: l.expiryTimestamp ? parseInt(l.expiryTimestamp, 10) : void 0
    }
}

function DE(i) {
    return i.startsWith("//") ? i.substring(2) : i
}

function SE(i, e = "-") {
    const t = "relay",
        s = {};
    return Object.keys(i).forEach(o => {
        const c = t + e + o;
        i[o] && (s[c] = i[o])
    }), s
}

function IE(i) {
    return `${i.protocol}:${i.topic}@${i.version}?` + ws.stringify(wE(bE({
        symKey: i.symKey
    }, SE(i.relay)), {
        expiryTimestamp: i.expiryTimestamp
    }))
}

function Hn(i) {
    const e = [];
    return i.forEach(t => {
        const [s, o] = t.split(":");
        e.push(`${s}:${o}`)
    }), e
}

function xE(i) {
    const e = [];
    return Object.values(i).forEach(t => {
        e.push(...Hn(t.accounts))
    }), e
}

function OE(i, e) {
    const t = [];
    return Object.values(i).forEach(s => {
        Hn(s.accounts).includes(e) && t.push(...s.methods)
    }), t
}

function PE(i, e) {
    const t = [];
    return Object.values(i).forEach(s => {
        Hn(s.accounts).includes(e) && t.push(...s.events)
    }), t
}

function Bu(i) {
    return i.includes(":")
}

function ys(i) {
    return Bu(i) ? i.split(":")[0] : i
}
const CE = {
        INVALID_METHOD: {
            message: "Invalid method.",
            code: 1001
        },
        INVALID_EVENT: {
            message: "Invalid event.",
            code: 1002
        },
        INVALID_UPDATE_REQUEST: {
            message: "Invalid update request.",
            code: 1003
        },
        INVALID_EXTEND_REQUEST: {
            message: "Invalid extend request.",
            code: 1004
        },
        INVALID_SESSION_SETTLE_REQUEST: {
            message: "Invalid session settle request.",
            code: 1005
        },
        UNAUTHORIZED_METHOD: {
            message: "Unauthorized method.",
            code: 3001
        },
        UNAUTHORIZED_EVENT: {
            message: "Unauthorized event.",
            code: 3002
        },
        UNAUTHORIZED_UPDATE_REQUEST: {
            message: "Unauthorized update request.",
            code: 3003
        },
        UNAUTHORIZED_EXTEND_REQUEST: {
            message: "Unauthorized extend request.",
            code: 3004
        },
        USER_REJECTED: {
            message: "User rejected.",
            code: 5e3
        },
        USER_REJECTED_CHAINS: {
            message: "User rejected chains.",
            code: 5001
        },
        USER_REJECTED_METHODS: {
            message: "User rejected methods.",
            code: 5002
        },
        USER_REJECTED_EVENTS: {
            message: "User rejected events.",
            code: 5003
        },
        UNSUPPORTED_CHAINS: {
            message: "Unsupported chains.",
            code: 5100
        },
        UNSUPPORTED_METHODS: {
            message: "Unsupported methods.",
            code: 5101
        },
        UNSUPPORTED_EVENTS: {
            message: "Unsupported events.",
            code: 5102
        },
        UNSUPPORTED_ACCOUNTS: {
            message: "Unsupported accounts.",
            code: 5103
        },
        UNSUPPORTED_NAMESPACE_KEY: {
            message: "Unsupported namespace key.",
            code: 5104
        },
        USER_DISCONNECTED: {
            message: "User disconnected.",
            code: 6e3
        },
        SESSION_SETTLEMENT_FAILED: {
            message: "Session settlement failed.",
            code: 7e3
        },
        WC_METHOD_UNSUPPORTED: {
            message: "Unsupported wc_ method.",
            code: 10001
        }
    },
    TE = {
        NOT_INITIALIZED: {
            message: "Not initialized.",
            code: 1
        },
        NO_MATCHING_KEY: {
            message: "No matching key.",
            code: 2
        },
        RESTORE_WILL_OVERRIDE: {
            message: "Restore will override.",
            code: 3
        },
        RESUBSCRIBED: {
            message: "Resubscribed.",
            code: 4
        },
        MISSING_OR_INVALID: {
            message: "Missing or invalid.",
            code: 5
        },
        EXPIRED: {
            message: "Expired.",
            code: 6
        },
        UNKNOWN_TYPE: {
            message: "Unknown type.",
            code: 7
        },
        MISMATCHED_TOPIC: {
            message: "Mismatched topic.",
            code: 8
        },
        NON_CONFORMING_NAMESPACES: {
            message: "Non conforming namespaces.",
            code: 9
        }
    };

function ce(i, e) {
    const {
        message: t,
        code: s
    } = TE[i];
    return {
        message: e ? `${t} ${e}` : t,
        code: s
    }
}

function _t(i, e) {
    const {
        message: t,
        code: s
    } = CE[i];
    return {
        message: e ? `${t} ${e}` : t,
        code: s
    }
}

function ri(i, e) {
    return Array.isArray(i) ? typeof e < "u" && i.length ? i.every(e) : !0 : !1
}

function Ds(i) {
    return Object.getPrototypeOf(i) === Object.prototype && Object.keys(i).length
}

function cr(i) {
    return typeof i > "u"
}

function Vt(i, e) {
    return e && cr(i) ? !0 : typeof i == "string" && !!i.trim().length
}

function Ku(i, e) {
    return e && cr(i) ? !0 : typeof i == "number" && !isNaN(i)
}

function AE(i, e) {
    const {
        requiredNamespaces: t
    } = e, s = Object.keys(i.namespaces), o = Object.keys(t);
    let c = !0;
    return sn(o, s) ? (s.forEach(l => {
        const {
            accounts: f,
            methods: y,
            events: p
        } = i.namespaces[l], v = Hn(f), D = t[l];
        (!sn(Xd(l, D), v) || !sn(D.methods, y) || !sn(D.events, p)) && (c = !1)
    }), c) : !1
}

function Jo(i) {
    return Vt(i, !1) && i.includes(":") ? i.split(":").length === 2 : !1
}

function RE(i) {
    if (Vt(i, !1) && i.includes(":")) {
        const e = i.split(":");
        if (e.length === 3) {
            const t = e[0] + ":" + e[1];
            return !!e[2] && Jo(t)
        }
    }
    return !1
}

function NE(i) {
    if (Vt(i, !1)) try {
        return typeof new URL(i) < "u"
    } catch {
        return !1
    }
    return !1
}

function $E(i) {
    var e;
    return (e = i == null ? void 0 : i.proposer) == null ? void 0 : e.publicKey
}

function jE(i) {
    return i == null ? void 0 : i.topic
}

function LE(i, e) {
    let t = null;
    return Vt(i == null ? void 0 : i.publicKey, !1) || (t = ce("MISSING_OR_INVALID", `${e} controller public key should be a string`)), t
}

function Pf(i) {
    let e = !0;
    return ri(i) ? i.length && (e = i.every(t => Vt(t, !1))) : e = !1, e
}

function ME(i, e, t) {
    let s = null;
    return ri(e) && e.length ? e.forEach(o => {
        s || Jo(o) || (s = _t("UNSUPPORTED_CHAINS", `${t}, chain ${o} should be a string and conform to "namespace:chainId" format`))
    }) : Jo(i) || (s = _t("UNSUPPORTED_CHAINS", `${t}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), s
}

function UE(i, e, t) {
    let s = null;
    return Object.entries(i).forEach(([o, c]) => {
        if (s) return;
        const l = ME(o, Xd(o, c), `${e} ${t}`);
        l && (s = l)
    }), s
}

function qE(i, e) {
    let t = null;
    return ri(i) ? i.forEach(s => {
        t || RE(s) || (t = _t("UNSUPPORTED_ACCOUNTS", `${e}, account ${s} should be a string and conform to "namespace:chainId:address" format`))
    }) : t = _t("UNSUPPORTED_ACCOUNTS", `${e}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), t
}

function zE(i, e) {
    let t = null;
    return Object.values(i).forEach(s => {
        if (t) return;
        const o = qE(s == null ? void 0 : s.accounts, `${e} namespace`);
        o && (t = o)
    }), t
}

function FE(i, e) {
    let t = null;
    return Pf(i == null ? void 0 : i.methods) ? Pf(i == null ? void 0 : i.events) || (t = _t("UNSUPPORTED_EVENTS", `${e}, events should be an array of strings or empty array for no events`)) : t = _t("UNSUPPORTED_METHODS", `${e}, methods should be an array of strings or empty array for no methods`), t
}

function op(i, e) {
    let t = null;
    return Object.values(i).forEach(s => {
        if (t) return;
        const o = FE(s, `${e}, namespace`);
        o && (t = o)
    }), t
}

function HE(i, e, t) {
    let s = null;
    if (i && Ds(i)) {
        const o = op(i, e);
        o && (s = o);
        const c = UE(i, e, t);
        c && (s = c)
    } else s = ce("MISSING_OR_INVALID", `${e}, ${t} should be an object with data`);
    return s
}

function Fc(i, e) {
    let t = null;
    if (i && Ds(i)) {
        const s = op(i, e);
        s && (t = s);
        const o = zE(i, e);
        o && (t = o)
    } else t = ce("MISSING_OR_INVALID", `${e}, namespaces should be an object with data`);
    return t
}

function ap(i) {
    return Vt(i.protocol, !0)
}

function BE(i, e) {
    let t = !1;
    return e && !i ? t = !0 : i && ri(i) && i.length && i.forEach(s => {
        t = ap(s)
    }), t
}

function KE(i) {
    return typeof i == "number"
}

function _r(i) {
    return typeof i < "u" && typeof i !== null
}

function kE(i) {
    return !(!i || typeof i != "object" || !i.code || !Ku(i.code, !1) || !i.message || !Vt(i.message, !1))
}

function VE(i) {
    return !(cr(i) || !Vt(i.method, !1))
}

function GE(i) {
    return !(cr(i) || cr(i.result) && cr(i.error) || !Ku(i.id, !1) || !Vt(i.jsonrpc, !1))
}

function WE(i) {
    return !(cr(i) || !Vt(i.name, !1))
}

function Cf(i, e) {
    return !(!Jo(e) || !xE(i).includes(e))
}

function YE(i, e, t) {
    return Vt(t, !1) ? OE(i, e).includes(t) : !1
}

function JE(i, e, t) {
    return Vt(t, !1) ? PE(i, e).includes(t) : !1
}

function Tf(i, e, t) {
    let s = null;
    const o = QE(i),
        c = XE(e),
        l = Object.keys(o),
        f = Object.keys(c),
        y = Af(Object.keys(i)),
        p = Af(Object.keys(e)),
        v = y.filter(D => !p.includes(D));
    return v.length && (s = ce("NON_CONFORMING_NAMESPACES", `${t} namespaces keys don't satisfy requiredNamespaces.
      Required: ${v.toString()}
      Received: ${Object.keys(e).toString()}`)), sn(l, f) || (s = ce("NON_CONFORMING_NAMESPACES", `${t} namespaces chains don't satisfy required namespaces.
      Required: ${l.toString()}
      Approved: ${f.toString()}`)), Object.keys(e).forEach(D => {
        if (!D.includes(":") || s) return;
        const S = Hn(e[D].accounts);
        S.includes(D) || (s = ce("NON_CONFORMING_NAMESPACES", `${t} namespaces accounts don't satisfy namespace accounts for ${D}
        Required: ${D}
        Approved: ${S.toString()}`))
    }), l.forEach(D => {
        s || (sn(o[D].methods, c[D].methods) ? sn(o[D].events, c[D].events) || (s = ce("NON_CONFORMING_NAMESPACES", `${t} namespaces events don't satisfy namespace events for ${D}`)) : s = ce("NON_CONFORMING_NAMESPACES", `${t} namespaces methods don't satisfy namespace methods for ${D}`))
    }), s
}

function QE(i) {
    const e = {};
    return Object.keys(i).forEach(t => {
        var s;
        t.includes(":") ? e[t] = i[t] : (s = i[t].chains) == null || s.forEach(o => {
            e[o] = {
                methods: i[t].methods,
                events: i[t].events
            }
        })
    }), e
}

function Af(i) {
    return [...new Set(i.map(e => e.includes(":") ? e.split(":")[0] : e))]
}

function XE(i) {
    const e = {};
    return Object.keys(i).forEach(t => {
        if (t.includes(":")) e[t] = i[t];
        else {
            const s = Hn(i[t].accounts);
            s == null || s.forEach(o => {
                e[o] = {
                    accounts: i[t].accounts.filter(c => c.includes(`${o}:`)),
                    methods: i[t].methods,
                    events: i[t].events
                }
            })
        }
    }), e
}

function ZE(i, e) {
    return Ku(i, !1) && i <= e.max && i >= e.min
}

function Rf() {
    const i = As();
    return new Promise(e => {
        switch (i) {
            case Or.browser:
                e(eD());
                break;
            case Or.reactNative:
                e(tD());
                break;
            case Or.node:
                e(rD());
                break;
            default:
                e(!0)
        }
    })
}

function eD() {
    return Fn() && (navigator == null ? void 0 : navigator.onLine)
}
async function tD() {
    if (zn() && typeof global < "u" && global != null && global.NetInfo) {
        const i = await (global == null ? void 0 : global.NetInfo.fetch());
        return i == null ? void 0 : i.isConnected
    }
    return !0
}

function rD() {
    return !0
}

function iD(i) {
    switch (As()) {
        case Or.browser:
            nD(i);
            break;
        case Or.reactNative:
            sD(i);
            break
    }
}

function nD(i) {
    !zn() && Fn() && (window.addEventListener("online", () => i(!0)), window.addEventListener("offline", () => i(!1)))
}

function sD(i) {
    zn() && typeof global < "u" && global != null && global.NetInfo && (global == null || global.NetInfo.addEventListener(e => i(e == null ? void 0 : e.isConnected)))
}
const Hc = {};
let Fo = class {
    static get(e) {
        return Hc[e]
    }
    static set(e, t) {
        Hc[e] = t
    }
    static delete(e) {
        delete Hc[e]
    }
};

function oD(i) {
    return !i || typeof i.then != "function" ? Promise.resolve(i) : i
}

function kt(i, ...e) {
    try {
        return oD(i(...e))
    } catch (t) {
        return Promise.reject(t)
    }
}

function aD(i) {
    const e = typeof i;
    return i === null || e !== "object" && e !== "function"
}

function cD(i) {
    const e = Object.getPrototypeOf(i);
    return !e || e.isPrototypeOf(Object)
}

function Go(i) {
    if (aD(i)) return String(i);
    if (cD(i) || Array.isArray(i)) return JSON.stringify(i);
    if (typeof i.toJSON == "function") return Go(i.toJSON());
    throw new Error("[unstorage] Cannot stringify value!")
}

function cp() {
    if (typeof Buffer === void 0) throw new TypeError("[unstorage] Buffer is not supported!")
}
const pu = "base64:";

function uD(i) {
    if (typeof i == "string") return i;
    cp();
    const e = Buffer.from(i).toString("base64");
    return pu + e
}

function hD(i) {
    return typeof i != "string" || !i.startsWith(pu) ? i : (cp(), Buffer.from(i.slice(pu.length), "base64"))
}

function vr(i) {
    return i ? i.split("?")[0].replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "") : ""
}

function lD(...i) {
    return vr(i.join(":"))
}

function Ho(i) {
    return i = vr(i), i ? i + ":" : ""
}
const fD = "memory",
    dD = () => {
        const i = new Map;
        return {
            name: fD,
            options: {},
            hasItem(e) {
                return i.has(e)
            },
            getItem(e) {
                return i.get(e) ? ? null
            },
            getItemRaw(e) {
                return i.get(e) ? ? null
            },
            setItem(e, t) {
                i.set(e, t)
            },
            setItemRaw(e, t) {
                i.set(e, t)
            },
            removeItem(e) {
                i.delete(e)
            },
            getKeys() {
                return Array.from(i.keys())
            },
            clear() {
                i.clear()
            },
            dispose() {
                i.clear()
            }
        }
    };

function pD(i = {}) {
    const e = {
            mounts: {
                "": i.driver || dD()
            },
            mountpoints: [""],
            watching: !1,
            watchListeners: [],
            unwatch: {}
        },
        t = p => {
            for (const v of e.mountpoints)
                if (p.startsWith(v)) return {
                    base: v,
                    relativeKey: p.slice(v.length),
                    driver: e.mounts[v]
                };
            return {
                base: "",
                relativeKey: p,
                driver: e.mounts[""]
            }
        },
        s = (p, v) => e.mountpoints.filter(D => D.startsWith(p) || v && p.startsWith(D)).map(D => ({
            relativeBase: p.length > D.length ? p.slice(D.length) : void 0,
            mountpoint: D,
            driver: e.mounts[D]
        })),
        o = (p, v) => {
            if (e.watching) {
                v = vr(v);
                for (const D of e.watchListeners) D(p, v)
            }
        },
        c = async () => {
            if (!e.watching) {
                e.watching = !0;
                for (const p in e.mounts) e.unwatch[p] = await Nf(e.mounts[p], o, p)
            }
        },
        l = async () => {
            if (e.watching) {
                for (const p in e.unwatch) await e.unwatch[p]();
                e.unwatch = {}, e.watching = !1
            }
        },
        f = (p, v, D) => {
            const S = new Map,
                x = O => {
                    let F = S.get(O.base);
                    return F || (F = {
                        driver: O.driver,
                        base: O.base,
                        items: []
                    }, S.set(O.base, F)), F
                };
            for (const O of p) {
                const F = typeof O == "string",
                    K = vr(F ? O : O.key),
                    ne = F ? void 0 : O.value,
                    $ = F || !O.options ? v : { ...v,
                        ...O.options
                    },
                    U = t(K);
                x(U).items.push({
                    key: K,
                    value: ne,
                    relativeKey: U.relativeKey,
                    options: $
                })
            }
            return Promise.all([...S.values()].map(O => D(O))).then(O => O.flat())
        },
        y = {
            hasItem(p, v = {}) {
                p = vr(p);
                const {
                    relativeKey: D,
                    driver: S
                } = t(p);
                return kt(S.hasItem, D, v)
            },
            getItem(p, v = {}) {
                p = vr(p);
                const {
                    relativeKey: D,
                    driver: S
                } = t(p);
                return kt(S.getItem, D, v).then(x => zo(x))
            },
            getItems(p, v) {
                return f(p, v, D => D.driver.getItems ? kt(D.driver.getItems, D.items.map(S => ({
                    key: S.relativeKey,
                    options: S.options
                })), v).then(S => S.map(x => ({
                    key: lD(D.base, x.key),
                    value: zo(x.value)
                }))) : Promise.all(D.items.map(S => kt(D.driver.getItem, S.relativeKey, S.options).then(x => ({
                    key: S.key,
                    value: zo(x)
                })))))
            },
            getItemRaw(p, v = {}) {
                p = vr(p);
                const {
                    relativeKey: D,
                    driver: S
                } = t(p);
                return S.getItemRaw ? kt(S.getItemRaw, D, v) : kt(S.getItem, D, v).then(x => hD(x))
            },
            async setItem(p, v, D = {}) {
                if (v === void 0) return y.removeItem(p);
                p = vr(p);
                const {
                    relativeKey: S,
                    driver: x
                } = t(p);
                x.setItem && (await kt(x.setItem, S, Go(v), D), x.watch || o("update", p))
            },
            async setItems(p, v) {
                await f(p, v, async D => {
                    if (D.driver.setItems) return kt(D.driver.setItems, D.items.map(S => ({
                        key: S.relativeKey,
                        value: Go(S.value),
                        options: S.options
                    })), v);
                    D.driver.setItem && await Promise.all(D.items.map(S => kt(D.driver.setItem, S.relativeKey, Go(S.value), S.options)))
                })
            },
            async setItemRaw(p, v, D = {}) {
                if (v === void 0) return y.removeItem(p, D);
                p = vr(p);
                const {
                    relativeKey: S,
                    driver: x
                } = t(p);
                if (x.setItemRaw) await kt(x.setItemRaw, S, v, D);
                else if (x.setItem) await kt(x.setItem, S, uD(v), D);
                else return;
                x.watch || o("update", p)
            },
            async removeItem(p, v = {}) {
                typeof v == "boolean" && (v = {
                    removeMeta: v
                }), p = vr(p);
                const {
                    relativeKey: D,
                    driver: S
                } = t(p);
                S.removeItem && (await kt(S.removeItem, D, v), (v.removeMeta || v.removeMata) && await kt(S.removeItem, D + "$", v), S.watch || o("remove", p))
            },
            async getMeta(p, v = {}) {
                typeof v == "boolean" && (v = {
                    nativeOnly: v
                }), p = vr(p);
                const {
                    relativeKey: D,
                    driver: S
                } = t(p), x = Object.create(null);
                if (S.getMeta && Object.assign(x, await kt(S.getMeta, D, v)), !v.nativeOnly) {
                    const O = await kt(S.getItem, D + "$", v).then(F => zo(F));
                    O && typeof O == "object" && (typeof O.atime == "string" && (O.atime = new Date(O.atime)), typeof O.mtime == "string" && (O.mtime = new Date(O.mtime)), Object.assign(x, O))
                }
                return x
            },
            setMeta(p, v, D = {}) {
                return this.setItem(p + "$", v, D)
            },
            removeMeta(p, v = {}) {
                return this.removeItem(p + "$", v)
            },
            async getKeys(p, v = {}) {
                p = Ho(p);
                const D = s(p, !0);
                let S = [];
                const x = [];
                for (const O of D) {
                    const K = (await kt(O.driver.getKeys, O.relativeBase, v)).map(ne => O.mountpoint + vr(ne)).filter(ne => !S.some($ => ne.startsWith($)));
                    x.push(...K), S = [O.mountpoint, ...S.filter(ne => !ne.startsWith(O.mountpoint))]
                }
                return p ? x.filter(O => O.startsWith(p) && !O.endsWith("$")) : x.filter(O => !O.endsWith("$"))
            },
            async clear(p, v = {}) {
                p = Ho(p), await Promise.all(s(p, !1).map(async D => {
                    if (D.driver.clear) return kt(D.driver.clear, D.relativeBase, v);
                    if (D.driver.removeItem) {
                        const S = await D.driver.getKeys(D.relativeBase || "", v);
                        return Promise.all(S.map(x => D.driver.removeItem(x, v)))
                    }
                }))
            },
            async dispose() {
                await Promise.all(Object.values(e.mounts).map(p => $f(p)))
            },
            async watch(p) {
                return await c(), e.watchListeners.push(p), async () => {
                    e.watchListeners = e.watchListeners.filter(v => v !== p), e.watchListeners.length === 0 && await l()
                }
            },
            async unwatch() {
                e.watchListeners = [], await l()
            },
            mount(p, v) {
                if (p = Ho(p), p && e.mounts[p]) throw new Error(`already mounted at ${p}`);
                return p && (e.mountpoints.push(p), e.mountpoints.sort((D, S) => S.length - D.length)), e.mounts[p] = v, e.watching && Promise.resolve(Nf(v, o, p)).then(D => {
                    e.unwatch[p] = D
                }).catch(console.error), y
            },
            async unmount(p, v = !0) {
                p = Ho(p), !(!p || !e.mounts[p]) && (e.watching && p in e.unwatch && (e.unwatch[p](), delete e.unwatch[p]), v && await $f(e.mounts[p]), e.mountpoints = e.mountpoints.filter(D => D !== p), delete e.mounts[p])
            },
            getMount(p = "") {
                p = vr(p) + ":";
                const v = t(p);
                return {
                    driver: v.driver,
                    base: v.base
                }
            },
            getMounts(p = "", v = {}) {
                return p = vr(p), s(p, v.parents).map(S => ({
                    driver: S.driver,
                    base: S.mountpoint
                }))
            }
        };
    return y
}

function Nf(i, e, t) {
    return i.watch ? i.watch((s, o) => e(s, t + o)) : () => {}
}
async function $f(i) {
    typeof i.dispose == "function" && await kt(i.dispose)
}

function un(i) {
    return new Promise((e, t) => {
        i.oncomplete = i.onsuccess = () => e(i.result), i.onabort = i.onerror = () => t(i.error)
    })
}

function up(i, e) {
    const t = indexedDB.open(i);
    t.onupgradeneeded = () => t.result.createObjectStore(e);
    const s = un(t);
    return (o, c) => s.then(l => c(l.transaction(e, o).objectStore(e)))
}
let Bc;

function Rs() {
    return Bc || (Bc = up("keyval-store", "keyval")), Bc
}

function jf(i, e = Rs()) {
    return e("readonly", t => un(t.get(i)))
}

function gD(i, e, t = Rs()) {
    return t("readwrite", s => (s.put(e, i), un(s.transaction)))
}

function yD(i, e = Rs()) {
    return e("readwrite", t => (t.delete(i), un(t.transaction)))
}

function vD(i = Rs()) {
    return i("readwrite", e => (e.clear(), un(e.transaction)))
}

function _D(i, e) {
    return i.openCursor().onsuccess = function() {
        this.result && (e(this.result), this.result.continue())
    }, un(i.transaction)
}

function mD(i = Rs()) {
    return i("readonly", e => {
        if (e.getAllKeys) return un(e.getAllKeys());
        const t = [];
        return _D(e, s => t.push(s.key)).then(() => t)
    })
}
const bD = i => JSON.stringify(i, (e, t) => typeof t == "bigint" ? t.toString() + "n" : t),
    wD = i => {
        const e = /([\[:])?(\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\}\]])/g,
            t = i.replace(e, '$1"$2n"$3');
        return JSON.parse(t, (s, o) => typeof o == "string" && o.match(/^\d+n$/) ? BigInt(o.substring(0, o.length - 1)) : o)
    };

function Ns(i) {
    if (typeof i != "string") throw new Error(`Cannot safe json parse value of type ${typeof i}`);
    try {
        return wD(i)
    } catch {
        return i
    }
}

function on(i) {
    return typeof i == "string" ? i : bD(i) || ""
}
const ED = "idb-keyval";
var DD = (i = {}) => {
    const e = i.base && i.base.length > 0 ? `${i.base}:` : "",
        t = o => e + o;
    let s;
    return i.dbName && i.storeName && (s = up(i.dbName, i.storeName)), {
        name: ED,
        options: i,
        async hasItem(o) {
            return !(typeof await jf(t(o), s) > "u")
        },
        async getItem(o) {
            return await jf(t(o), s) ? ? null
        },
        setItem(o, c) {
            return gD(t(o), c, s)
        },
        removeItem(o) {
            return yD(t(o), s)
        },
        getKeys() {
            return mD(s)
        },
        clear() {
            return vD(s)
        }
    }
};
const SD = "WALLET_CONNECT_V2_INDEXED_DB",
    ID = "keyvaluestorage";
let xD = class {
    constructor() {
        this.indexedDb = pD({
            driver: DD({
                dbName: SD,
                storeName: ID
            })
        })
    }
    async getKeys() {
        return this.indexedDb.getKeys()
    }
    async getEntries() {
        return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map(e => [e.key, e.value])
    }
    async getItem(e) {
        const t = await this.indexedDb.getItem(e);
        if (t !== null) return t
    }
    async setItem(e, t) {
        await this.indexedDb.setItem(e, on(t))
    }
    async removeItem(e) {
        await this.indexedDb.removeItem(e)
    }
};
var Kc = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {},
    Wo = {
        exports: {}
    };
(function() {
    let i;

    function e() {}
    i = e, i.prototype.getItem = function(t) {
        return this.hasOwnProperty(t) ? String(this[t]) : null
    }, i.prototype.setItem = function(t, s) {
        this[t] = String(s)
    }, i.prototype.removeItem = function(t) {
        delete this[t]
    }, i.prototype.clear = function() {
        const t = this;
        Object.keys(t).forEach(function(s) {
            t[s] = void 0, delete t[s]
        })
    }, i.prototype.key = function(t) {
        return t = t || 0, Object.keys(this)[t]
    }, i.prototype.__defineGetter__("length", function() {
        return Object.keys(this).length
    }), typeof Kc < "u" && Kc.localStorage ? Wo.exports = Kc.localStorage : typeof window < "u" && window.localStorage ? Wo.exports = window.localStorage : Wo.exports = new e
})();

function OD(i) {
    var e;
    return [i[0], Ns((e = i[1]) != null ? e : "")]
}
class PD {
    constructor() {
        this.localStorage = Wo.exports
    }
    async getKeys() {
        return Object.keys(this.localStorage)
    }
    async getEntries() {
        return Object.entries(this.localStorage).map(OD)
    }
    async getItem(e) {
        const t = this.localStorage.getItem(e);
        if (t !== null) return Ns(t)
    }
    async setItem(e, t) {
        this.localStorage.setItem(e, on(t))
    }
    async removeItem(e) {
        this.localStorage.removeItem(e)
    }
}
const CD = "wc_storage_version",
    Lf = 1,
    TD = async (i, e, t) => {
        const s = CD,
            o = await e.getItem(s);
        if (o && o >= Lf) {
            t(e);
            return
        }
        const c = await i.getKeys();
        if (!c.length) {
            t(e);
            return
        }
        const l = [];
        for (; c.length;) {
            const f = c.shift();
            if (!f) continue;
            const y = f.toLowerCase();
            if (y.includes("wc@") || y.includes("walletconnect") || y.includes("wc_") || y.includes("wallet_connect")) {
                const p = await i.getItem(f);
                await e.setItem(f, p), l.push(f)
            }
        }
        await e.setItem(s, Lf), t(e), AD(i, l)
    },
    AD = async (i, e) => {
        e.length && e.forEach(async t => {
            await i.removeItem(t)
        })
    };
let RD = class {
    constructor() {
        this.initialized = !1, this.setInitialized = t => {
            this.storage = t, this.initialized = !0
        };
        const e = new PD;
        this.storage = e;
        try {
            const t = new xD;
            TD(e, t, this.setInitialized)
        } catch {
            this.initialized = !0
        }
    }
    async getKeys() {
        return await this.initialize(), this.storage.getKeys()
    }
    async getEntries() {
        return await this.initialize(), this.storage.getEntries()
    }
    async getItem(e) {
        return await this.initialize(), this.storage.getItem(e)
    }
    async setItem(e, t) {
        return await this.initialize(), this.storage.setItem(e, t)
    }
    async removeItem(e) {
        return await this.initialize(), this.storage.removeItem(e)
    }
    async initialize() {
        this.initialized || await new Promise(e => {
            const t = setInterval(() => {
                this.initialized && (clearInterval(t), e())
            }, 20)
        })
    }
};
var Bn = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var gu = function(i, e) {
    return gu = Object.setPrototypeOf || {
        __proto__: []
    }
    instanceof Array && function(t, s) {
        t.__proto__ = s
    } || function(t, s) {
        for (var o in s) s.hasOwnProperty(o) && (t[o] = s[o])
    }, gu(i, e)
};

function ND(i, e) {
    gu(i, e);

    function t() {
        this.constructor = i
    }
    i.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t)
}
var yu = function() {
    return yu = Object.assign || function(e) {
        for (var t, s = 1, o = arguments.length; s < o; s++) {
            t = arguments[s];
            for (var c in t) Object.prototype.hasOwnProperty.call(t, c) && (e[c] = t[c])
        }
        return e
    }, yu.apply(this, arguments)
};

function $D(i, e) {
    var t = {};
    for (var s in i) Object.prototype.hasOwnProperty.call(i, s) && e.indexOf(s) < 0 && (t[s] = i[s]);
    if (i != null && typeof Object.getOwnPropertySymbols == "function")
        for (var o = 0, s = Object.getOwnPropertySymbols(i); o < s.length; o++) e.indexOf(s[o]) < 0 && Object.prototype.propertyIsEnumerable.call(i, s[o]) && (t[s[o]] = i[s[o]]);
    return t
}

function jD(i, e, t, s) {
    var o = arguments.length,
        c = o < 3 ? e : s === null ? s = Object.getOwnPropertyDescriptor(e, t) : s,
        l;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") c = Reflect.decorate(i, e, t, s);
    else
        for (var f = i.length - 1; f >= 0; f--)(l = i[f]) && (c = (o < 3 ? l(c) : o > 3 ? l(e, t, c) : l(e, t)) || c);
    return o > 3 && c && Object.defineProperty(e, t, c), c
}

function LD(i, e) {
    return function(t, s) {
        e(t, s, i)
    }
}

function MD(i, e) {
    if (typeof Reflect == "object" && typeof Reflect.metadata == "function") return Reflect.metadata(i, e)
}

function UD(i, e, t, s) {
    function o(c) {
        return c instanceof t ? c : new t(function(l) {
            l(c)
        })
    }
    return new(t || (t = Promise))(function(c, l) {
        function f(v) {
            try {
                p(s.next(v))
            } catch (D) {
                l(D)
            }
        }

        function y(v) {
            try {
                p(s.throw(v))
            } catch (D) {
                l(D)
            }
        }

        function p(v) {
            v.done ? c(v.value) : o(v.value).then(f, y)
        }
        p((s = s.apply(i, e || [])).next())
    })
}

function qD(i, e) {
    var t = {
            label: 0,
            sent: function() {
                if (c[0] & 1) throw c[1];
                return c[1]
            },
            trys: [],
            ops: []
        },
        s, o, c, l;
    return l = {
        next: f(0),
        throw: f(1),
        return: f(2)
    }, typeof Symbol == "function" && (l[Symbol.iterator] = function() {
        return this
    }), l;

    function f(p) {
        return function(v) {
            return y([p, v])
        }
    }

    function y(p) {
        if (s) throw new TypeError("Generator is already executing.");
        for (; t;) try {
            if (s = 1, o && (c = p[0] & 2 ? o.return : p[0] ? o.throw || ((c = o.return) && c.call(o), 0) : o.next) && !(c = c.call(o, p[1])).done) return c;
            switch (o = 0, c && (p = [p[0] & 2, c.value]), p[0]) {
                case 0:
                case 1:
                    c = p;
                    break;
                case 4:
                    return t.label++, {
                        value: p[1],
                        done: !1
                    };
                case 5:
                    t.label++, o = p[1], p = [0];
                    continue;
                case 7:
                    p = t.ops.pop(), t.trys.pop();
                    continue;
                default:
                    if (c = t.trys, !(c = c.length > 0 && c[c.length - 1]) && (p[0] === 6 || p[0] === 2)) {
                        t = 0;
                        continue
                    }
                    if (p[0] === 3 && (!c || p[1] > c[0] && p[1] < c[3])) {
                        t.label = p[1];
                        break
                    }
                    if (p[0] === 6 && t.label < c[1]) {
                        t.label = c[1], c = p;
                        break
                    }
                    if (c && t.label < c[2]) {
                        t.label = c[2], t.ops.push(p);
                        break
                    }
                    c[2] && t.ops.pop(), t.trys.pop();
                    continue
            }
            p = e.call(i, t)
        } catch (v) {
            p = [6, v], o = 0
        } finally {
            s = c = 0
        }
        if (p[0] & 5) throw p[1];
        return {
            value: p[0] ? p[1] : void 0,
            done: !0
        }
    }
}

function zD(i, e, t, s) {
    s === void 0 && (s = t), i[s] = e[t]
}

function FD(i, e) {
    for (var t in i) t !== "default" && !e.hasOwnProperty(t) && (e[t] = i[t])
}

function vu(i) {
    var e = typeof Symbol == "function" && Symbol.iterator,
        t = e && i[e],
        s = 0;
    if (t) return t.call(i);
    if (i && typeof i.length == "number") return {
        next: function() {
            return i && s >= i.length && (i = void 0), {
                value: i && i[s++],
                done: !i
            }
        }
    };
    throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.")
}

function hp(i, e) {
    var t = typeof Symbol == "function" && i[Symbol.iterator];
    if (!t) return i;
    var s = t.call(i),
        o, c = [],
        l;
    try {
        for (;
            (e === void 0 || e-- > 0) && !(o = s.next()).done;) c.push(o.value)
    } catch (f) {
        l = {
            error: f
        }
    } finally {
        try {
            o && !o.done && (t = s.return) && t.call(s)
        } finally {
            if (l) throw l.error
        }
    }
    return c
}

function HD() {
    for (var i = [], e = 0; e < arguments.length; e++) i = i.concat(hp(arguments[e]));
    return i
}

function BD() {
    for (var i = 0, e = 0, t = arguments.length; e < t; e++) i += arguments[e].length;
    for (var s = Array(i), o = 0, e = 0; e < t; e++)
        for (var c = arguments[e], l = 0, f = c.length; l < f; l++, o++) s[o] = c[l];
    return s
}

function Ss(i) {
    return this instanceof Ss ? (this.v = i, this) : new Ss(i)
}

function KD(i, e, t) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var s = t.apply(i, e || []),
        o, c = [];
    return o = {}, l("next"), l("throw"), l("return"), o[Symbol.asyncIterator] = function() {
        return this
    }, o;

    function l(S) {
        s[S] && (o[S] = function(x) {
            return new Promise(function(O, F) {
                c.push([S, x, O, F]) > 1 || f(S, x)
            })
        })
    }

    function f(S, x) {
        try {
            y(s[S](x))
        } catch (O) {
            D(c[0][3], O)
        }
    }

    function y(S) {
        S.value instanceof Ss ? Promise.resolve(S.value.v).then(p, v) : D(c[0][2], S)
    }

    function p(S) {
        f("next", S)
    }

    function v(S) {
        f("throw", S)
    }

    function D(S, x) {
        S(x), c.shift(), c.length && f(c[0][0], c[0][1])
    }
}

function kD(i) {
    var e, t;
    return e = {}, s("next"), s("throw", function(o) {
        throw o
    }), s("return"), e[Symbol.iterator] = function() {
        return this
    }, e;

    function s(o, c) {
        e[o] = i[o] ? function(l) {
            return (t = !t) ? {
                value: Ss(i[o](l)),
                done: o === "return"
            } : c ? c(l) : l
        } : c
    }
}

function VD(i) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var e = i[Symbol.asyncIterator],
        t;
    return e ? e.call(i) : (i = typeof vu == "function" ? vu(i) : i[Symbol.iterator](), t = {}, s("next"), s("throw"), s("return"), t[Symbol.asyncIterator] = function() {
        return this
    }, t);

    function s(c) {
        t[c] = i[c] && function(l) {
            return new Promise(function(f, y) {
                l = i[c](l), o(f, y, l.done, l.value)
            })
        }
    }

    function o(c, l, f, y) {
        Promise.resolve(y).then(function(p) {
            c({
                value: p,
                done: f
            })
        }, l)
    }
}

function GD(i, e) {
    return Object.defineProperty ? Object.defineProperty(i, "raw", {
        value: e
    }) : i.raw = e, i
}

function WD(i) {
    if (i && i.__esModule) return i;
    var e = {};
    if (i != null)
        for (var t in i) Object.hasOwnProperty.call(i, t) && (e[t] = i[t]);
    return e.default = i, e
}

function YD(i) {
    return i && i.__esModule ? i : {
        default: i
    }
}

function JD(i, e) {
    if (!e.has(i)) throw new TypeError("attempted to get private field on non-instance");
    return e.get(i)
}

function QD(i, e, t) {
    if (!e.has(i)) throw new TypeError("attempted to set private field on non-instance");
    return e.set(i, t), t
}
const XD = Object.freeze(Object.defineProperty({
        __proto__: null,
        get __assign() {
            return yu
        },
        __asyncDelegator: kD,
        __asyncGenerator: KD,
        __asyncValues: VD,
        __await: Ss,
        __awaiter: UD,
        __classPrivateFieldGet: JD,
        __classPrivateFieldSet: QD,
        __createBinding: zD,
        __decorate: jD,
        __exportStar: FD,
        __extends: ND,
        __generator: qD,
        __importDefault: YD,
        __importStar: WD,
        __makeTemplateObject: GD,
        __metadata: MD,
        __param: LD,
        __read: hp,
        __rest: $D,
        __spread: HD,
        __spreadArrays: BD,
        __values: vu
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    sa = Un(XD);
var ls = {},
    kc = {},
    fs = {};
let hn = class {};
const ZD = Object.freeze(Object.defineProperty({
        __proto__: null,
        IEvents: hn
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    e3 = Un(ZD);
var Mf;

function t3() {
    if (Mf) return fs;
    Mf = 1, Object.defineProperty(fs, "__esModule", {
        value: !0
    }), fs.IHeartBeat = void 0;
    const i = e3;
    class e extends i.IEvents {
        constructor(s) {
            super()
        }
    }
    return fs.IHeartBeat = e, fs
}
var Uf;

function lp() {
    return Uf || (Uf = 1, function(i) {
        Object.defineProperty(i, "__esModule", {
            value: !0
        }), sa.__exportStar(t3(), i)
    }(kc)), kc
}
var Vc = {},
    rn = {},
    qf;

function r3() {
    if (qf) return rn;
    qf = 1, Object.defineProperty(rn, "__esModule", {
        value: !0
    }), rn.HEARTBEAT_EVENTS = rn.HEARTBEAT_INTERVAL = void 0;
    const i = ve;
    return rn.HEARTBEAT_INTERVAL = i.FIVE_SECONDS, rn.HEARTBEAT_EVENTS = {
        pulse: "heartbeat_pulse"
    }, rn
}
var zf;

function fp() {
    return zf || (zf = 1, function(i) {
        Object.defineProperty(i, "__esModule", {
            value: !0
        }), sa.__exportStar(r3(), i)
    }(Vc)), Vc
}
var Ff;

function i3() {
    if (Ff) return ls;
    Ff = 1, Object.defineProperty(ls, "__esModule", {
        value: !0
    }), ls.HeartBeat = void 0;
    const i = sa,
        e = Ur,
        t = ve,
        s = lp(),
        o = fp();
    class c extends s.IHeartBeat {
        constructor(f) {
            super(f), this.events = new e.EventEmitter, this.interval = o.HEARTBEAT_INTERVAL, this.interval = (f == null ? void 0 : f.interval) || o.HEARTBEAT_INTERVAL
        }
        static init(f) {
            return i.__awaiter(this, void 0, void 0, function*() {
                const y = new c(f);
                return yield y.init(), y
            })
        }
        init() {
            return i.__awaiter(this, void 0, void 0, function*() {
                yield this.initialize()
            })
        }
        stop() {
            clearInterval(this.intervalRef)
        }
        on(f, y) {
            this.events.on(f, y)
        }
        once(f, y) {
            this.events.once(f, y)
        }
        off(f, y) {
            this.events.off(f, y)
        }
        removeListener(f, y) {
            this.events.removeListener(f, y)
        }
        initialize() {
            return i.__awaiter(this, void 0, void 0, function*() {
                this.intervalRef = setInterval(() => this.pulse(), t.toMiliseconds(this.interval))
            })
        }
        pulse() {
            this.events.emit(o.HEARTBEAT_EVENTS.pulse)
        }
    }
    return ls.HeartBeat = c, ls
}(function(i) {
    Object.defineProperty(i, "__esModule", {
        value: !0
    });
    const e = sa;
    e.__exportStar(i3(), i), e.__exportStar(lp(), i), e.__exportStar(fp(), i)
})(Bn);
var Ye = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var _u = function(i, e) {
    return _u = Object.setPrototypeOf || {
        __proto__: []
    }
    instanceof Array && function(t, s) {
        t.__proto__ = s
    } || function(t, s) {
        for (var o in s) s.hasOwnProperty(o) && (t[o] = s[o])
    }, _u(i, e)
};

function n3(i, e) {
    _u(i, e);

    function t() {
        this.constructor = i
    }
    i.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t)
}
var mu = function() {
    return mu = Object.assign || function(e) {
        for (var t, s = 1, o = arguments.length; s < o; s++) {
            t = arguments[s];
            for (var c in t) Object.prototype.hasOwnProperty.call(t, c) && (e[c] = t[c])
        }
        return e
    }, mu.apply(this, arguments)
};

function s3(i, e) {
    var t = {};
    for (var s in i) Object.prototype.hasOwnProperty.call(i, s) && e.indexOf(s) < 0 && (t[s] = i[s]);
    if (i != null && typeof Object.getOwnPropertySymbols == "function")
        for (var o = 0, s = Object.getOwnPropertySymbols(i); o < s.length; o++) e.indexOf(s[o]) < 0 && Object.prototype.propertyIsEnumerable.call(i, s[o]) && (t[s[o]] = i[s[o]]);
    return t
}

function o3(i, e, t, s) {
    var o = arguments.length,
        c = o < 3 ? e : s === null ? s = Object.getOwnPropertyDescriptor(e, t) : s,
        l;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") c = Reflect.decorate(i, e, t, s);
    else
        for (var f = i.length - 1; f >= 0; f--)(l = i[f]) && (c = (o < 3 ? l(c) : o > 3 ? l(e, t, c) : l(e, t)) || c);
    return o > 3 && c && Object.defineProperty(e, t, c), c
}

function a3(i, e) {
    return function(t, s) {
        e(t, s, i)
    }
}

function c3(i, e) {
    if (typeof Reflect == "object" && typeof Reflect.metadata == "function") return Reflect.metadata(i, e)
}

function u3(i, e, t, s) {
    function o(c) {
        return c instanceof t ? c : new t(function(l) {
            l(c)
        })
    }
    return new(t || (t = Promise))(function(c, l) {
        function f(v) {
            try {
                p(s.next(v))
            } catch (D) {
                l(D)
            }
        }

        function y(v) {
            try {
                p(s.throw(v))
            } catch (D) {
                l(D)
            }
        }

        function p(v) {
            v.done ? c(v.value) : o(v.value).then(f, y)
        }
        p((s = s.apply(i, e || [])).next())
    })
}

function h3(i, e) {
    var t = {
            label: 0,
            sent: function() {
                if (c[0] & 1) throw c[1];
                return c[1]
            },
            trys: [],
            ops: []
        },
        s, o, c, l;
    return l = {
        next: f(0),
        throw: f(1),
        return: f(2)
    }, typeof Symbol == "function" && (l[Symbol.iterator] = function() {
        return this
    }), l;

    function f(p) {
        return function(v) {
            return y([p, v])
        }
    }

    function y(p) {
        if (s) throw new TypeError("Generator is already executing.");
        for (; t;) try {
            if (s = 1, o && (c = p[0] & 2 ? o.return : p[0] ? o.throw || ((c = o.return) && c.call(o), 0) : o.next) && !(c = c.call(o, p[1])).done) return c;
            switch (o = 0, c && (p = [p[0] & 2, c.value]), p[0]) {
                case 0:
                case 1:
                    c = p;
                    break;
                case 4:
                    return t.label++, {
                        value: p[1],
                        done: !1
                    };
                case 5:
                    t.label++, o = p[1], p = [0];
                    continue;
                case 7:
                    p = t.ops.pop(), t.trys.pop();
                    continue;
                default:
                    if (c = t.trys, !(c = c.length > 0 && c[c.length - 1]) && (p[0] === 6 || p[0] === 2)) {
                        t = 0;
                        continue
                    }
                    if (p[0] === 3 && (!c || p[1] > c[0] && p[1] < c[3])) {
                        t.label = p[1];
                        break
                    }
                    if (p[0] === 6 && t.label < c[1]) {
                        t.label = c[1], c = p;
                        break
                    }
                    if (c && t.label < c[2]) {
                        t.label = c[2], t.ops.push(p);
                        break
                    }
                    c[2] && t.ops.pop(), t.trys.pop();
                    continue
            }
            p = e.call(i, t)
        } catch (v) {
            p = [6, v], o = 0
        } finally {
            s = c = 0
        }
        if (p[0] & 5) throw p[1];
        return {
            value: p[0] ? p[1] : void 0,
            done: !0
        }
    }
}

function l3(i, e, t, s) {
    s === void 0 && (s = t), i[s] = e[t]
}

function f3(i, e) {
    for (var t in i) t !== "default" && !e.hasOwnProperty(t) && (e[t] = i[t])
}

function bu(i) {
    var e = typeof Symbol == "function" && Symbol.iterator,
        t = e && i[e],
        s = 0;
    if (t) return t.call(i);
    if (i && typeof i.length == "number") return {
        next: function() {
            return i && s >= i.length && (i = void 0), {
                value: i && i[s++],
                done: !i
            }
        }
    };
    throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.")
}

function dp(i, e) {
    var t = typeof Symbol == "function" && i[Symbol.iterator];
    if (!t) return i;
    var s = t.call(i),
        o, c = [],
        l;
    try {
        for (;
            (e === void 0 || e-- > 0) && !(o = s.next()).done;) c.push(o.value)
    } catch (f) {
        l = {
            error: f
        }
    } finally {
        try {
            o && !o.done && (t = s.return) && t.call(s)
        } finally {
            if (l) throw l.error
        }
    }
    return c
}

function d3() {
    for (var i = [], e = 0; e < arguments.length; e++) i = i.concat(dp(arguments[e]));
    return i
}

function p3() {
    for (var i = 0, e = 0, t = arguments.length; e < t; e++) i += arguments[e].length;
    for (var s = Array(i), o = 0, e = 0; e < t; e++)
        for (var c = arguments[e], l = 0, f = c.length; l < f; l++, o++) s[o] = c[l];
    return s
}

function Is(i) {
    return this instanceof Is ? (this.v = i, this) : new Is(i)
}

function g3(i, e, t) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var s = t.apply(i, e || []),
        o, c = [];
    return o = {}, l("next"), l("throw"), l("return"), o[Symbol.asyncIterator] = function() {
        return this
    }, o;

    function l(S) {
        s[S] && (o[S] = function(x) {
            return new Promise(function(O, F) {
                c.push([S, x, O, F]) > 1 || f(S, x)
            })
        })
    }

    function f(S, x) {
        try {
            y(s[S](x))
        } catch (O) {
            D(c[0][3], O)
        }
    }

    function y(S) {
        S.value instanceof Is ? Promise.resolve(S.value.v).then(p, v) : D(c[0][2], S)
    }

    function p(S) {
        f("next", S)
    }

    function v(S) {
        f("throw", S)
    }

    function D(S, x) {
        S(x), c.shift(), c.length && f(c[0][0], c[0][1])
    }
}

function y3(i) {
    var e, t;
    return e = {}, s("next"), s("throw", function(o) {
        throw o
    }), s("return"), e[Symbol.iterator] = function() {
        return this
    }, e;

    function s(o, c) {
        e[o] = i[o] ? function(l) {
            return (t = !t) ? {
                value: Is(i[o](l)),
                done: o === "return"
            } : c ? c(l) : l
        } : c
    }
}

function v3(i) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var e = i[Symbol.asyncIterator],
        t;
    return e ? e.call(i) : (i = typeof bu == "function" ? bu(i) : i[Symbol.iterator](), t = {}, s("next"), s("throw"), s("return"), t[Symbol.asyncIterator] = function() {
        return this
    }, t);

    function s(c) {
        t[c] = i[c] && function(l) {
            return new Promise(function(f, y) {
                l = i[c](l), o(f, y, l.done, l.value)
            })
        }
    }

    function o(c, l, f, y) {
        Promise.resolve(y).then(function(p) {
            c({
                value: p,
                done: f
            })
        }, l)
    }
}

function _3(i, e) {
    return Object.defineProperty ? Object.defineProperty(i, "raw", {
        value: e
    }) : i.raw = e, i
}

function m3(i) {
    if (i && i.__esModule) return i;
    var e = {};
    if (i != null)
        for (var t in i) Object.hasOwnProperty.call(i, t) && (e[t] = i[t]);
    return e.default = i, e
}

function b3(i) {
    return i && i.__esModule ? i : {
        default: i
    }
}

function w3(i, e) {
    if (!e.has(i)) throw new TypeError("attempted to get private field on non-instance");
    return e.get(i)
}

function E3(i, e, t) {
    if (!e.has(i)) throw new TypeError("attempted to set private field on non-instance");
    return e.set(i, t), t
}
const D3 = Object.freeze(Object.defineProperty({
        __proto__: null,
        get __assign() {
            return mu
        },
        __asyncDelegator: y3,
        __asyncGenerator: g3,
        __asyncValues: v3,
        __await: Is,
        __awaiter: u3,
        __classPrivateFieldGet: w3,
        __classPrivateFieldSet: E3,
        __createBinding: l3,
        __decorate: o3,
        __exportStar: f3,
        __extends: n3,
        __generator: h3,
        __importDefault: b3,
        __importStar: m3,
        __makeTemplateObject: _3,
        __metadata: c3,
        __param: a3,
        __read: dp,
        __rest: s3,
        __spread: d3,
        __spreadArrays: p3,
        __values: bu
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    S3 = Un(D3);
var Gc, Hf;

function I3() {
    if (Hf) return Gc;
    Hf = 1;

    function i(t) {
        try {
            return JSON.stringify(t)
        } catch {
            return '"[Circular]"'
        }
    }
    Gc = e;

    function e(t, s, o) {
        var c = o && o.stringify || i,
            l = 1;
        if (typeof t == "object" && t !== null) {
            var f = s.length + l;
            if (f === 1) return t;
            var y = new Array(f);
            y[0] = c(t);
            for (var p = 1; p < f; p++) y[p] = c(s[p]);
            return y.join(" ")
        }
        if (typeof t != "string") return t;
        var v = s.length;
        if (v === 0) return t;
        for (var D = "", S = 1 - l, x = -1, O = t && t.length || 0, F = 0; F < O;) {
            if (t.charCodeAt(F) === 37 && F + 1 < O) {
                switch (x = x > -1 ? x : 0, t.charCodeAt(F + 1)) {
                    case 100:
                    case 102:
                        if (S >= v || s[S] == null) break;
                        x < F && (D += t.slice(x, F)), D += Number(s[S]), x = F + 2, F++;
                        break;
                    case 105:
                        if (S >= v || s[S] == null) break;
                        x < F && (D += t.slice(x, F)), D += Math.floor(Number(s[S])), x = F + 2, F++;
                        break;
                    case 79:
                    case 111:
                    case 106:
                        if (S >= v || s[S] === void 0) break;
                        x < F && (D += t.slice(x, F));
                        var K = typeof s[S];
                        if (K === "string") {
                            D += "'" + s[S] + "'", x = F + 2, F++;
                            break
                        }
                        if (K === "function") {
                            D += s[S].name || "<anonymous>", x = F + 2, F++;
                            break
                        }
                        D += c(s[S]), x = F + 2, F++;
                        break;
                    case 115:
                        if (S >= v) break;
                        x < F && (D += t.slice(x, F)), D += String(s[S]), x = F + 2, F++;
                        break;
                    case 37:
                        x < F && (D += t.slice(x, F)), D += "%", x = F + 2, F++, S--;
                        break
                }++S
            }++F
        }
        return x === -1 ? t : (x < O && (D += t.slice(x)), D)
    }
    return Gc
}
var Wc, Bf;

function x3() {
    if (Bf) return Wc;
    Bf = 1;
    const i = I3();
    Wc = o;
    const e = A().console || {},
        t = {
            mapHttpRequest: O,
            mapHttpResponse: O,
            wrapRequestSerializer: F,
            wrapResponseSerializer: F,
            wrapErrorSerializer: F,
            req: O,
            res: O,
            err: S
        };

    function s(E, u) {
        return Array.isArray(E) ? E.filter(function(G) {
            return G !== "!stdSerializers.err"
        }) : E === !0 ? Object.keys(u) : !1
    }

    function o(E) {
        E = E || {}, E.browser = E.browser || {};
        const u = E.browser.transmit;
        if (u && typeof u.send != "function") throw Error("pino: transmit option must have a send function");
        const b = E.browser.write || e;
        E.browser.write && (E.browser.asObject = !0);
        const G = E.serializers || {},
            W = s(E.browser.serialize, G);
        let se = E.browser.serialize;
        Array.isArray(E.browser.serialize) && E.browser.serialize.indexOf("!stdSerializers.err") > -1 && (se = !1);
        const ue = ["error", "fatal", "warn", "info", "debug", "trace"];
        typeof b == "function" && (b.error = b.fatal = b.warn = b.info = b.debug = b.trace = b), E.enabled === !1 && (E.level = "silent");
        const de = E.level || "info",
            w = Object.create(b);
        w.log || (w.log = K), Object.defineProperty(w, "levelVal", {
            get: ee
        }), Object.defineProperty(w, "level", {
            get: Q,
            set: k
        });
        const T = {
            transmit: u,
            serialize: W,
            asObject: E.browser.asObject,
            levels: ue,
            timestamp: x(E)
        };
        w.levels = o.levels, w.level = de, w.setMaxListeners = w.getMaxListeners = w.emit = w.addListener = w.on = w.prependListener = w.once = w.prependOnceListener = w.removeListener = w.removeAllListeners = w.listeners = w.listenerCount = w.eventNames = w.write = w.flush = K, w.serializers = G, w._serialize = W, w._stdErrSerialize = se, w.child = V, u && (w._logEvent = D());

        function ee() {
            return this.level === "silent" ? 1 / 0 : this.levels.values[this.level]
        }

        function Q() {
            return this._level
        }

        function k(J) {
            if (J !== "silent" && !this.levels.values[J]) throw Error("unknown level " + J);
            this._level = J, c(T, w, "error", "log"), c(T, w, "fatal", "error"), c(T, w, "warn", "error"), c(T, w, "info", "log"), c(T, w, "debug", "log"), c(T, w, "trace", "log")
        }

        function V(J, re) {
            if (!J) throw new Error("missing bindings for child Pino");
            re = re || {}, W && J.serializers && (re.serializers = J.serializers);
            const be = re.serializers;
            if (W && be) {
                var oe = Object.assign({}, G, be),
                    we = E.browser.serialize === !0 ? Object.keys(oe) : W;
                delete J.serializers, y([J], we, oe, this._stdErrSerialize)
            }

            function le(_e) {
                this._childLevel = (_e._childLevel | 0) + 1, this.error = p(_e, J, "error"), this.fatal = p(_e, J, "fatal"), this.warn = p(_e, J, "warn"), this.info = p(_e, J, "info"), this.debug = p(_e, J, "debug"), this.trace = p(_e, J, "trace"), oe && (this.serializers = oe, this._serialize = we), u && (this._logEvent = D([].concat(_e._logEvent.bindings, J)))
            }
            return le.prototype = this, new le(this)
        }
        return w
    }
    o.levels = {
        values: {
            fatal: 60,
            error: 50,
            warn: 40,
            info: 30,
            debug: 20,
            trace: 10
        },
        labels: {
            10: "trace",
            20: "debug",
            30: "info",
            40: "warn",
            50: "error",
            60: "fatal"
        }
    }, o.stdSerializers = t, o.stdTimeFunctions = Object.assign({}, {
        nullTime: ne,
        epochTime: $,
        unixTime: U,
        isoTime: C
    });

    function c(E, u, b, G) {
        const W = Object.getPrototypeOf(u);
        u[b] = u.levelVal > u.levels.values[b] ? K : W[b] ? W[b] : e[b] || e[G] || K, l(E, u, b)
    }

    function l(E, u, b) {
        !E.transmit && u[b] === K || (u[b] = function(G) {
            return function() {
                const se = E.timestamp(),
                    ue = new Array(arguments.length),
                    de = Object.getPrototypeOf && Object.getPrototypeOf(this) === e ? e : this;
                for (var w = 0; w < ue.length; w++) ue[w] = arguments[w];
                if (E.serialize && !E.asObject && y(ue, this._serialize, this.serializers, this._stdErrSerialize), E.asObject ? G.call(de, f(this, b, ue, se)) : G.apply(de, ue), E.transmit) {
                    const T = E.transmit.level || u.level,
                        ee = o.levels.values[T],
                        Q = o.levels.values[b];
                    if (Q < ee) return;
                    v(this, {
                        ts: se,
                        methodLevel: b,
                        methodValue: Q,
                        transmitLevel: T,
                        transmitValue: o.levels.values[E.transmit.level || u.level],
                        send: E.transmit.send,
                        val: u.levelVal
                    }, ue)
                }
            }
        }(u[b]))
    }

    function f(E, u, b, G) {
        E._serialize && y(b, E._serialize, E.serializers, E._stdErrSerialize);
        const W = b.slice();
        let se = W[0];
        const ue = {};
        G && (ue.time = G), ue.level = o.levels.values[u];
        let de = (E._childLevel | 0) + 1;
        if (de < 1 && (de = 1), se !== null && typeof se == "object") {
            for (; de-- && typeof W[0] == "object";) Object.assign(ue, W.shift());
            se = W.length ? i(W.shift(), W) : void 0
        } else typeof se == "string" && (se = i(W.shift(), W));
        return se !== void 0 && (ue.msg = se), ue
    }

    function y(E, u, b, G) {
        for (const W in E)
            if (G && E[W] instanceof Error) E[W] = o.stdSerializers.err(E[W]);
            else if (typeof E[W] == "object" && !Array.isArray(E[W]))
            for (const se in E[W]) u && u.indexOf(se) > -1 && se in b && (E[W][se] = b[se](E[W][se]))
    }

    function p(E, u, b) {
        return function() {
            const G = new Array(1 + arguments.length);
            G[0] = u;
            for (var W = 1; W < G.length; W++) G[W] = arguments[W - 1];
            return E[b].apply(this, G)
        }
    }

    function v(E, u, b) {
        const G = u.send,
            W = u.ts,
            se = u.methodLevel,
            ue = u.methodValue,
            de = u.val,
            w = E._logEvent.bindings;
        y(b, E._serialize || Object.keys(E.serializers), E.serializers, E._stdErrSerialize === void 0 ? !0 : E._stdErrSerialize), E._logEvent.ts = W, E._logEvent.messages = b.filter(function(T) {
            return w.indexOf(T) === -1
        }), E._logEvent.level.label = se, E._logEvent.level.value = ue, G(se, E._logEvent, de), E._logEvent = D(w)
    }

    function D(E) {
        return {
            ts: 0,
            messages: [],
            bindings: E || [],
            level: {
                label: "",
                value: 0
            }
        }
    }

    function S(E) {
        const u = {
            type: E.constructor.name,
            msg: E.message,
            stack: E.stack
        };
        for (const b in E) u[b] === void 0 && (u[b] = E[b]);
        return u
    }

    function x(E) {
        return typeof E.timestamp == "function" ? E.timestamp : E.timestamp === !1 ? ne : $
    }

    function O() {
        return {}
    }

    function F(E) {
        return E
    }

    function K() {}

    function ne() {
        return !1
    }

    function $() {
        return Date.now()
    }

    function U() {
        return Math.round(Date.now() / 1e3)
    }

    function C() {
        return new Date(Date.now()).toISOString()
    }

    function A() {
        function E(u) {
            return typeof u < "u" && u
        }
        try {
            return typeof globalThis < "u" || Object.defineProperty(Object.prototype, "globalThis", {
                get: function() {
                    return delete Object.prototype.globalThis, this.globalThis = this
                },
                configurable: !0
            }), globalThis
        } catch {
            return E(self) || E(window) || E(this) || {}
        }
    }
    return Wc
}
var nn = {},
    Kf;

function pp() {
    return Kf || (Kf = 1, Object.defineProperty(nn, "__esModule", {
        value: !0
    }), nn.PINO_CUSTOM_CONTEXT_KEY = nn.PINO_LOGGER_DEFAULTS = void 0, nn.PINO_LOGGER_DEFAULTS = {
        level: "info"
    }, nn.PINO_CUSTOM_CONTEXT_KEY = "custom_context"), nn
}
var or = {},
    kf;

function O3() {
    if (kf) return or;
    kf = 1, Object.defineProperty(or, "__esModule", {
        value: !0
    }), or.generateChildLogger = or.formatChildLoggerContext = or.getLoggerContext = or.setBrowserLoggerContext = or.getBrowserLoggerContext = or.getDefaultLoggerOptions = void 0;
    const i = pp();

    function e(f) {
        return Object.assign(Object.assign({}, f), {
            level: (f == null ? void 0 : f.level) || i.PINO_LOGGER_DEFAULTS.level
        })
    }
    or.getDefaultLoggerOptions = e;

    function t(f, y = i.PINO_CUSTOM_CONTEXT_KEY) {
        return f[y] || ""
    }
    or.getBrowserLoggerContext = t;

    function s(f, y, p = i.PINO_CUSTOM_CONTEXT_KEY) {
        return f[p] = y, f
    }
    or.setBrowserLoggerContext = s;

    function o(f, y = i.PINO_CUSTOM_CONTEXT_KEY) {
        let p = "";
        return typeof f.bindings > "u" ? p = t(f, y) : p = f.bindings().context || "", p
    }
    or.getLoggerContext = o;

    function c(f, y, p = i.PINO_CUSTOM_CONTEXT_KEY) {
        const v = o(f, p);
        return v.trim() ? `${v}/${y}` : y
    }
    or.formatChildLoggerContext = c;

    function l(f, y, p = i.PINO_CUSTOM_CONTEXT_KEY) {
        const v = c(f, y, p),
            D = f.child({
                context: v
            });
        return s(D, v, p)
    }
    return or.generateChildLogger = l, or
}(function(i) {
    Object.defineProperty(i, "__esModule", {
        value: !0
    }), i.pino = void 0;
    const e = S3,
        t = e.__importDefault(x3());
    Object.defineProperty(i, "pino", {
        enumerable: !0,
        get: function() {
            return t.default
        }
    }), e.__exportStar(pp(), i), e.__exportStar(O3(), i)
})(Ye);
class P3 extends hn {
    constructor(e) {
        super(), this.opts = e, this.protocol = "wc", this.version = 2
    }
}
let C3 = class extends hn {
        constructor(e, t) {
            super(), this.core = e, this.logger = t, this.records = new Map
        }
    },
    T3 = class {
        constructor(e, t) {
            this.logger = e, this.core = t
        }
    },
    A3 = class extends hn {
        constructor(e, t) {
            super(), this.relayer = e, this.logger = t
        }
    },
    R3 = class extends hn {
        constructor(e) {
            super()
        }
    },
    N3 = class {
        constructor(e, t, s, o) {
            this.core = e, this.logger = t, this.name = s
        }
    };
class $3 extends hn {
    constructor(e, t) {
        super(), this.relayer = e, this.logger = t
    }
}
let j3 = class extends hn {
        constructor(e, t) {
            super(), this.core = e, this.logger = t
        }
    },
    L3 = class {
        constructor(e, t) {
            this.projectId = e, this.logger = t
        }
    },
    M3 = class {
        constructor(e, t) {
            this.projectId = e, this.logger = t
        }
    },
    U3 = class {
        constructor(e) {
            this.opts = e, this.protocol = "wc", this.version = 2
        }
    },
    q3 = class {
        constructor(e) {
            this.client = e
        }
    };
var ku = {},
    gp = {};
(function(i) {
    Object.defineProperty(i, "__esModule", {
        value: !0
    });
    var e = ea,
        t = wi;
    i.DIGEST_LENGTH = 64, i.BLOCK_SIZE = 128;
    var s = function() {
        function f() {
            this.digestLength = i.DIGEST_LENGTH, this.blockSize = i.BLOCK_SIZE, this._stateHi = new Int32Array(8), this._stateLo = new Int32Array(8), this._tempHi = new Int32Array(16), this._tempLo = new Int32Array(16), this._buffer = new Uint8Array(256), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this.reset()
        }
        return f.prototype._initState = function() {
            this._stateHi[0] = 1779033703, this._stateHi[1] = 3144134277, this._stateHi[2] = 1013904242, this._stateHi[3] = 2773480762, this._stateHi[4] = 1359893119, this._stateHi[5] = 2600822924, this._stateHi[6] = 528734635, this._stateHi[7] = 1541459225, this._stateLo[0] = 4089235720, this._stateLo[1] = 2227873595, this._stateLo[2] = 4271175723, this._stateLo[3] = 1595750129, this._stateLo[4] = 2917565137, this._stateLo[5] = 725511199, this._stateLo[6] = 4215389547, this._stateLo[7] = 327033209
        }, f.prototype.reset = function() {
            return this._initState(), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this
        }, f.prototype.clean = function() {
            t.wipe(this._buffer), t.wipe(this._tempHi), t.wipe(this._tempLo), this.reset()
        }, f.prototype.update = function(y, p) {
            if (p === void 0 && (p = y.length), this._finished) throw new Error("SHA512: can't update because hash was finished.");
            var v = 0;
            if (this._bytesHashed += p, this._bufferLength > 0) {
                for (; this._bufferLength < i.BLOCK_SIZE && p > 0;) this._buffer[this._bufferLength++] = y[v++], p--;
                this._bufferLength === this.blockSize && (c(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, this.blockSize), this._bufferLength = 0)
            }
            for (p >= this.blockSize && (v = c(this._tempHi, this._tempLo, this._stateHi, this._stateLo, y, v, p), p %= this.blockSize); p > 0;) this._buffer[this._bufferLength++] = y[v++], p--;
            return this
        }, f.prototype.finish = function(y) {
            if (!this._finished) {
                var p = this._bytesHashed,
                    v = this._bufferLength,
                    D = p / 536870912 | 0,
                    S = p << 3,
                    x = p % 128 < 112 ? 128 : 256;
                this._buffer[v] = 128;
                for (var O = v + 1; O < x - 8; O++) this._buffer[O] = 0;
                e.writeUint32BE(D, this._buffer, x - 8), e.writeUint32BE(S, this._buffer, x - 4), c(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, x), this._finished = !0
            }
            for (var O = 0; O < this.digestLength / 8; O++) e.writeUint32BE(this._stateHi[O], y, O * 8), e.writeUint32BE(this._stateLo[O], y, O * 8 + 4);
            return this
        }, f.prototype.digest = function() {
            var y = new Uint8Array(this.digestLength);
            return this.finish(y), y
        }, f.prototype.saveState = function() {
            if (this._finished) throw new Error("SHA256: cannot save finished state");
            return {
                stateHi: new Int32Array(this._stateHi),
                stateLo: new Int32Array(this._stateLo),
                buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
                bufferLength: this._bufferLength,
                bytesHashed: this._bytesHashed
            }
        }, f.prototype.restoreState = function(y) {
            return this._stateHi.set(y.stateHi), this._stateLo.set(y.stateLo), this._bufferLength = y.bufferLength, y.buffer && this._buffer.set(y.buffer), this._bytesHashed = y.bytesHashed, this._finished = !1, this
        }, f.prototype.cleanSavedState = function(y) {
            t.wipe(y.stateHi), t.wipe(y.stateLo), y.buffer && t.wipe(y.buffer), y.bufferLength = 0, y.bytesHashed = 0
        }, f
    }();
    i.SHA512 = s;
    var o = new Int32Array([1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591]);

    function c(f, y, p, v, D, S, x) {
        for (var O = p[0], F = p[1], K = p[2], ne = p[3], $ = p[4], U = p[5], C = p[6], A = p[7], E = v[0], u = v[1], b = v[2], G = v[3], W = v[4], se = v[5], ue = v[6], de = v[7], w, T, ee, Q, k, V, J, re; x >= 128;) {
            for (var be = 0; be < 16; be++) {
                var oe = 8 * be + S;
                f[be] = e.readUint32BE(D, oe), y[be] = e.readUint32BE(D, oe + 4)
            }
            for (var be = 0; be < 80; be++) {
                var we = O,
                    le = F,
                    _e = K,
                    H = ne,
                    z = $,
                    j = U,
                    d = C,
                    R = A,
                    ae = E,
                    fe = u,
                    Ie = b,
                    Fe = G,
                    Ke = W,
                    Le = se,
                    dt = ue,
                    pt = de;
                if (w = A, T = de, k = T & 65535, V = T >>> 16, J = w & 65535, re = w >>> 16, w = ($ >>> 14 | W << 18) ^ ($ >>> 18 | W << 14) ^ (W >>> 9 | $ << 23), T = (W >>> 14 | $ << 18) ^ (W >>> 18 | $ << 14) ^ ($ >>> 9 | W << 23), k += T & 65535, V += T >>> 16, J += w & 65535, re += w >>> 16, w = $ & U ^ ~$ & C, T = W & se ^ ~W & ue, k += T & 65535, V += T >>> 16, J += w & 65535, re += w >>> 16, w = o[be * 2], T = o[be * 2 + 1], k += T & 65535, V += T >>> 16, J += w & 65535, re += w >>> 16, w = f[be % 16], T = y[be % 16], k += T & 65535, V += T >>> 16, J += w & 65535, re += w >>> 16, V += k >>> 16, J += V >>> 16, re += J >>> 16, ee = J & 65535 | re << 16, Q = k & 65535 | V << 16, w = ee, T = Q, k = T & 65535, V = T >>> 16, J = w & 65535, re = w >>> 16, w = (O >>> 28 | E << 4) ^ (E >>> 2 | O << 30) ^ (E >>> 7 | O << 25), T = (E >>> 28 | O << 4) ^ (O >>> 2 | E << 30) ^ (O >>> 7 | E << 25), k += T & 65535, V += T >>> 16, J += w & 65535, re += w >>> 16, w = O & F ^ O & K ^ F & K, T = E & u ^ E & b ^ u & b, k += T & 65535, V += T >>> 16, J += w & 65535, re += w >>> 16, V += k >>> 16, J += V >>> 16, re += J >>> 16, R = J & 65535 | re << 16, pt = k & 65535 | V << 16, w = H, T = Fe, k = T & 65535, V = T >>> 16, J = w & 65535, re = w >>> 16, w = ee, T = Q, k += T & 65535, V += T >>> 16, J += w & 65535, re += w >>> 16, V += k >>> 16, J += V >>> 16, re += J >>> 16, H = J & 65535 | re << 16, Fe = k & 65535 | V << 16, F = we, K = le, ne = _e, $ = H, U = z, C = j, A = d, O = R, u = ae, b = fe, G = Ie, W = Fe, se = Ke, ue = Le, de = dt, E = pt, be % 16 === 15)
                    for (var oe = 0; oe < 16; oe++) w = f[oe], T = y[oe], k = T & 65535, V = T >>> 16, J = w & 65535, re = w >>> 16, w = f[(oe + 9) % 16], T = y[(oe + 9) % 16], k += T & 65535, V += T >>> 16, J += w & 65535, re += w >>> 16, ee = f[(oe + 1) % 16], Q = y[(oe + 1) % 16], w = (ee >>> 1 | Q << 31) ^ (ee >>> 8 | Q << 24) ^ ee >>> 7, T = (Q >>> 1 | ee << 31) ^ (Q >>> 8 | ee << 24) ^ (Q >>> 7 | ee << 25), k += T & 65535, V += T >>> 16, J += w & 65535, re += w >>> 16, ee = f[(oe + 14) % 16], Q = y[(oe + 14) % 16], w = (ee >>> 19 | Q << 13) ^ (Q >>> 29 | ee << 3) ^ ee >>> 6, T = (Q >>> 19 | ee << 13) ^ (ee >>> 29 | Q << 3) ^ (Q >>> 6 | ee << 26), k += T & 65535, V += T >>> 16, J += w & 65535, re += w >>> 16, V += k >>> 16, J += V >>> 16, re += J >>> 16, f[oe] = J & 65535 | re << 16, y[oe] = k & 65535 | V << 16
            }
            w = O, T = E, k = T & 65535, V = T >>> 16, J = w & 65535, re = w >>> 16, w = p[0], T = v[0], k += T & 65535, V += T >>> 16, J += w & 65535, re += w >>> 16, V += k >>> 16, J += V >>> 16, re += J >>> 16, p[0] = O = J & 65535 | re << 16, v[0] = E = k & 65535 | V << 16, w = F, T = u, k = T & 65535, V = T >>> 16, J = w & 65535, re = w >>> 16, w = p[1], T = v[1], k += T & 65535, V += T >>> 16, J += w & 65535, re += w >>> 16, V += k >>> 16, J += V >>> 16, re += J >>> 16, p[1] = F = J & 65535 | re << 16, v[1] = u = k & 65535 | V << 16, w = K, T = b, k = T & 65535, V = T >>> 16, J = w & 65535, re = w >>> 16, w = p[2], T = v[2], k += T & 65535, V += T >>> 16, J += w & 65535, re += w >>> 16, V += k >>> 16, J += V >>> 16, re += J >>> 16, p[2] = K = J & 65535 | re << 16, v[2] = b = k & 65535 | V << 16, w = ne, T = G, k = T & 65535, V = T >>> 16, J = w & 65535, re = w >>> 16, w = p[3], T = v[3], k += T & 65535, V += T >>> 16, J += w & 65535, re += w >>> 16, V += k >>> 16, J += V >>> 16, re += J >>> 16, p[3] = ne = J & 65535 | re << 16, v[3] = G = k & 65535 | V << 16, w = $, T = W, k = T & 65535, V = T >>> 16, J = w & 65535, re = w >>> 16, w = p[4], T = v[4], k += T & 65535, V += T >>> 16, J += w & 65535, re += w >>> 16, V += k >>> 16, J += V >>> 16, re += J >>> 16, p[4] = $ = J & 65535 | re << 16, v[4] = W = k & 65535 | V << 16, w = U, T = se, k = T & 65535, V = T >>> 16, J = w & 65535, re = w >>> 16, w = p[5], T = v[5], k += T & 65535, V += T >>> 16, J += w & 65535, re += w >>> 16, V += k >>> 16, J += V >>> 16, re += J >>> 16, p[5] = U = J & 65535 | re << 16, v[5] = se = k & 65535 | V << 16, w = C, T = ue, k = T & 65535, V = T >>> 16, J = w & 65535, re = w >>> 16, w = p[6], T = v[6], k += T & 65535, V += T >>> 16, J += w & 65535, re += w >>> 16, V += k >>> 16, J += V >>> 16, re += J >>> 16, p[6] = C = J & 65535 | re << 16, v[6] = ue = k & 65535 | V << 16, w = A, T = de, k = T & 65535, V = T >>> 16, J = w & 65535, re = w >>> 16, w = p[7], T = v[7], k += T & 65535, V += T >>> 16, J += w & 65535, re += w >>> 16, V += k >>> 16, J += V >>> 16, re += J >>> 16, p[7] = A = J & 65535 | re << 16, v[7] = de = k & 65535 | V << 16, S += 128, x -= 128
        }
        return S
    }

    function l(f) {
        var y = new s;
        y.update(f);
        var p = y.digest();
        return y.clean(), p
    }
    i.hash = l
})(gp);
(function(i) {
    Object.defineProperty(i, "__esModule", {
        value: !0
    }), i.convertSecretKeyToX25519 = i.convertPublicKeyToX25519 = i.verify = i.sign = i.extractPublicKeyFromSecretKey = i.generateKeyPair = i.generateKeyPairFromSeed = i.SEED_LENGTH = i.SECRET_KEY_LENGTH = i.PUBLIC_KEY_LENGTH = i.SIGNATURE_LENGTH = void 0;
    const e = Os,
        t = gp,
        s = wi;
    i.SIGNATURE_LENGTH = 64, i.PUBLIC_KEY_LENGTH = 32, i.SECRET_KEY_LENGTH = 64, i.SEED_LENGTH = 32;

    function o(H) {
        const z = new Float64Array(16);
        if (H)
            for (let j = 0; j < H.length; j++) z[j] = H[j];
        return z
    }
    const c = new Uint8Array(32);
    c[0] = 9;
    const l = o(),
        f = o([1]),
        y = o([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]),
        p = o([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]),
        v = o([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]),
        D = o([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]),
        S = o([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);

    function x(H, z) {
        for (let j = 0; j < 16; j++) H[j] = z[j] | 0
    }

    function O(H) {
        let z = 1;
        for (let j = 0; j < 16; j++) {
            let d = H[j] + z + 65535;
            z = Math.floor(d / 65536), H[j] = d - z * 65536
        }
        H[0] += z - 1 + 37 * (z - 1)
    }

    function F(H, z, j) {
        const d = ~(j - 1);
        for (let R = 0; R < 16; R++) {
            const ae = d & (H[R] ^ z[R]);
            H[R] ^= ae, z[R] ^= ae
        }
    }

    function K(H, z) {
        const j = o(),
            d = o();
        for (let R = 0; R < 16; R++) d[R] = z[R];
        O(d), O(d), O(d);
        for (let R = 0; R < 2; R++) {
            j[0] = d[0] - 65517;
            for (let fe = 1; fe < 15; fe++) j[fe] = d[fe] - 65535 - (j[fe - 1] >> 16 & 1), j[fe - 1] &= 65535;
            j[15] = d[15] - 32767 - (j[14] >> 16 & 1);
            const ae = j[15] >> 16 & 1;
            j[14] &= 65535, F(d, j, 1 - ae)
        }
        for (let R = 0; R < 16; R++) H[2 * R] = d[R] & 255, H[2 * R + 1] = d[R] >> 8
    }

    function ne(H, z) {
        let j = 0;
        for (let d = 0; d < 32; d++) j |= H[d] ^ z[d];
        return (1 & j - 1 >>> 8) - 1
    }

    function $(H, z) {
        const j = new Uint8Array(32),
            d = new Uint8Array(32);
        return K(j, H), K(d, z), ne(j, d)
    }

    function U(H) {
        const z = new Uint8Array(32);
        return K(z, H), z[0] & 1
    }

    function C(H, z) {
        for (let j = 0; j < 16; j++) H[j] = z[2 * j] + (z[2 * j + 1] << 8);
        H[15] &= 32767
    }

    function A(H, z, j) {
        for (let d = 0; d < 16; d++) H[d] = z[d] + j[d]
    }

    function E(H, z, j) {
        for (let d = 0; d < 16; d++) H[d] = z[d] - j[d]
    }

    function u(H, z, j) {
        let d, R, ae = 0,
            fe = 0,
            Ie = 0,
            Fe = 0,
            Ke = 0,
            Le = 0,
            dt = 0,
            pt = 0,
            Ue = 0,
            xe = 0,
            Ne = 0,
            $e = 0,
            qe = 0,
            Pe = 0,
            je = 0,
            Se = 0,
            Ce = 0,
            He = 0,
            Oe = 0,
            ke = 0,
            Ge = 0,
            Ze = 0,
            et = 0,
            Je = 0,
            er = 0,
            lr = 0,
            Wr = 0,
            tr = 0,
            ii = 0,
            Si = 0,
            zi = 0,
            Et = j[0],
            gt = j[1],
            Dt = j[2],
            St = j[3],
            bt = j[4],
            yt = j[5],
            $t = j[6],
            jt = j[7],
            It = j[8],
            Lt = j[9],
            xt = j[10],
            Ct = j[11],
            Ot = j[12],
            ut = j[13],
            Mt = j[14],
            Ut = j[15];
        d = z[0], ae += d * Et, fe += d * gt, Ie += d * Dt, Fe += d * St, Ke += d * bt, Le += d * yt, dt += d * $t, pt += d * jt, Ue += d * It, xe += d * Lt, Ne += d * xt, $e += d * Ct, qe += d * Ot, Pe += d * ut, je += d * Mt, Se += d * Ut, d = z[1], fe += d * Et, Ie += d * gt, Fe += d * Dt, Ke += d * St, Le += d * bt, dt += d * yt, pt += d * $t, Ue += d * jt, xe += d * It, Ne += d * Lt, $e += d * xt, qe += d * Ct, Pe += d * Ot, je += d * ut, Se += d * Mt, Ce += d * Ut, d = z[2], Ie += d * Et, Fe += d * gt, Ke += d * Dt, Le += d * St, dt += d * bt, pt += d * yt, Ue += d * $t, xe += d * jt, Ne += d * It, $e += d * Lt, qe += d * xt, Pe += d * Ct, je += d * Ot, Se += d * ut, Ce += d * Mt, He += d * Ut, d = z[3], Fe += d * Et, Ke += d * gt, Le += d * Dt, dt += d * St, pt += d * bt, Ue += d * yt, xe += d * $t, Ne += d * jt, $e += d * It, qe += d * Lt, Pe += d * xt, je += d * Ct, Se += d * Ot, Ce += d * ut, He += d * Mt, Oe += d * Ut, d = z[4], Ke += d * Et, Le += d * gt, dt += d * Dt, pt += d * St, Ue += d * bt, xe += d * yt, Ne += d * $t, $e += d * jt, qe += d * It, Pe += d * Lt, je += d * xt, Se += d * Ct, Ce += d * Ot, He += d * ut, Oe += d * Mt, ke += d * Ut, d = z[5], Le += d * Et, dt += d * gt, pt += d * Dt, Ue += d * St, xe += d * bt, Ne += d * yt, $e += d * $t, qe += d * jt, Pe += d * It, je += d * Lt, Se += d * xt, Ce += d * Ct, He += d * Ot, Oe += d * ut, ke += d * Mt, Ge += d * Ut, d = z[6], dt += d * Et, pt += d * gt, Ue += d * Dt, xe += d * St, Ne += d * bt, $e += d * yt, qe += d * $t, Pe += d * jt, je += d * It, Se += d * Lt, Ce += d * xt, He += d * Ct, Oe += d * Ot, ke += d * ut, Ge += d * Mt, Ze += d * Ut, d = z[7], pt += d * Et, Ue += d * gt, xe += d * Dt, Ne += d * St, $e += d * bt, qe += d * yt, Pe += d * $t, je += d * jt, Se += d * It, Ce += d * Lt, He += d * xt, Oe += d * Ct, ke += d * Ot, Ge += d * ut, Ze += d * Mt, et += d * Ut, d = z[8], Ue += d * Et, xe += d * gt, Ne += d * Dt, $e += d * St, qe += d * bt, Pe += d * yt, je += d * $t, Se += d * jt, Ce += d * It, He += d * Lt, Oe += d * xt, ke += d * Ct, Ge += d * Ot, Ze += d * ut, et += d * Mt, Je += d * Ut, d = z[9], xe += d * Et, Ne += d * gt, $e += d * Dt, qe += d * St, Pe += d * bt, je += d * yt, Se += d * $t, Ce += d * jt, He += d * It, Oe += d * Lt, ke += d * xt, Ge += d * Ct, Ze += d * Ot, et += d * ut, Je += d * Mt, er += d * Ut, d = z[10], Ne += d * Et, $e += d * gt, qe += d * Dt, Pe += d * St, je += d * bt, Se += d * yt, Ce += d * $t, He += d * jt, Oe += d * It, ke += d * Lt, Ge += d * xt, Ze += d * Ct, et += d * Ot, Je += d * ut, er += d * Mt, lr += d * Ut, d = z[11], $e += d * Et, qe += d * gt, Pe += d * Dt, je += d * St, Se += d * bt, Ce += d * yt, He += d * $t, Oe += d * jt, ke += d * It, Ge += d * Lt, Ze += d * xt, et += d * Ct, Je += d * Ot, er += d * ut, lr += d * Mt, Wr += d * Ut, d = z[12], qe += d * Et, Pe += d * gt, je += d * Dt, Se += d * St, Ce += d * bt, He += d * yt, Oe += d * $t, ke += d * jt, Ge += d * It, Ze += d * Lt, et += d * xt, Je += d * Ct, er += d * Ot, lr += d * ut, Wr += d * Mt, tr += d * Ut, d = z[13], Pe += d * Et, je += d * gt, Se += d * Dt, Ce += d * St, He += d * bt, Oe += d * yt, ke += d * $t, Ge += d * jt, Ze += d * It, et += d * Lt, Je += d * xt, er += d * Ct, lr += d * Ot, Wr += d * ut, tr += d * Mt, ii += d * Ut, d = z[14], je += d * Et, Se += d * gt, Ce += d * Dt, He += d * St, Oe += d * bt, ke += d * yt, Ge += d * $t, Ze += d * jt, et += d * It, Je += d * Lt, er += d * xt, lr += d * Ct, Wr += d * Ot, tr += d * ut, ii += d * Mt, Si += d * Ut, d = z[15], Se += d * Et, Ce += d * gt, He += d * Dt, Oe += d * St, ke += d * bt, Ge += d * yt, Ze += d * $t, et += d * jt, Je += d * It, er += d * Lt, lr += d * xt, Wr += d * Ct, tr += d * Ot, ii += d * ut, Si += d * Mt, zi += d * Ut, ae += 38 * Ce, fe += 38 * He, Ie += 38 * Oe, Fe += 38 * ke, Ke += 38 * Ge, Le += 38 * Ze, dt += 38 * et, pt += 38 * Je, Ue += 38 * er, xe += 38 * lr, Ne += 38 * Wr, $e += 38 * tr, qe += 38 * ii, Pe += 38 * Si, je += 38 * zi, R = 1, d = ae + R + 65535, R = Math.floor(d / 65536), ae = d - R * 65536, d = fe + R + 65535, R = Math.floor(d / 65536), fe = d - R * 65536, d = Ie + R + 65535, R = Math.floor(d / 65536), Ie = d - R * 65536, d = Fe + R + 65535, R = Math.floor(d / 65536), Fe = d - R * 65536, d = Ke + R + 65535, R = Math.floor(d / 65536), Ke = d - R * 65536, d = Le + R + 65535, R = Math.floor(d / 65536), Le = d - R * 65536, d = dt + R + 65535, R = Math.floor(d / 65536), dt = d - R * 65536, d = pt + R + 65535, R = Math.floor(d / 65536), pt = d - R * 65536, d = Ue + R + 65535, R = Math.floor(d / 65536), Ue = d - R * 65536, d = xe + R + 65535, R = Math.floor(d / 65536), xe = d - R * 65536, d = Ne + R + 65535, R = Math.floor(d / 65536), Ne = d - R * 65536, d = $e + R + 65535, R = Math.floor(d / 65536), $e = d - R * 65536, d = qe + R + 65535, R = Math.floor(d / 65536), qe = d - R * 65536, d = Pe + R + 65535, R = Math.floor(d / 65536), Pe = d - R * 65536, d = je + R + 65535, R = Math.floor(d / 65536), je = d - R * 65536, d = Se + R + 65535, R = Math.floor(d / 65536), Se = d - R * 65536, ae += R - 1 + 37 * (R - 1), R = 1, d = ae + R + 65535, R = Math.floor(d / 65536), ae = d - R * 65536, d = fe + R + 65535, R = Math.floor(d / 65536), fe = d - R * 65536, d = Ie + R + 65535, R = Math.floor(d / 65536), Ie = d - R * 65536, d = Fe + R + 65535, R = Math.floor(d / 65536), Fe = d - R * 65536, d = Ke + R + 65535, R = Math.floor(d / 65536), Ke = d - R * 65536, d = Le + R + 65535, R = Math.floor(d / 65536), Le = d - R * 65536, d = dt + R + 65535, R = Math.floor(d / 65536), dt = d - R * 65536, d = pt + R + 65535, R = Math.floor(d / 65536), pt = d - R * 65536, d = Ue + R + 65535, R = Math.floor(d / 65536), Ue = d - R * 65536, d = xe + R + 65535, R = Math.floor(d / 65536), xe = d - R * 65536, d = Ne + R + 65535, R = Math.floor(d / 65536), Ne = d - R * 65536, d = $e + R + 65535, R = Math.floor(d / 65536), $e = d - R * 65536, d = qe + R + 65535, R = Math.floor(d / 65536), qe = d - R * 65536, d = Pe + R + 65535, R = Math.floor(d / 65536), Pe = d - R * 65536, d = je + R + 65535, R = Math.floor(d / 65536), je = d - R * 65536, d = Se + R + 65535, R = Math.floor(d / 65536), Se = d - R * 65536, ae += R - 1 + 37 * (R - 1), H[0] = ae, H[1] = fe, H[2] = Ie, H[3] = Fe, H[4] = Ke, H[5] = Le, H[6] = dt, H[7] = pt, H[8] = Ue, H[9] = xe, H[10] = Ne, H[11] = $e, H[12] = qe, H[13] = Pe, H[14] = je, H[15] = Se
    }

    function b(H, z) {
        u(H, z, z)
    }

    function G(H, z) {
        const j = o();
        let d;
        for (d = 0; d < 16; d++) j[d] = z[d];
        for (d = 253; d >= 0; d--) b(j, j), d !== 2 && d !== 4 && u(j, j, z);
        for (d = 0; d < 16; d++) H[d] = j[d]
    }

    function W(H, z) {
        const j = o();
        let d;
        for (d = 0; d < 16; d++) j[d] = z[d];
        for (d = 250; d >= 0; d--) b(j, j), d !== 1 && u(j, j, z);
        for (d = 0; d < 16; d++) H[d] = j[d]
    }

    function se(H, z) {
        const j = o(),
            d = o(),
            R = o(),
            ae = o(),
            fe = o(),
            Ie = o(),
            Fe = o(),
            Ke = o(),
            Le = o();
        E(j, H[1], H[0]), E(Le, z[1], z[0]), u(j, j, Le), A(d, H[0], H[1]), A(Le, z[0], z[1]), u(d, d, Le), u(R, H[3], z[3]), u(R, R, p), u(ae, H[2], z[2]), A(ae, ae, ae), E(fe, d, j), E(Ie, ae, R), A(Fe, ae, R), A(Ke, d, j), u(H[0], fe, Ie), u(H[1], Ke, Fe), u(H[2], Fe, Ie), u(H[3], fe, Ke)
    }

    function ue(H, z, j) {
        for (let d = 0; d < 4; d++) F(H[d], z[d], j)
    }

    function de(H, z) {
        const j = o(),
            d = o(),
            R = o();
        G(R, z[2]), u(j, z[0], R), u(d, z[1], R), K(H, d), H[31] ^= U(j) << 7
    }

    function w(H, z, j) {
        x(H[0], l), x(H[1], f), x(H[2], f), x(H[3], l);
        for (let d = 255; d >= 0; --d) {
            const R = j[d / 8 | 0] >> (d & 7) & 1;
            ue(H, z, R), se(z, H), se(H, H), ue(H, z, R)
        }
    }

    function T(H, z) {
        const j = [o(), o(), o(), o()];
        x(j[0], v), x(j[1], D), x(j[2], f), u(j[3], v, D), w(H, j, z)
    }

    function ee(H) {
        if (H.length !== i.SEED_LENGTH) throw new Error(`ed25519: seed must be ${i.SEED_LENGTH} bytes`);
        const z = (0, t.hash)(H);
        z[0] &= 248, z[31] &= 127, z[31] |= 64;
        const j = new Uint8Array(32),
            d = [o(), o(), o(), o()];
        T(d, z), de(j, d);
        const R = new Uint8Array(64);
        return R.set(H), R.set(j, 32), {
            publicKey: j,
            secretKey: R
        }
    }
    i.generateKeyPairFromSeed = ee;

    function Q(H) {
        const z = (0, e.randomBytes)(32, H),
            j = ee(z);
        return (0, s.wipe)(z), j
    }
    i.generateKeyPair = Q;

    function k(H) {
        if (H.length !== i.SECRET_KEY_LENGTH) throw new Error(`ed25519: secret key must be ${i.SECRET_KEY_LENGTH} bytes`);
        return new Uint8Array(H.subarray(32))
    }
    i.extractPublicKeyFromSecretKey = k;
    const V = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);

    function J(H, z) {
        let j, d, R, ae;
        for (d = 63; d >= 32; --d) {
            for (j = 0, R = d - 32, ae = d - 12; R < ae; ++R) z[R] += j - 16 * z[d] * V[R - (d - 32)], j = Math.floor((z[R] + 128) / 256), z[R] -= j * 256;
            z[R] += j, z[d] = 0
        }
        for (j = 0, R = 0; R < 32; R++) z[R] += j - (z[31] >> 4) * V[R], j = z[R] >> 8, z[R] &= 255;
        for (R = 0; R < 32; R++) z[R] -= j * V[R];
        for (d = 0; d < 32; d++) z[d + 1] += z[d] >> 8, H[d] = z[d] & 255
    }

    function re(H) {
        const z = new Float64Array(64);
        for (let j = 0; j < 64; j++) z[j] = H[j];
        for (let j = 0; j < 64; j++) H[j] = 0;
        J(H, z)
    }

    function be(H, z) {
        const j = new Float64Array(64),
            d = [o(), o(), o(), o()],
            R = (0, t.hash)(H.subarray(0, 32));
        R[0] &= 248, R[31] &= 127, R[31] |= 64;
        const ae = new Uint8Array(64);
        ae.set(R.subarray(32), 32);
        const fe = new t.SHA512;
        fe.update(ae.subarray(32)), fe.update(z);
        const Ie = fe.digest();
        fe.clean(), re(Ie), T(d, Ie), de(ae, d), fe.reset(), fe.update(ae.subarray(0, 32)), fe.update(H.subarray(32)), fe.update(z);
        const Fe = fe.digest();
        re(Fe);
        for (let Ke = 0; Ke < 32; Ke++) j[Ke] = Ie[Ke];
        for (let Ke = 0; Ke < 32; Ke++)
            for (let Le = 0; Le < 32; Le++) j[Ke + Le] += Fe[Ke] * R[Le];
        return J(ae.subarray(32), j), ae
    }
    i.sign = be;

    function oe(H, z) {
        const j = o(),
            d = o(),
            R = o(),
            ae = o(),
            fe = o(),
            Ie = o(),
            Fe = o();
        return x(H[2], f), C(H[1], z), b(R, H[1]), u(ae, R, y), E(R, R, H[2]), A(ae, H[2], ae), b(fe, ae), b(Ie, fe), u(Fe, Ie, fe), u(j, Fe, R), u(j, j, ae), W(j, j), u(j, j, R), u(j, j, ae), u(j, j, ae), u(H[0], j, ae), b(d, H[0]), u(d, d, ae), $(d, R) && u(H[0], H[0], S), b(d, H[0]), u(d, d, ae), $(d, R) ? -1 : (U(H[0]) === z[31] >> 7 && E(H[0], l, H[0]), u(H[3], H[0], H[1]), 0)
    }

    function we(H, z, j) {
        const d = new Uint8Array(32),
            R = [o(), o(), o(), o()],
            ae = [o(), o(), o(), o()];
        if (j.length !== i.SIGNATURE_LENGTH) throw new Error(`ed25519: signature must be ${i.SIGNATURE_LENGTH} bytes`);
        if (oe(ae, H)) return !1;
        const fe = new t.SHA512;
        fe.update(j.subarray(0, 32)), fe.update(H), fe.update(z);
        const Ie = fe.digest();
        return re(Ie), w(R, ae, Ie), T(ae, j.subarray(32)), se(R, ae), de(d, R), !ne(j, d)
    }
    i.verify = we;

    function le(H) {
        let z = [o(), o(), o(), o()];
        if (oe(z, H)) throw new Error("Ed25519: invalid public key");
        let j = o(),
            d = o(),
            R = z[1];
        A(j, f, R), E(d, f, R), G(d, d), u(j, j, d);
        let ae = new Uint8Array(32);
        return K(ae, j), ae
    }
    i.convertPublicKeyToX25519 = le;

    function _e(H) {
        const z = (0, t.hash)(H.subarray(0, 32));
        z[0] &= 248, z[31] &= 127, z[31] |= 64;
        const j = new Uint8Array(z.subarray(0, 32));
        return (0, s.wipe)(z), j
    }
    i.convertSecretKeyToX25519 = _e
})(ku);
const z3 = "EdDSA",
    F3 = "JWT",
    yp = ".",
    vp = "base64url",
    H3 = "utf8",
    B3 = "utf8",
    K3 = ":",
    k3 = "did",
    V3 = "key",
    Vf = "base58btc",
    G3 = "z",
    W3 = "K36",
    Y3 = 32;

function Qo(i) {
    return hr(mr(on(i), H3), vp)
}

function _p(i) {
    const e = mr(W3, Vf),
        t = G3 + hr(su([e, i]), Vf);
    return [k3, V3, t].join(K3)
}

function J3(i) {
    return hr(i, vp)
}

function Q3(i) {
    return mr([Qo(i.header), Qo(i.payload)].join(yp), B3)
}

function X3(i) {
    return [Qo(i.header), Qo(i.payload), J3(i.signature)].join(yp)
}

function Gf(i = Os.randomBytes(Y3)) {
    return ku.generateKeyPairFromSeed(i)
}
async function Z3(i, e, t, s, o = ve.fromMiliseconds(Date.now())) {
    const c = {
            alg: z3,
            typ: F3
        },
        l = _p(s.publicKey),
        f = o + t,
        y = {
            iss: l,
            sub: i,
            aud: e,
            iat: o,
            exp: f
        },
        p = Q3({
            header: c,
            payload: y
        }),
        v = ku.sign(s.secretKey, p);
    return X3({
        header: c,
        payload: y,
        signature: v
    })
}
const eS = "PARSE_ERROR",
    tS = "INVALID_REQUEST",
    rS = "METHOD_NOT_FOUND",
    iS = "INVALID_PARAMS",
    mp = "INTERNAL_ERROR",
    Vu = "SERVER_ERROR",
    nS = [-32700, -32600, -32601, -32602, -32603],
    ms = {
        [eS]: {
            code: -32700,
            message: "Parse error"
        },
        [tS]: {
            code: -32600,
            message: "Invalid Request"
        },
        [rS]: {
            code: -32601,
            message: "Method not found"
        },
        [iS]: {
            code: -32602,
            message: "Invalid params"
        },
        [mp]: {
            code: -32603,
            message: "Internal error"
        },
        [Vu]: {
            code: -32e3,
            message: "Server error"
        }
    },
    bp = Vu;

function sS(i) {
    return nS.includes(i)
}

function Wf(i) {
    return Object.keys(ms).includes(i) ? ms[i] : ms[bp]
}

function oS(i) {
    const e = Object.values(ms).find(t => t.code === i);
    return e || ms[bp]
}

function wp(i, e, t) {
    return i.message.includes("getaddrinfo ENOTFOUND") || i.message.includes("connect ECONNREFUSED") ? new Error(`Unavailable ${t} RPC url at ${e}`) : i
}
var Ep = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var wu = function(i, e) {
    return wu = Object.setPrototypeOf || {
        __proto__: []
    }
    instanceof Array && function(t, s) {
        t.__proto__ = s
    } || function(t, s) {
        for (var o in s) s.hasOwnProperty(o) && (t[o] = s[o])
    }, wu(i, e)
};

function aS(i, e) {
    wu(i, e);

    function t() {
        this.constructor = i
    }
    i.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t)
}
var Eu = function() {
    return Eu = Object.assign || function(e) {
        for (var t, s = 1, o = arguments.length; s < o; s++) {
            t = arguments[s];
            for (var c in t) Object.prototype.hasOwnProperty.call(t, c) && (e[c] = t[c])
        }
        return e
    }, Eu.apply(this, arguments)
};

function cS(i, e) {
    var t = {};
    for (var s in i) Object.prototype.hasOwnProperty.call(i, s) && e.indexOf(s) < 0 && (t[s] = i[s]);
    if (i != null && typeof Object.getOwnPropertySymbols == "function")
        for (var o = 0, s = Object.getOwnPropertySymbols(i); o < s.length; o++) e.indexOf(s[o]) < 0 && Object.prototype.propertyIsEnumerable.call(i, s[o]) && (t[s[o]] = i[s[o]]);
    return t
}

function uS(i, e, t, s) {
    var o = arguments.length,
        c = o < 3 ? e : s === null ? s = Object.getOwnPropertyDescriptor(e, t) : s,
        l;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") c = Reflect.decorate(i, e, t, s);
    else
        for (var f = i.length - 1; f >= 0; f--)(l = i[f]) && (c = (o < 3 ? l(c) : o > 3 ? l(e, t, c) : l(e, t)) || c);
    return o > 3 && c && Object.defineProperty(e, t, c), c
}

function hS(i, e) {
    return function(t, s) {
        e(t, s, i)
    }
}

function lS(i, e) {
    if (typeof Reflect == "object" && typeof Reflect.metadata == "function") return Reflect.metadata(i, e)
}

function fS(i, e, t, s) {
    function o(c) {
        return c instanceof t ? c : new t(function(l) {
            l(c)
        })
    }
    return new(t || (t = Promise))(function(c, l) {
        function f(v) {
            try {
                p(s.next(v))
            } catch (D) {
                l(D)
            }
        }

        function y(v) {
            try {
                p(s.throw(v))
            } catch (D) {
                l(D)
            }
        }

        function p(v) {
            v.done ? c(v.value) : o(v.value).then(f, y)
        }
        p((s = s.apply(i, e || [])).next())
    })
}

function dS(i, e) {
    var t = {
            label: 0,
            sent: function() {
                if (c[0] & 1) throw c[1];
                return c[1]
            },
            trys: [],
            ops: []
        },
        s, o, c, l;
    return l = {
        next: f(0),
        throw: f(1),
        return: f(2)
    }, typeof Symbol == "function" && (l[Symbol.iterator] = function() {
        return this
    }), l;

    function f(p) {
        return function(v) {
            return y([p, v])
        }
    }

    function y(p) {
        if (s) throw new TypeError("Generator is already executing.");
        for (; t;) try {
            if (s = 1, o && (c = p[0] & 2 ? o.return : p[0] ? o.throw || ((c = o.return) && c.call(o), 0) : o.next) && !(c = c.call(o, p[1])).done) return c;
            switch (o = 0, c && (p = [p[0] & 2, c.value]), p[0]) {
                case 0:
                case 1:
                    c = p;
                    break;
                case 4:
                    return t.label++, {
                        value: p[1],
                        done: !1
                    };
                case 5:
                    t.label++, o = p[1], p = [0];
                    continue;
                case 7:
                    p = t.ops.pop(), t.trys.pop();
                    continue;
                default:
                    if (c = t.trys, !(c = c.length > 0 && c[c.length - 1]) && (p[0] === 6 || p[0] === 2)) {
                        t = 0;
                        continue
                    }
                    if (p[0] === 3 && (!c || p[1] > c[0] && p[1] < c[3])) {
                        t.label = p[1];
                        break
                    }
                    if (p[0] === 6 && t.label < c[1]) {
                        t.label = c[1], c = p;
                        break
                    }
                    if (c && t.label < c[2]) {
                        t.label = c[2], t.ops.push(p);
                        break
                    }
                    c[2] && t.ops.pop(), t.trys.pop();
                    continue
            }
            p = e.call(i, t)
        } catch (v) {
            p = [6, v], o = 0
        } finally {
            s = c = 0
        }
        if (p[0] & 5) throw p[1];
        return {
            value: p[0] ? p[1] : void 0,
            done: !0
        }
    }
}

function pS(i, e, t, s) {
    s === void 0 && (s = t), i[s] = e[t]
}

function gS(i, e) {
    for (var t in i) t !== "default" && !e.hasOwnProperty(t) && (e[t] = i[t])
}

function Du(i) {
    var e = typeof Symbol == "function" && Symbol.iterator,
        t = e && i[e],
        s = 0;
    if (t) return t.call(i);
    if (i && typeof i.length == "number") return {
        next: function() {
            return i && s >= i.length && (i = void 0), {
                value: i && i[s++],
                done: !i
            }
        }
    };
    throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.")
}

function Dp(i, e) {
    var t = typeof Symbol == "function" && i[Symbol.iterator];
    if (!t) return i;
    var s = t.call(i),
        o, c = [],
        l;
    try {
        for (;
            (e === void 0 || e-- > 0) && !(o = s.next()).done;) c.push(o.value)
    } catch (f) {
        l = {
            error: f
        }
    } finally {
        try {
            o && !o.done && (t = s.return) && t.call(s)
        } finally {
            if (l) throw l.error
        }
    }
    return c
}

function yS() {
    for (var i = [], e = 0; e < arguments.length; e++) i = i.concat(Dp(arguments[e]));
    return i
}

function vS() {
    for (var i = 0, e = 0, t = arguments.length; e < t; e++) i += arguments[e].length;
    for (var s = Array(i), o = 0, e = 0; e < t; e++)
        for (var c = arguments[e], l = 0, f = c.length; l < f; l++, o++) s[o] = c[l];
    return s
}

function xs(i) {
    return this instanceof xs ? (this.v = i, this) : new xs(i)
}

function _S(i, e, t) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var s = t.apply(i, e || []),
        o, c = [];
    return o = {}, l("next"), l("throw"), l("return"), o[Symbol.asyncIterator] = function() {
        return this
    }, o;

    function l(S) {
        s[S] && (o[S] = function(x) {
            return new Promise(function(O, F) {
                c.push([S, x, O, F]) > 1 || f(S, x)
            })
        })
    }

    function f(S, x) {
        try {
            y(s[S](x))
        } catch (O) {
            D(c[0][3], O)
        }
    }

    function y(S) {
        S.value instanceof xs ? Promise.resolve(S.value.v).then(p, v) : D(c[0][2], S)
    }

    function p(S) {
        f("next", S)
    }

    function v(S) {
        f("throw", S)
    }

    function D(S, x) {
        S(x), c.shift(), c.length && f(c[0][0], c[0][1])
    }
}

function mS(i) {
    var e, t;
    return e = {}, s("next"), s("throw", function(o) {
        throw o
    }), s("return"), e[Symbol.iterator] = function() {
        return this
    }, e;

    function s(o, c) {
        e[o] = i[o] ? function(l) {
            return (t = !t) ? {
                value: xs(i[o](l)),
                done: o === "return"
            } : c ? c(l) : l
        } : c
    }
}

function bS(i) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var e = i[Symbol.asyncIterator],
        t;
    return e ? e.call(i) : (i = typeof Du == "function" ? Du(i) : i[Symbol.iterator](), t = {}, s("next"), s("throw"), s("return"), t[Symbol.asyncIterator] = function() {
        return this
    }, t);

    function s(c) {
        t[c] = i[c] && function(l) {
            return new Promise(function(f, y) {
                l = i[c](l), o(f, y, l.done, l.value)
            })
        }
    }

    function o(c, l, f, y) {
        Promise.resolve(y).then(function(p) {
            c({
                value: p,
                done: f
            })
        }, l)
    }
}

function wS(i, e) {
    return Object.defineProperty ? Object.defineProperty(i, "raw", {
        value: e
    }) : i.raw = e, i
}

function ES(i) {
    if (i && i.__esModule) return i;
    var e = {};
    if (i != null)
        for (var t in i) Object.hasOwnProperty.call(i, t) && (e[t] = i[t]);
    return e.default = i, e
}

function DS(i) {
    return i && i.__esModule ? i : {
        default: i
    }
}

function SS(i, e) {
    if (!e.has(i)) throw new TypeError("attempted to get private field on non-instance");
    return e.get(i)
}

function IS(i, e, t) {
    if (!e.has(i)) throw new TypeError("attempted to set private field on non-instance");
    return e.set(i, t), t
}
const xS = Object.freeze(Object.defineProperty({
        __proto__: null,
        get __assign() {
            return Eu
        },
        __asyncDelegator: mS,
        __asyncGenerator: _S,
        __asyncValues: bS,
        __await: xs,
        __awaiter: fS,
        __classPrivateFieldGet: SS,
        __classPrivateFieldSet: IS,
        __createBinding: pS,
        __decorate: uS,
        __exportStar: gS,
        __extends: aS,
        __generator: dS,
        __importDefault: DS,
        __importStar: ES,
        __makeTemplateObject: wS,
        __metadata: lS,
        __param: hS,
        __read: Dp,
        __rest: cS,
        __spread: yS,
        __spreadArrays: vS,
        __values: Du
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    OS = Un(xS);
var gi = {},
    Yf;

function PS() {
    if (Yf) return gi;
    Yf = 1, Object.defineProperty(gi, "__esModule", {
        value: !0
    }), gi.isBrowserCryptoAvailable = gi.getSubtleCrypto = gi.getBrowerCrypto = void 0;

    function i() {
        return (Gr === null || Gr === void 0 ? void 0 : Gr.crypto) || (Gr === null || Gr === void 0 ? void 0 : Gr.msCrypto) || {}
    }
    gi.getBrowerCrypto = i;

    function e() {
        const s = i();
        return s.subtle || s.webkitSubtle
    }
    gi.getSubtleCrypto = e;

    function t() {
        return !!i() && !!e()
    }
    return gi.isBrowserCryptoAvailable = t, gi
}
var yi = {},
    Jf;

function CS() {
    if (Jf) return yi;
    Jf = 1, Object.defineProperty(yi, "__esModule", {
        value: !0
    }), yi.isBrowser = yi.isNode = yi.isReactNative = void 0;

    function i() {
        return typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative"
    }
    yi.isReactNative = i;

    function e() {
        return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u"
    }
    yi.isNode = e;

    function t() {
        return !i() && !e()
    }
    return yi.isBrowser = t, yi
}(function(i) {
    Object.defineProperty(i, "__esModule", {
        value: !0
    });
    const e = OS;
    e.__exportStar(PS(), i), e.__exportStar(CS(), i)
})(Ep);

function Gu(i = 3) {
    const e = Date.now() * Math.pow(10, i),
        t = Math.floor(Math.random() * Math.pow(10, i));
    return e + t
}

function Sp(i = 6) {
    return BigInt(Gu(i))
}

function Mn(i, e, t) {
    return {
        id: t || Gu(),
        jsonrpc: "2.0",
        method: i,
        params: e
    }
}

function oa(i, e) {
    return {
        id: i,
        jsonrpc: "2.0",
        result: e
    }
}

function aa(i, e, t) {
    return {
        id: i,
        jsonrpc: "2.0",
        error: TS(e, t)
    }
}

function TS(i, e) {
    return typeof i > "u" ? Wf(mp) : (typeof i == "string" && (i = Object.assign(Object.assign({}, Wf(Vu)), {
        message: i
    })), typeof e < "u" && (i.data = e), sS(i.code) && (i = oS(i.code)), i)
}
class AS {}
class RS extends AS {
    constructor() {
        super()
    }
}
class NS extends RS {
    constructor(e) {
        super()
    }
}
const $S = "^https?:",
    jS = "^wss?:";

function LS(i) {
    const e = i.match(new RegExp(/^\w+:/, "gi"));
    if (!(!e || !e.length)) return e[0]
}

function Ip(i, e) {
    const t = LS(i);
    return typeof t > "u" ? !1 : new RegExp(e).test(t)
}

function Qf(i) {
    return Ip(i, $S)
}

function Xf(i) {
    return Ip(i, jS)
}

function MS(i) {
    return new RegExp("wss?://localhost(:d{2,5})?").test(i)
}

function xp(i) {
    return typeof i == "object" && "id" in i && "jsonrpc" in i && i.jsonrpc === "2.0"
}

function Wu(i) {
    return xp(i) && "method" in i
}

function ca(i) {
    return xp(i) && (bi(i) || Vr(i))
}

function bi(i) {
    return "result" in i
}

function Vr(i) {
    return "error" in i
}
class Ei extends NS {
    constructor(e) {
        super(e), this.events = new Ur.EventEmitter, this.hasRegisteredEventListeners = !1, this.connection = this.setConnection(e), this.connection.connected && this.registerEventListeners()
    }
    async connect(e = this.connection) {
        await this.open(e)
    }
    async disconnect() {
        await this.close()
    }
    on(e, t) {
        this.events.on(e, t)
    }
    once(e, t) {
        this.events.once(e, t)
    }
    off(e, t) {
        this.events.off(e, t)
    }
    removeListener(e, t) {
        this.events.removeListener(e, t)
    }
    async request(e, t) {
        return this.requestStrict(Mn(e.method, e.params || [], e.id || Sp().toString()), t)
    }
    async requestStrict(e, t) {
        return new Promise(async (s, o) => {
            if (!this.connection.connected) try {
                await this.open()
            } catch (c) {
                o(c)
            }
            this.events.on(`${e.id}`, c => {
                Vr(c) ? o(c.error) : s(c.result)
            });
            try {
                await this.connection.send(e, t)
            } catch (c) {
                o(c)
            }
        })
    }
    setConnection(e = this.connection) {
        return e
    }
    onPayload(e) {
        this.events.emit("payload", e), ca(e) ? this.events.emit(`${e.id}`, e) : this.events.emit("message", {
            type: e.method,
            data: e.params
        })
    }
    onClose(e) {
        e && e.code === 3e3 && this.events.emit("error", new Error(`WebSocket connection closed abnormally with code: ${e.code} ${e.reason?`(${e.reason})`:""}`)), this.events.emit("disconnect")
    }
    async open(e = this.connection) {
        this.connection === e && this.connection.connected || (this.connection.connected && this.close(), typeof e == "string" && (await this.connection.open(e), e = this.connection), this.connection = this.setConnection(e), await this.connection.open(), this.registerEventListeners(), this.events.emit("connect"))
    }
    async close() {
        await this.connection.close()
    }
    registerEventListeners() {
        this.hasRegisteredEventListeners || (this.connection.on("payload", e => this.onPayload(e)), this.connection.on("close", e => this.onClose(e)), this.connection.on("error", e => this.events.emit("error", e)), this.connection.on("register_error", e => this.onClose()), this.hasRegisteredEventListeners = !0)
    }
}
const US = () => typeof WebSocket < "u" ? WebSocket : typeof global < "u" && typeof globalThis.WebSocket < "u" ? global.WebSocket : typeof window < "u" && typeof window.WebSocket < "u" ? window.WebSocket : typeof self < "u" && typeof self.WebSocket < "u" ? self.WebSocket : require("ws"),
    qS = () => typeof WebSocket < "u" || typeof global < "u" && typeof globalThis.WebSocket < "u" || typeof window < "u" && typeof window.WebSocket < "u" || typeof self < "u" && typeof self.WebSocket < "u",
    Zf = i => i.split("?")[0],
    ed = 10,
    zS = US();
let FS = class {
    constructor(e) {
        if (this.url = e, this.events = new Ur.EventEmitter, this.registering = !1, !Xf(e)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
        this.url = e
    }
    get connected() {
        return typeof this.socket < "u"
    }
    get connecting() {
        return this.registering
    }
    on(e, t) {
        this.events.on(e, t)
    }
    once(e, t) {
        this.events.once(e, t)
    }
    off(e, t) {
        this.events.off(e, t)
    }
    removeListener(e, t) {
        this.events.removeListener(e, t)
    }
    async open(e = this.url) {
        await this.register(e)
    }
    async close() {
        return new Promise((e, t) => {
            if (typeof this.socket > "u") {
                t(new Error("Connection already closed"));
                return
            }
            this.socket.onclose = s => {
                this.onClose(s), e()
            }, this.socket.close()
        })
    }
    async send(e) {
        typeof this.socket > "u" && (this.socket = await this.register());
        try {
            this.socket.send(on(e))
        } catch (t) {
            this.onError(e.id, t)
        }
    }
    register(e = this.url) {
        if (!Xf(e)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
        if (this.registering) {
            const t = this.events.getMaxListeners();
            return (this.events.listenerCount("register_error") >= t || this.events.listenerCount("open") >= t) && this.events.setMaxListeners(t + 1), new Promise((s, o) => {
                this.events.once("register_error", c => {
                    this.resetMaxListeners(), o(c)
                }), this.events.once("open", () => {
                    if (this.resetMaxListeners(), typeof this.socket > "u") return o(new Error("WebSocket connection is missing or invalid"));
                    s(this.socket)
                })
            })
        }
        return this.url = e, this.registering = !0, new Promise((t, s) => {
            const o = new URLSearchParams(e).get("origin"),
                c = Ep.isReactNative() ? {
                    headers: {
                        origin: o
                    }
                } : {
                    rejectUnauthorized: !MS(e)
                },
                l = new zS(e, [], c);
            qS() ? l.onerror = f => {
                const y = f;
                s(this.emitError(y.error))
            } : l.on("error", f => {
                s(this.emitError(f))
            }), l.onopen = () => {
                this.onOpen(l), t(l)
            }
        })
    }
    onOpen(e) {
        e.onmessage = t => this.onPayload(t), e.onclose = t => this.onClose(t), this.socket = e, this.registering = !1, this.events.emit("open")
    }
    onClose(e) {
        this.socket = void 0, this.registering = !1, this.events.emit("close", e)
    }
    onPayload(e) {
        if (typeof e.data > "u") return;
        const t = typeof e.data == "string" ? Ns(e.data) : e.data;
        this.events.emit("payload", t)
    }
    onError(e, t) {
        const s = this.parseError(t),
            o = s.message || s.toString(),
            c = aa(e, o);
        this.events.emit("payload", c)
    }
    parseError(e, t = this.url) {
        return wp(e, Zf(t), "WS")
    }
    resetMaxListeners() {
        this.events.getMaxListeners() > ed && this.events.setMaxListeners(ed)
    }
    emitError(e) {
        const t = this.parseError(new Error((e == null ? void 0 : e.message) || `WebSocket connection failed for host: ${Zf(this.url)}`));
        return this.events.emit("register_error", t), t
    }
};
var Xo = {
    exports: {}
};
Xo.exports;
(function(i, e) {
    var t = 200,
        s = "__lodash_hash_undefined__",
        o = 1,
        c = 2,
        l = 9007199254740991,
        f = "[object Arguments]",
        y = "[object Array]",
        p = "[object AsyncFunction]",
        v = "[object Boolean]",
        D = "[object Date]",
        S = "[object Error]",
        x = "[object Function]",
        O = "[object GeneratorFunction]",
        F = "[object Map]",
        K = "[object Number]",
        ne = "[object Null]",
        $ = "[object Object]",
        U = "[object Promise]",
        C = "[object Proxy]",
        A = "[object RegExp]",
        E = "[object Set]",
        u = "[object String]",
        b = "[object Symbol]",
        G = "[object Undefined]",
        W = "[object WeakMap]",
        se = "[object ArrayBuffer]",
        ue = "[object DataView]",
        de = "[object Float32Array]",
        w = "[object Float64Array]",
        T = "[object Int8Array]",
        ee = "[object Int16Array]",
        Q = "[object Int32Array]",
        k = "[object Uint8Array]",
        V = "[object Uint8ClampedArray]",
        J = "[object Uint16Array]",
        re = "[object Uint32Array]",
        be = /[\\^$.*+?()[\]{}|]/g,
        oe = /^\[object .+?Constructor\]$/,
        we = /^(?:0|[1-9]\d*)$/,
        le = {};
    le[de] = le[w] = le[T] = le[ee] = le[Q] = le[k] = le[V] = le[J] = le[re] = !0, le[f] = le[y] = le[se] = le[v] = le[ue] = le[D] = le[S] = le[x] = le[F] = le[K] = le[$] = le[A] = le[E] = le[u] = le[W] = !1;
    var _e = typeof Gr == "object" && Gr && Gr.Object === Object && Gr,
        H = typeof self == "object" && self && self.Object === Object && self,
        z = _e || H || Function("return this")(),
        j = e && !e.nodeType && e,
        d = j && !0 && i && !i.nodeType && i,
        R = d && d.exports === j,
        ae = R && _e.process,
        fe = function() {
            try {
                return ae && ae.binding && ae.binding("util")
            } catch {}
        }(),
        Ie = fe && fe.isTypedArray;

    function Fe(I, L) {
        for (var te = -1, pe = I == null ? 0 : I.length, ot = 0, Ae = []; ++te < pe;) {
            var lt = I[te];
            L(lt, te, I) && (Ae[ot++] = lt)
        }
        return Ae
    }

    function Ke(I, L) {
        for (var te = -1, pe = L.length, ot = I.length; ++te < pe;) I[ot + te] = L[te];
        return I
    }

    function Le(I, L) {
        for (var te = -1, pe = I == null ? 0 : I.length; ++te < pe;)
            if (L(I[te], te, I)) return !0;
        return !1
    }

    function dt(I, L) {
        for (var te = -1, pe = Array(I); ++te < I;) pe[te] = L(te);
        return pe
    }

    function pt(I) {
        return function(L) {
            return I(L)
        }
    }

    function Ue(I, L) {
        return I.has(L)
    }

    function xe(I, L) {
        return I == null ? void 0 : I[L]
    }

    function Ne(I) {
        var L = -1,
            te = Array(I.size);
        return I.forEach(function(pe, ot) {
            te[++L] = [ot, pe]
        }), te
    }

    function $e(I, L) {
        return function(te) {
            return I(L(te))
        }
    }

    function qe(I) {
        var L = -1,
            te = Array(I.size);
        return I.forEach(function(pe) {
            te[++L] = pe
        }), te
    }
    var Pe = Array.prototype,
        je = Function.prototype,
        Se = Object.prototype,
        Ce = z["__core-js_shared__"],
        He = je.toString,
        Oe = Se.hasOwnProperty,
        ke = function() {
            var I = /[^.]+$/.exec(Ce && Ce.keys && Ce.keys.IE_PROTO || "");
            return I ? "Symbol(src)_1." + I : ""
        }(),
        Ge = Se.toString,
        Ze = RegExp("^" + He.call(Oe).replace(be, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
        et = R ? z.Buffer : void 0,
        Je = z.Symbol,
        er = z.Uint8Array,
        lr = Se.propertyIsEnumerable,
        Wr = Pe.splice,
        tr = Je ? Je.toStringTag : void 0,
        ii = Object.getOwnPropertySymbols,
        Si = et ? et.isBuffer : void 0,
        zi = $e(Object.keys, Object),
        Et = br(z, "DataView"),
        gt = br(z, "Map"),
        Dt = br(z, "Promise"),
        St = br(z, "Set"),
        bt = br(z, "WeakMap"),
        yt = br(Object, "create"),
        $t = si(Et),
        jt = si(gt),
        It = si(Dt),
        Lt = si(St),
        xt = si(bt),
        Ct = Je ? Je.prototype : void 0,
        Ot = Ct ? Ct.valueOf : void 0;

    function ut(I) {
        var L = -1,
            te = I == null ? 0 : I.length;
        for (this.clear(); ++L < te;) {
            var pe = I[L];
            this.set(pe[0], pe[1])
        }
    }

    function Mt() {
        this.__data__ = yt ? yt(null) : {}, this.size = 0
    }

    function Ut(I) {
        var L = this.has(I) && delete this.__data__[I];
        return this.size -= L ? 1 : 0, L
    }

    function la(I) {
        var L = this.__data__;
        if (yt) {
            var te = L[I];
            return te === s ? void 0 : te
        }
        return Oe.call(L, I) ? L[I] : void 0
    }

    function fa(I) {
        var L = this.__data__;
        return yt ? L[I] !== void 0 : Oe.call(L, I)
    }

    function da(I, L) {
        var te = this.__data__;
        return this.size += this.has(I) ? 0 : 1, te[I] = yt && L === void 0 ? s : L, this
    }
    ut.prototype.clear = Mt, ut.prototype.delete = Ut, ut.prototype.get = la, ut.prototype.has = fa, ut.prototype.set = da;

    function Pr(I) {
        var L = -1,
            te = I == null ? 0 : I.length;
        for (this.clear(); ++L < te;) {
            var pe = I[L];
            this.set(pe[0], pe[1])
        }
    }

    function pa() {
        this.__data__ = [], this.size = 0
    }

    function ga(I) {
        var L = this.__data__,
            te = Fi(L, I);
        if (te < 0) return !1;
        var pe = L.length - 1;
        return te == pe ? L.pop() : Wr.call(L, te, 1), --this.size, !0
    }

    function ya(I) {
        var L = this.__data__,
            te = Fi(L, I);
        return te < 0 ? void 0 : L[te][1]
    }

    function va(I) {
        return Fi(this.__data__, I) > -1
    }

    function _a(I, L) {
        var te = this.__data__,
            pe = Fi(te, I);
        return pe < 0 ? (++this.size, te.push([I, L])) : te[pe][1] = L, this
    }
    Pr.prototype.clear = pa, Pr.prototype.delete = ga, Pr.prototype.get = ya, Pr.prototype.has = va, Pr.prototype.set = _a;

    function ni(I) {
        var L = -1,
            te = I == null ? 0 : I.length;
        for (this.clear(); ++L < te;) {
            var pe = I[L];
            this.set(pe[0], pe[1])
        }
    }

    function fn() {
        this.size = 0, this.__data__ = {
            hash: new ut,
            map: new(gt || Pr),
            string: new ut
        }
    }

    function ma(I) {
        var L = Ii(this, I).delete(I);
        return this.size -= L ? 1 : 0, L
    }

    function dn(I) {
        return Ii(this, I).get(I)
    }

    function ba(I) {
        return Ii(this, I).has(I)
    }

    function wa(I, L) {
        var te = Ii(this, I),
            pe = te.size;
        return te.set(I, L), this.size += te.size == pe ? 0 : 1, this
    }
    ni.prototype.clear = fn, ni.prototype.delete = ma, ni.prototype.get = dn, ni.prototype.has = ba, ni.prototype.set = wa;

    function pn(I) {
        var L = -1,
            te = I == null ? 0 : I.length;
        for (this.__data__ = new ni; ++L < te;) this.add(I[L])
    }

    function js(I) {
        return this.__data__.set(I, s), this
    }

    function Ls(I) {
        return this.__data__.has(I)
    }
    pn.prototype.add = pn.prototype.push = js, pn.prototype.has = Ls;

    function qr(I) {
        var L = this.__data__ = new Pr(I);
        this.size = L.size
    }

    function Ea() {
        this.__data__ = new Pr, this.size = 0
    }

    function Da(I) {
        var L = this.__data__,
            te = L.delete(I);
        return this.size = L.size, te
    }

    function Sa(I) {
        return this.__data__.get(I)
    }

    function Ia(I) {
        return this.__data__.has(I)
    }

    function Ms(I, L) {
        var te = this.__data__;
        if (te instanceof Pr) {
            var pe = te.__data__;
            if (!gt || pe.length < t - 1) return pe.push([I, L]), this.size = ++te.size, this;
            te = this.__data__ = new ni(pe)
        }
        return te.set(I, L), this.size = te.size, this
    }
    qr.prototype.clear = Ea, qr.prototype.delete = Da, qr.prototype.get = Sa, qr.prototype.has = Ia, qr.prototype.set = Ms;

    function Us(I, L) {
        var te = vn(I),
            pe = !te && Js(I),
            ot = !te && !pe && Vn(I),
            Ae = !te && !pe && !ot && Zs(I),
            lt = te || pe || ot || Ae,
            qt = lt ? dt(I.length, String) : [],
            Qe = qt.length;
        for (var at in I)(L || Oe.call(I, at)) && !(lt && (at == "length" || ot && (at == "offset" || at == "parent") || Ae && (at == "buffer" || at == "byteLength" || at == "byteOffset") || ks(at, Qe))) && qt.push(at);
        return qt
    }

    function Fi(I, L) {
        for (var te = I.length; te--;)
            if (Ys(I[te][0], L)) return te;
        return -1
    }

    function Kn(I, L, te) {
        var pe = L(I);
        return vn(I) ? pe : Ke(pe, te(I))
    }

    function Hi(I) {
        return I == null ? I === void 0 ? G : ne : tr && tr in Object(I) ? Bs(I) : Pa(I)
    }

    function kn(I) {
        return Ki(I) && Hi(I) == f
    }

    function Bi(I, L, te, pe, ot) {
        return I === L ? !0 : I == null || L == null || !Ki(I) && !Ki(L) ? I !== I && L !== L : qs(I, L, te, pe, Bi, ot)
    }

    function qs(I, L, te, pe, ot, Ae) {
        var lt = vn(I),
            qt = vn(L),
            Qe = lt ? y : Yr(I),
            at = qt ? y : Yr(L);
        Qe = Qe == f ? $ : Qe, at = at == f ? $ : at;
        var Tt = Qe == $,
            fr = at == $,
            zt = Qe == at;
        if (zt && Vn(I)) {
            if (!Vn(L)) return !1;
            lt = !0, Tt = !1
        }
        if (zt && !Tt) return Ae || (Ae = new qr), lt || Zs(I) ? gn(I, L, te, pe, ot, Ae) : Oa(I, L, Qe, te, pe, ot, Ae);
        if (!(te & o)) {
            var ft = Tt && Oe.call(I, "__wrapped__"),
                rr = fr && Oe.call(L, "__wrapped__");
            if (ft || rr) {
                var zr = ft ? I.value() : I,
                    Cr = rr ? L.value() : L;
                return Ae || (Ae = new qr), ot(zr, Cr, te, pe, Ae)
            }
        }
        return zt ? (Ae || (Ae = new qr), Hs(I, L, te, pe, ot, Ae)) : !1
    }

    function xa(I) {
        if (!Xs(I) || Gs(I)) return !1;
        var L = _n(I) ? Ze : oe;
        return L.test(si(I))
    }

    function zs(I) {
        return Ki(I) && Qs(I.length) && !!le[Hi(I)]
    }

    function Fs(I) {
        if (!Ws(I)) return zi(I);
        var L = [];
        for (var te in Object(I)) Oe.call(I, te) && te != "constructor" && L.push(te);
        return L
    }

    function gn(I, L, te, pe, ot, Ae) {
        var lt = te & o,
            qt = I.length,
            Qe = L.length;
        if (qt != Qe && !(lt && Qe > qt)) return !1;
        var at = Ae.get(I);
        if (at && Ae.get(L)) return at == L;
        var Tt = -1,
            fr = !0,
            zt = te & c ? new pn : void 0;
        for (Ae.set(I, L), Ae.set(L, I); ++Tt < qt;) {
            var ft = I[Tt],
                rr = L[Tt];
            if (pe) var zr = lt ? pe(rr, ft, Tt, L, I, Ae) : pe(ft, rr, Tt, I, L, Ae);
            if (zr !== void 0) {
                if (zr) continue;
                fr = !1;
                break
            }
            if (zt) {
                if (!Le(L, function(Cr, Jr) {
                        if (!Ue(zt, Jr) && (ft === Cr || ot(ft, Cr, te, pe, Ae))) return zt.push(Jr)
                    })) {
                    fr = !1;
                    break
                }
            } else if (!(ft === rr || ot(ft, rr, te, pe, Ae))) {
                fr = !1;
                break
            }
        }
        return Ae.delete(I), Ae.delete(L), fr
    }

    function Oa(I, L, te, pe, ot, Ae, lt) {
        switch (te) {
            case ue:
                if (I.byteLength != L.byteLength || I.byteOffset != L.byteOffset) return !1;
                I = I.buffer, L = L.buffer;
            case se:
                return !(I.byteLength != L.byteLength || !Ae(new er(I), new er(L)));
            case v:
            case D:
            case K:
                return Ys(+I, +L);
            case S:
                return I.name == L.name && I.message == L.message;
            case A:
            case u:
                return I == L + "";
            case F:
                var qt = Ne;
            case E:
                var Qe = pe & o;
                if (qt || (qt = qe), I.size != L.size && !Qe) return !1;
                var at = lt.get(I);
                if (at) return at == L;
                pe |= c, lt.set(I, L);
                var Tt = gn(qt(I), qt(L), pe, ot, Ae, lt);
                return lt.delete(I), Tt;
            case b:
                if (Ot) return Ot.call(I) == Ot.call(L)
        }
        return !1
    }

    function Hs(I, L, te, pe, ot, Ae) {
        var lt = te & o,
            qt = yn(I),
            Qe = qt.length,
            at = yn(L),
            Tt = at.length;
        if (Qe != Tt && !lt) return !1;
        for (var fr = Qe; fr--;) {
            var zt = qt[fr];
            if (!(lt ? zt in L : Oe.call(L, zt))) return !1
        }
        var ft = Ae.get(I);
        if (ft && Ae.get(L)) return ft == L;
        var rr = !0;
        Ae.set(I, L), Ae.set(L, I);
        for (var zr = lt; ++fr < Qe;) {
            zt = qt[fr];
            var Cr = I[zt],
                Jr = L[zt];
            if (pe) var Gn = lt ? pe(Jr, Cr, zt, L, I, Ae) : pe(Cr, Jr, zt, I, L, Ae);
            if (!(Gn === void 0 ? Cr === Jr || ot(Cr, Jr, te, pe, Ae) : Gn)) {
                rr = !1;
                break
            }
            zr || (zr = zt == "constructor")
        }
        if (rr && !zr) {
            var ki = I.constructor,
                Bt = L.constructor;
            ki != Bt && "constructor" in I && "constructor" in L && !(typeof ki == "function" && ki instanceof ki && typeof Bt == "function" && Bt instanceof Bt) && (rr = !1)
        }
        return Ae.delete(I), Ae.delete(L), rr
    }

    function yn(I) {
        return Kn(I, Aa, Ks)
    }

    function Ii(I, L) {
        var te = I.__data__;
        return Vs(L) ? te[typeof L == "string" ? "string" : "hash"] : te.map
    }

    function br(I, L) {
        var te = xe(I, L);
        return xa(te) ? te : void 0
    }

    function Bs(I) {
        var L = Oe.call(I, tr),
            te = I[tr];
        try {
            I[tr] = void 0;
            var pe = !0
        } catch {}
        var ot = Ge.call(I);
        return pe && (L ? I[tr] = te : delete I[tr]), ot
    }
    var Ks = ii ? function(I) {
            return I == null ? [] : (I = Object(I), Fe(ii(I), function(L) {
                return lr.call(I, L)
            }))
        } : st,
        Yr = Hi;
    (Et && Yr(new Et(new ArrayBuffer(1))) != ue || gt && Yr(new gt) != F || Dt && Yr(Dt.resolve()) != U || St && Yr(new St) != E || bt && Yr(new bt) != W) && (Yr = function(I) {
        var L = Hi(I),
            te = L == $ ? I.constructor : void 0,
            pe = te ? si(te) : "";
        if (pe) switch (pe) {
            case $t:
                return ue;
            case jt:
                return F;
            case It:
                return U;
            case Lt:
                return E;
            case xt:
                return W
        }
        return L
    });

    function ks(I, L) {
        return L = L ? ? l, !!L && (typeof I == "number" || we.test(I)) && I > -1 && I % 1 == 0 && I < L
    }

    function Vs(I) {
        var L = typeof I;
        return L == "string" || L == "number" || L == "symbol" || L == "boolean" ? I !== "__proto__" : I === null
    }

    function Gs(I) {
        return !!ke && ke in I
    }

    function Ws(I) {
        var L = I && I.constructor,
            te = typeof L == "function" && L.prototype || Se;
        return I === te
    }

    function Pa(I) {
        return Ge.call(I)
    }

    function si(I) {
        if (I != null) {
            try {
                return He.call(I)
            } catch {}
            try {
                return I + ""
            } catch {}
        }
        return ""
    }

    function Ys(I, L) {
        return I === L || I !== I && L !== L
    }
    var Js = kn(function() {
            return arguments
        }()) ? kn : function(I) {
            return Ki(I) && Oe.call(I, "callee") && !lr.call(I, "callee")
        },
        vn = Array.isArray;

    function Ca(I) {
        return I != null && Qs(I.length) && !_n(I)
    }
    var Vn = Si || nt;

    function Ta(I, L) {
        return Bi(I, L)
    }

    function _n(I) {
        if (!Xs(I)) return !1;
        var L = Hi(I);
        return L == x || L == O || L == p || L == C
    }

    function Qs(I) {
        return typeof I == "number" && I > -1 && I % 1 == 0 && I <= l
    }

    function Xs(I) {
        var L = typeof I;
        return I != null && (L == "object" || L == "function")
    }

    function Ki(I) {
        return I != null && typeof I == "object"
    }
    var Zs = Ie ? pt(Ie) : zs;

    function Aa(I) {
        return Ca(I) ? Us(I) : Fs(I)
    }

    function st() {
        return []
    }

    function nt() {
        return !1
    }
    i.exports = Ta
})(Xo, Xo.exports);
var HS = Xo.exports;
const BS = Au(HS);

function KS(i, e) {
    return e = e || {}, new Promise(function(t, s) {
        var o = new XMLHttpRequest,
            c = [],
            l = [],
            f = {},
            y = function() {
                return {
                    ok: (o.status / 100 | 0) == 2,
                    statusText: o.statusText,
                    status: o.status,
                    url: o.responseURL,
                    text: function() {
                        return Promise.resolve(o.responseText)
                    },
                    json: function() {
                        return Promise.resolve(o.responseText).then(JSON.parse)
                    },
                    blob: function() {
                        return Promise.resolve(new Blob([o.response]))
                    },
                    clone: y,
                    headers: {
                        keys: function() {
                            return c
                        },
                        entries: function() {
                            return l
                        },
                        get: function(v) {
                            return f[v.toLowerCase()]
                        },
                        has: function(v) {
                            return v.toLowerCase() in f
                        }
                    }
                }
            };
        for (var p in o.open(e.method || "get", i, !0), o.onload = function() {
                o.getAllResponseHeaders().replace(/^(.*?):[^\S\n]*([\s\S]*?)$/gm, function(v, D, S) {
                    c.push(D = D.toLowerCase()), l.push([D, S]), f[D] = f[D] ? f[D] + "," + S : S
                }), t(y())
            }, o.onerror = s, o.withCredentials = e.credentials == "include", e.headers) o.setRequestHeader(p, e.headers[p]);
        o.send(e.body || null)
    })
}
const kS = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: KS
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    td = Un(kS);
var VS = self.fetch || (self.fetch = td.default || td);
const GS = Au(VS);
var WS = {};

function YS(i, e) {
    if (i.length >= 255) throw new TypeError("Alphabet too long");
    for (var t = new Uint8Array(256), s = 0; s < t.length; s++) t[s] = 255;
    for (var o = 0; o < i.length; o++) {
        var c = i.charAt(o),
            l = c.charCodeAt(0);
        if (t[l] !== 255) throw new TypeError(c + " is ambiguous");
        t[l] = o
    }
    var f = i.length,
        y = i.charAt(0),
        p = Math.log(f) / Math.log(256),
        v = Math.log(256) / Math.log(f);

    function D(O) {
        if (O instanceof Uint8Array || (ArrayBuffer.isView(O) ? O = new Uint8Array(O.buffer, O.byteOffset, O.byteLength) : Array.isArray(O) && (O = Uint8Array.from(O))), !(O instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
        if (O.length === 0) return "";
        for (var F = 0, K = 0, ne = 0, $ = O.length; ne !== $ && O[ne] === 0;) ne++, F++;
        for (var U = ($ - ne) * v + 1 >>> 0, C = new Uint8Array(U); ne !== $;) {
            for (var A = O[ne], E = 0, u = U - 1;
                (A !== 0 || E < K) && u !== -1; u--, E++) A += 256 * C[u] >>> 0, C[u] = A % f >>> 0, A = A / f >>> 0;
            if (A !== 0) throw new Error("Non-zero carry");
            K = E, ne++
        }
        for (var b = U - K; b !== U && C[b] === 0;) b++;
        for (var G = y.repeat(F); b < U; ++b) G += i.charAt(C[b]);
        return G
    }

    function S(O) {
        if (typeof O != "string") throw new TypeError("Expected String");
        if (O.length === 0) return new Uint8Array;
        var F = 0;
        if (O[F] !== " ") {
            for (var K = 0, ne = 0; O[F] === y;) K++, F++;
            for (var $ = (O.length - F) * p + 1 >>> 0, U = new Uint8Array($); O[F];) {
                var C = t[O.charCodeAt(F)];
                if (C === 255) return;
                for (var A = 0, E = $ - 1;
                    (C !== 0 || A < ne) && E !== -1; E--, A++) C += f * U[E] >>> 0, U[E] = C % 256 >>> 0, C = C / 256 >>> 0;
                if (C !== 0) throw new Error("Non-zero carry");
                ne = A, F++
            }
            if (O[F] !== " ") {
                for (var u = $ - ne; u !== $ && U[u] === 0;) u++;
                for (var b = new Uint8Array(K + ($ - u)), G = K; u !== $;) b[G++] = U[u++];
                return b
            }
        }
    }

    function x(O) {
        var F = S(O);
        if (F) return F;
        throw new Error(`Non-${e} character`)
    }
    return {
        encode: D,
        decodeUnsafe: S,
        decode: x
    }
}
var JS = YS,
    QS = JS;
const Op = i => {
        if (i instanceof Uint8Array && i.constructor.name === "Uint8Array") return i;
        if (i instanceof ArrayBuffer) return new Uint8Array(i);
        if (ArrayBuffer.isView(i)) return new Uint8Array(i.buffer, i.byteOffset, i.byteLength);
        throw new Error("Unknown type, must be binary type")
    },
    XS = i => new TextEncoder().encode(i),
    ZS = i => new TextDecoder().decode(i);
class eI {
    constructor(e, t, s) {
        this.name = e, this.prefix = t, this.baseEncode = s
    }
    encode(e) {
        if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;
        throw Error("Unknown type, must be binary type")
    }
}
class tI {
    constructor(e, t, s) {
        if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
        this.prefixCodePoint = t.codePointAt(0), this.baseDecode = s
    }
    decode(e) {
        if (typeof e == "string") {
            if (e.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
            return this.baseDecode(e.slice(this.prefix.length))
        } else throw Error("Can only multibase decode strings")
    }
    or(e) {
        return Pp(this, e)
    }
}
class rI {
    constructor(e) {
        this.decoders = e
    }
    or(e) {
        return Pp(this, e)
    }
    decode(e) {
        const t = e[0],
            s = this.decoders[t];
        if (s) return s.decode(e);
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)
    }
}
const Pp = (i, e) => new rI({ ...i.decoders || {
        [i.prefix]: i
    },
    ...e.decoders || {
        [e.prefix]: e
    }
});
class iI {
    constructor(e, t, s, o) {
        this.name = e, this.prefix = t, this.baseEncode = s, this.baseDecode = o, this.encoder = new eI(e, t, s), this.decoder = new tI(e, t, o)
    }
    encode(e) {
        return this.encoder.encode(e)
    }
    decode(e) {
        return this.decoder.decode(e)
    }
}
const ua = ({
        name: i,
        prefix: e,
        encode: t,
        decode: s
    }) => new iI(i, e, t, s),
    $s = ({
        prefix: i,
        name: e,
        alphabet: t
    }) => {
        const {
            encode: s,
            decode: o
        } = QS(t, e);
        return ua({
            prefix: i,
            name: e,
            encode: s,
            decode: c => Op(o(c))
        })
    },
    nI = (i, e, t, s) => {
        const o = {};
        for (let v = 0; v < e.length; ++v) o[e[v]] = v;
        let c = i.length;
        for (; i[c - 1] === "=";) --c;
        const l = new Uint8Array(c * t / 8 | 0);
        let f = 0,
            y = 0,
            p = 0;
        for (let v = 0; v < c; ++v) {
            const D = o[i[v]];
            if (D === void 0) throw new SyntaxError(`Non-${s} character`);
            y = y << t | D, f += t, f >= 8 && (f -= 8, l[p++] = 255 & y >> f)
        }
        if (f >= t || 255 & y << 8 - f) throw new SyntaxError("Unexpected end of data");
        return l
    },
    sI = (i, e, t) => {
        const s = e[e.length - 1] === "=",
            o = (1 << t) - 1;
        let c = "",
            l = 0,
            f = 0;
        for (let y = 0; y < i.length; ++y)
            for (f = f << 8 | i[y], l += 8; l > t;) l -= t, c += e[o & f >> l];
        if (l && (c += e[o & f << t - l]), s)
            for (; c.length * t & 7;) c += "=";
        return c
    },
    Yt = ({
        name: i,
        prefix: e,
        bitsPerChar: t,
        alphabet: s
    }) => ua({
        prefix: e,
        name: i,
        encode(o) {
            return sI(o, s, t)
        },
        decode(o) {
            return nI(o, s, t, i)
        }
    }),
    oI = ua({
        prefix: "\0",
        name: "identity",
        encode: i => ZS(i),
        decode: i => XS(i)
    });
var aI = Object.freeze({
    __proto__: null,
    identity: oI
});
const cI = Yt({
    prefix: "0",
    name: "base2",
    alphabet: "01",
    bitsPerChar: 1
});
var uI = Object.freeze({
    __proto__: null,
    base2: cI
});
const hI = Yt({
    prefix: "7",
    name: "base8",
    alphabet: "01234567",
    bitsPerChar: 3
});
var lI = Object.freeze({
    __proto__: null,
    base8: hI
});
const fI = $s({
    prefix: "9",
    name: "base10",
    alphabet: "0123456789"
});
var dI = Object.freeze({
    __proto__: null,
    base10: fI
});
const pI = Yt({
        prefix: "f",
        name: "base16",
        alphabet: "0123456789abcdef",
        bitsPerChar: 4
    }),
    gI = Yt({
        prefix: "F",
        name: "base16upper",
        alphabet: "0123456789ABCDEF",
        bitsPerChar: 4
    });
var yI = Object.freeze({
    __proto__: null,
    base16: pI,
    base16upper: gI
});
const vI = Yt({
        prefix: "b",
        name: "base32",
        alphabet: "abcdefghijklmnopqrstuvwxyz234567",
        bitsPerChar: 5
    }),
    _I = Yt({
        prefix: "B",
        name: "base32upper",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
        bitsPerChar: 5
    }),
    mI = Yt({
        prefix: "c",
        name: "base32pad",
        alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
        bitsPerChar: 5
    }),
    bI = Yt({
        prefix: "C",
        name: "base32padupper",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
        bitsPerChar: 5
    }),
    wI = Yt({
        prefix: "v",
        name: "base32hex",
        alphabet: "0123456789abcdefghijklmnopqrstuv",
        bitsPerChar: 5
    }),
    EI = Yt({
        prefix: "V",
        name: "base32hexupper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
        bitsPerChar: 5
    }),
    DI = Yt({
        prefix: "t",
        name: "base32hexpad",
        alphabet: "0123456789abcdefghijklmnopqrstuv=",
        bitsPerChar: 5
    }),
    SI = Yt({
        prefix: "T",
        name: "base32hexpadupper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
        bitsPerChar: 5
    }),
    II = Yt({
        prefix: "h",
        name: "base32z",
        alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
        bitsPerChar: 5
    });
var xI = Object.freeze({
    __proto__: null,
    base32: vI,
    base32upper: _I,
    base32pad: mI,
    base32padupper: bI,
    base32hex: wI,
    base32hexupper: EI,
    base32hexpad: DI,
    base32hexpadupper: SI,
    base32z: II
});
const OI = $s({
        prefix: "k",
        name: "base36",
        alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
    }),
    PI = $s({
        prefix: "K",
        name: "base36upper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    });
var CI = Object.freeze({
    __proto__: null,
    base36: OI,
    base36upper: PI
});
const TI = $s({
        name: "base58btc",
        prefix: "z",
        alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    }),
    AI = $s({
        name: "base58flickr",
        prefix: "Z",
        alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
    });
var RI = Object.freeze({
    __proto__: null,
    base58btc: TI,
    base58flickr: AI
});
const NI = Yt({
        prefix: "m",
        name: "base64",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
        bitsPerChar: 6
    }),
    $I = Yt({
        prefix: "M",
        name: "base64pad",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
        bitsPerChar: 6
    }),
    jI = Yt({
        prefix: "u",
        name: "base64url",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
        bitsPerChar: 6
    }),
    LI = Yt({
        prefix: "U",
        name: "base64urlpad",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
        bitsPerChar: 6
    });
var MI = Object.freeze({
    __proto__: null,
    base64: NI,
    base64pad: $I,
    base64url: jI,
    base64urlpad: LI
});
const Cp = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"),
    UI = Cp.reduce((i, e, t) => (i[t] = e, i), []),
    qI = Cp.reduce((i, e, t) => (i[e.codePointAt(0)] = t, i), []);

function zI(i) {
    return i.reduce((e, t) => (e += UI[t], e), "")
}

function FI(i) {
    const e = [];
    for (const t of i) {
        const s = qI[t.codePointAt(0)];
        if (s === void 0) throw new Error(`Non-base256emoji character: ${t}`);
        e.push(s)
    }
    return new Uint8Array(e)
}
const HI = ua({
    prefix: "🚀",
    name: "base256emoji",
    encode: zI,
    decode: FI
});
var BI = Object.freeze({
        __proto__: null,
        base256emoji: HI
    }),
    KI = Tp,
    rd = 128,
    kI = 127,
    VI = ~kI,
    GI = Math.pow(2, 31);

function Tp(i, e, t) {
    e = e || [], t = t || 0;
    for (var s = t; i >= GI;) e[t++] = i & 255 | rd, i /= 128;
    for (; i & VI;) e[t++] = i & 255 | rd, i >>>= 7;
    return e[t] = i | 0, Tp.bytes = t - s + 1, e
}
var WI = Su,
    YI = 128,
    id = 127;

function Su(i, s) {
    var t = 0,
        s = s || 0,
        o = 0,
        c = s,
        l, f = i.length;
    do {
        if (c >= f) throw Su.bytes = 0, new RangeError("Could not decode varint");
        l = i[c++], t += o < 28 ? (l & id) << o : (l & id) * Math.pow(2, o), o += 7
    } while (l >= YI);
    return Su.bytes = c - s, t
}
var JI = Math.pow(2, 7),
    QI = Math.pow(2, 14),
    XI = Math.pow(2, 21),
    ZI = Math.pow(2, 28),
    e2 = Math.pow(2, 35),
    t2 = Math.pow(2, 42),
    r2 = Math.pow(2, 49),
    i2 = Math.pow(2, 56),
    n2 = Math.pow(2, 63),
    s2 = function(i) {
        return i < JI ? 1 : i < QI ? 2 : i < XI ? 3 : i < ZI ? 4 : i < e2 ? 5 : i < t2 ? 6 : i < r2 ? 7 : i < i2 ? 8 : i < n2 ? 9 : 10
    },
    o2 = {
        encode: KI,
        decode: WI,
        encodingLength: s2
    },
    Ap = o2;
const nd = (i, e, t = 0) => (Ap.encode(i, e, t), e),
    sd = i => Ap.encodingLength(i),
    Iu = (i, e) => {
        const t = e.byteLength,
            s = sd(i),
            o = s + sd(t),
            c = new Uint8Array(o + t);
        return nd(i, c, 0), nd(t, c, s), c.set(e, o), new a2(i, t, e, c)
    };
class a2 {
    constructor(e, t, s, o) {
        this.code = e, this.size = t, this.digest = s, this.bytes = o
    }
}
const Rp = ({
    name: i,
    code: e,
    encode: t
}) => new c2(i, e, t);
class c2 {
    constructor(e, t, s) {
        this.name = e, this.code = t, this.encode = s
    }
    digest(e) {
        if (e instanceof Uint8Array) {
            const t = this.encode(e);
            return t instanceof Uint8Array ? Iu(this.code, t) : t.then(s => Iu(this.code, s))
        } else throw Error("Unknown type, must be binary type")
    }
}
const Np = i => async e => new Uint8Array(await crypto.subtle.digest(i, e)),
    u2 = Rp({
        name: "sha2-256",
        code: 18,
        encode: Np("SHA-256")
    }),
    h2 = Rp({
        name: "sha2-512",
        code: 19,
        encode: Np("SHA-512")
    });
var l2 = Object.freeze({
    __proto__: null,
    sha256: u2,
    sha512: h2
});
const $p = 0,
    f2 = "identity",
    jp = Op,
    d2 = i => Iu($p, jp(i)),
    p2 = {
        code: $p,
        name: f2,
        encode: jp,
        digest: d2
    };
var g2 = Object.freeze({
    __proto__: null,
    identity: p2
});
new TextEncoder, new TextDecoder;
const od = { ...aI,
    ...uI,
    ...lI,
    ...dI,
    ...yI,
    ...xI,
    ...CI,
    ...RI,
    ...MI,
    ...BI
};
({ ...l2,
    ...g2
});

function Lp(i) {
    return globalThis.Buffer != null ? new Uint8Array(i.buffer, i.byteOffset, i.byteLength) : i
}

function y2(i = 0) {
    return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? Lp(globalThis.Buffer.allocUnsafe(i)) : new Uint8Array(i)
}

function Mp(i, e, t, s) {
    return {
        name: i,
        prefix: e,
        encoder: {
            name: i,
            prefix: e,
            encode: t
        },
        decoder: {
            decode: s
        }
    }
}
const ad = Mp("utf8", "u", i => "u" + new TextDecoder("utf8").decode(i), i => new TextEncoder().encode(i.substring(1))),
    Yc = Mp("ascii", "a", i => {
        let e = "a";
        for (let t = 0; t < i.length; t++) e += String.fromCharCode(i[t]);
        return e
    }, i => {
        i = i.substring(1);
        const e = y2(i.length);
        for (let t = 0; t < i.length; t++) e[t] = i.charCodeAt(t);
        return e
    }),
    v2 = {
        utf8: ad,
        "utf-8": ad,
        hex: od.base16,
        latin1: Yc,
        ascii: Yc,
        binary: Yc,
        ...od
    };

function _2(i, e = "utf8") {
    const t = v2[e];
    if (!t) throw new Error(`Unsupported encoding "${e}"`);
    return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? Lp(globalThis.Buffer.from(i, "utf-8")) : t.decoder.decode(`${t.prefix}${i}`)
}
const Up = "wc",
    m2 = 2,
    Yu = "core",
    Li = `${Up}@2:${Yu}:`,
    b2 = {
        name: Yu,
        logger: "error"
    },
    w2 = {
        database: ":memory:"
    },
    E2 = "crypto",
    cd = "client_ed25519_seed",
    D2 = ve.ONE_DAY,
    S2 = "keychain",
    I2 = "0.3",
    x2 = "messages",
    O2 = "0.3",
    P2 = ve.SIX_HOURS,
    C2 = "publisher",
    qp = "irn",
    T2 = "error",
    zp = "wss://relay.walletconnect.com",
    ud = "wss://relay.walletconnect.org",
    A2 = "relayer",
    Zt = {
        message: "relayer_message",
        message_ack: "relayer_message_ack",
        connect: "relayer_connect",
        disconnect: "relayer_disconnect",
        error: "relayer_error",
        connection_stalled: "relayer_connection_stalled",
        transport_closed: "relayer_transport_closed",
        publish: "relayer_publish"
    },
    R2 = "_subscription",
    vi = {
        payload: "payload",
        connect: "connect",
        disconnect: "disconnect",
        error: "error"
    },
    N2 = ve.ONE_SECOND,
    $2 = "2.11.2",
    j2 = 1e4,
    L2 = "0.3",
    M2 = "WALLETCONNECT_CLIENT_ID",
    kr = {
        created: "subscription_created",
        deleted: "subscription_deleted",
        expired: "subscription_expired",
        disabled: "subscription_disabled",
        sync: "subscription_sync",
        resubscribed: "subscription_resubscribed"
    },
    U2 = "subscription",
    q2 = "0.3",
    z2 = ve.FIVE_SECONDS * 1e3,
    F2 = "pairing",
    H2 = "0.3",
    ds = {
        wc_pairingDelete: {
            req: {
                ttl: ve.ONE_DAY,
                prompt: !1,
                tag: 1e3
            },
            res: {
                ttl: ve.ONE_DAY,
                prompt: !1,
                tag: 1001
            }
        },
        wc_pairingPing: {
            req: {
                ttl: ve.THIRTY_SECONDS,
                prompt: !1,
                tag: 1002
            },
            res: {
                ttl: ve.THIRTY_SECONDS,
                prompt: !1,
                tag: 1003
            }
        },
        unregistered_method: {
            req: {
                ttl: ve.ONE_DAY,
                prompt: !1,
                tag: 0
            },
            res: {
                ttl: ve.ONE_DAY,
                prompt: !1,
                tag: 0
            }
        }
    },
    vs = {
        create: "pairing_create",
        expire: "pairing_expire",
        delete: "pairing_delete",
        ping: "pairing_ping"
    },
    ti = {
        created: "history_created",
        updated: "history_updated",
        deleted: "history_deleted",
        sync: "history_sync"
    },
    B2 = "history",
    K2 = "0.3",
    k2 = "expirer",
    Mr = {
        created: "expirer_created",
        deleted: "expirer_deleted",
        expired: "expirer_expired",
        sync: "expirer_sync"
    },
    V2 = "0.3",
    Jc = "verify-api",
    jn = "https://verify.walletconnect.com",
    xu = "https://verify.walletconnect.org",
    G2 = [jn, xu],
    W2 = "echo",
    Y2 = "https://echo.walletconnect.com";
class J2 {
    constructor(e, t) {
        this.core = e, this.logger = t, this.keychain = new Map, this.name = S2, this.version = I2, this.initialized = !1, this.storagePrefix = Li, this.init = async () => {
            if (!this.initialized) {
                const s = await this.getKeyChain();
                typeof s < "u" && (this.keychain = s), this.initialized = !0
            }
        }, this.has = s => (this.isInitialized(), this.keychain.has(s)), this.set = async (s, o) => {
            this.isInitialized(), this.keychain.set(s, o), await this.persist()
        }, this.get = s => {
            this.isInitialized();
            const o = this.keychain.get(s);
            if (typeof o > "u") {
                const {
                    message: c
                } = ce("NO_MATCHING_KEY", `${this.name}: ${s}`);
                throw new Error(c)
            }
            return o
        }, this.del = async s => {
            this.isInitialized(), this.keychain.delete(s), await this.persist()
        }, this.core = e, this.logger = Ye.generateChildLogger(t, this.name)
    }
    get context() {
        return Ye.getLoggerContext(this.logger)
    }
    get storageKey() {
        return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name
    }
    async setKeyChain(e) {
        await this.core.storage.setItem(this.storageKey, rp(e))
    }
    async getKeyChain() {
        const e = await this.core.storage.getItem(this.storageKey);
        return typeof e < "u" ? ip(e) : void 0
    }
    async persist() {
        await this.setKeyChain(this.keychain)
    }
    isInitialized() {
        if (!this.initialized) {
            const {
                message: e
            } = ce("NOT_INITIALIZED", this.name);
            throw new Error(e)
        }
    }
}
class Q2 {
    constructor(e, t, s) {
        this.core = e, this.logger = t, this.name = E2, this.initialized = !1, this.init = async () => {
            this.initialized || (await this.keychain.init(), this.initialized = !0)
        }, this.hasKeys = o => (this.isInitialized(), this.keychain.has(o)), this.getClientId = async () => {
            this.isInitialized();
            const o = await this.getClientSeed(),
                c = Gf(o);
            return _p(c.publicKey)
        }, this.generateKeyPair = () => {
            this.isInitialized();
            const o = K1();
            return this.setPrivateKey(o.publicKey, o.privateKey)
        }, this.signJWT = async o => {
            this.isInitialized();
            const c = await this.getClientSeed(),
                l = Gf(c),
                f = fu();
            return await Z3(f, o, D2, l)
        }, this.generateSharedKey = (o, c, l) => {
            this.isInitialized();
            const f = this.getPrivateKey(o),
                y = k1(f, c);
            return this.setSymKey(y, l)
        }, this.setSymKey = async (o, c) => {
            this.isInitialized();
            const l = c || V1(o);
            return await this.keychain.set(l, o), l
        }, this.deleteKeyPair = async o => {
            this.isInitialized(), await this.keychain.del(o)
        }, this.deleteSymKey = async o => {
            this.isInitialized(), await this.keychain.del(o)
        }, this.encode = async (o, c, l) => {
            this.isInitialized();
            const f = tp(l),
                y = on(c);
            if (wf(f)) {
                const S = f.senderPublicKey,
                    x = f.receiverPublicKey;
                o = await this.generateSharedKey(S, x)
            }
            const p = this.getSymKey(o),
                {
                    type: v,
                    senderPublicKey: D
                } = f;
            return W1({
                type: v,
                symKey: p,
                message: y,
                senderPublicKey: D
            })
        }, this.decode = async (o, c, l) => {
            this.isInitialized();
            const f = Q1(c, l);
            if (wf(f)) {
                const y = f.receiverPublicKey,
                    p = f.senderPublicKey;
                o = await this.generateSharedKey(y, p)
            }
            try {
                const y = this.getSymKey(o),
                    p = Y1({
                        symKey: y,
                        encoded: c
                    });
                return Ns(p)
            } catch (y) {
                this.logger.error(`Failed to decode message from topic: '${o}', clientId: '${await this.getClientId()}'`), this.logger.error(y)
            }
        }, this.getPayloadType = o => {
            const c = Yo(o);
            return Ts(c.type)
        }, this.getPayloadSenderPublicKey = o => {
            const c = Yo(o);
            return c.senderPublicKey ? hr(c.senderPublicKey, ur) : void 0
        }, this.core = e, this.logger = Ye.generateChildLogger(t, this.name), this.keychain = s || new J2(this.core, this.logger)
    }
    get context() {
        return Ye.getLoggerContext(this.logger)
    }
    async setPrivateKey(e, t) {
        return await this.keychain.set(e, t), e
    }
    getPrivateKey(e) {
        return this.keychain.get(e)
    }
    async getClientSeed() {
        let e = "";
        try {
            e = this.keychain.get(cd)
        } catch {
            e = fu(), await this.keychain.set(cd, e)
        }
        return _2(e, "base16")
    }
    getSymKey(e) {
        return this.keychain.get(e)
    }
    isInitialized() {
        if (!this.initialized) {
            const {
                message: e
            } = ce("NOT_INITIALIZED", this.name);
            throw new Error(e)
        }
    }
}
class X2 extends T3 {
    constructor(e, t) {
        super(e, t), this.logger = e, this.core = t, this.messages = new Map, this.name = x2, this.version = O2, this.initialized = !1, this.storagePrefix = Li, this.init = async () => {
            if (!this.initialized) {
                this.logger.trace("Initialized");
                try {
                    const s = await this.getRelayerMessages();
                    typeof s < "u" && (this.messages = s), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({
                        type: "method",
                        method: "restore",
                        size: this.messages.size
                    })
                } catch (s) {
                    this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(s)
                } finally {
                    this.initialized = !0
                }
            }
        }, this.set = async (s, o) => {
            this.isInitialized();
            const c = Ln(o);
            let l = this.messages.get(s);
            return typeof l > "u" && (l = {}), typeof l[c] < "u" || (l[c] = o, this.messages.set(s, l), await this.persist()), c
        }, this.get = s => {
            this.isInitialized();
            let o = this.messages.get(s);
            return typeof o > "u" && (o = {}), o
        }, this.has = (s, o) => {
            this.isInitialized();
            const c = this.get(s),
                l = Ln(o);
            return typeof c[l] < "u"
        }, this.del = async s => {
            this.isInitialized(), this.messages.delete(s), await this.persist()
        }, this.logger = Ye.generateChildLogger(e, this.name), this.core = t
    }
    get context() {
        return Ye.getLoggerContext(this.logger)
    }
    get storageKey() {
        return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name
    }
    async setRelayerMessages(e) {
        await this.core.storage.setItem(this.storageKey, rp(e))
    }
    async getRelayerMessages() {
        const e = await this.core.storage.getItem(this.storageKey);
        return typeof e < "u" ? ip(e) : void 0
    }
    async persist() {
        await this.setRelayerMessages(this.messages)
    }
    isInitialized() {
        if (!this.initialized) {
            const {
                message: e
            } = ce("NOT_INITIALIZED", this.name);
            throw new Error(e)
        }
    }
}
class Z2 extends A3 {
    constructor(e, t) {
        super(e, t), this.relayer = e, this.logger = t, this.events = new Ur.EventEmitter, this.name = C2, this.queue = new Map, this.publishTimeout = ve.toMiliseconds(ve.TEN_SECONDS * 2), this.needsTransportRestart = !1, this.publish = async (s, o, c) => {
            var l;
            this.logger.debug("Publishing Payload"), this.logger.trace({
                type: "method",
                method: "publish",
                params: {
                    topic: s,
                    message: o,
                    opts: c
                }
            });
            try {
                const f = (c == null ? void 0 : c.ttl) || P2,
                    y = du(c),
                    p = (c == null ? void 0 : c.prompt) || !1,
                    v = (c == null ? void 0 : c.tag) || 0,
                    D = (c == null ? void 0 : c.id) || Sp().toString(),
                    S = {
                        topic: s,
                        message: o,
                        opts: {
                            ttl: f,
                            relay: y,
                            prompt: p,
                            tag: v,
                            id: D
                        }
                    },
                    x = setTimeout(() => this.queue.set(D, S), this.publishTimeout);
                try {
                    await await Es(this.rpcPublish(s, o, f, y, p, v, D), this.publishTimeout, `Failed to publish payload, please try again. id:${D} tag:${v}`), this.removeRequestFromQueue(D), this.relayer.events.emit(Zt.publish, S)
                } catch (O) {
                    if (this.logger.debug("Publishing Payload stalled"), this.needsTransportRestart = !0, (l = c == null ? void 0 : c.internal) != null && l.throwOnFailedPublish) throw this.removeRequestFromQueue(D), O;
                    return
                } finally {
                    clearTimeout(x)
                }
                this.logger.debug("Successfully Published Payload"), this.logger.trace({
                    type: "method",
                    method: "publish",
                    params: {
                        topic: s,
                        message: o,
                        opts: c
                    }
                })
            } catch (f) {
                throw this.logger.debug("Failed to Publish Payload"), this.logger.error(f), f
            }
        }, this.on = (s, o) => {
            this.events.on(s, o)
        }, this.once = (s, o) => {
            this.events.once(s, o)
        }, this.off = (s, o) => {
            this.events.off(s, o)
        }, this.removeListener = (s, o) => {
            this.events.removeListener(s, o)
        }, this.relayer = e, this.logger = Ye.generateChildLogger(t, this.name), this.registerEventListeners()
    }
    get context() {
        return Ye.getLoggerContext(this.logger)
    }
    rpcPublish(e, t, s, o, c, l, f) {
        var y, p, v, D;
        const S = {
            method: Vo(o.protocol).publish,
            params: {
                topic: e,
                message: t,
                ttl: s,
                prompt: c,
                tag: l
            },
            id: f
        };
        return cr((y = S.params) == null ? void 0 : y.prompt) && ((p = S.params) == null || delete p.prompt), cr((v = S.params) == null ? void 0 : v.tag) && ((D = S.params) == null || delete D.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({
            type: "message",
            direction: "outgoing",
            request: S
        }), this.relayer.request(S)
    }
    removeRequestFromQueue(e) {
        this.queue.delete(e)
    }
    checkQueue() {
        this.queue.forEach(async e => {
            const {
                topic: t,
                message: s,
                opts: o
            } = e;
            await this.publish(t, s, o)
        })
    }
    registerEventListeners() {
        this.relayer.core.heartbeat.on(Bn.HEARTBEAT_EVENTS.pulse, () => {
            if (this.needsTransportRestart) {
                this.needsTransportRestart = !1, this.relayer.events.emit(Zt.connection_stalled);
                return
            }
            this.checkQueue()
        }), this.relayer.on(Zt.message_ack, e => {
            this.removeRequestFromQueue(e.id.toString())
        })
    }
}
class e6 {
    constructor() {
        this.map = new Map, this.set = (e, t) => {
            const s = this.get(e);
            this.exists(e, t) || this.map.set(e, [...s, t])
        }, this.get = e => this.map.get(e) || [], this.exists = (e, t) => this.get(e).includes(t), this.delete = (e, t) => {
            if (typeof t > "u") {
                this.map.delete(e);
                return
            }
            if (!this.map.has(e)) return;
            const s = this.get(e);
            if (!this.exists(e, t)) return;
            const o = s.filter(c => c !== t);
            if (!o.length) {
                this.map.delete(e);
                return
            }
            this.map.set(e, o)
        }, this.clear = () => {
            this.map.clear()
        }
    }
    get topics() {
        return Array.from(this.map.keys())
    }
}
var t6 = Object.defineProperty,
    r6 = Object.defineProperties,
    i6 = Object.getOwnPropertyDescriptors,
    hd = Object.getOwnPropertySymbols,
    n6 = Object.prototype.hasOwnProperty,
    s6 = Object.prototype.propertyIsEnumerable,
    ld = (i, e, t) => e in i ? t6(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t,
    ps = (i, e) => {
        for (var t in e || (e = {})) n6.call(e, t) && ld(i, t, e[t]);
        if (hd)
            for (var t of hd(e)) s6.call(e, t) && ld(i, t, e[t]);
        return i
    },
    Qc = (i, e) => r6(i, i6(e));
class o6 extends $3 {
    constructor(e, t) {
        super(e, t), this.relayer = e, this.logger = t, this.subscriptions = new Map, this.topicMap = new e6, this.events = new Ur.EventEmitter, this.name = U2, this.version = q2, this.pending = new Map, this.cached = [], this.initialized = !1, this.pendingSubscriptionWatchLabel = "pending_sub_watch_label", this.pollingInterval = 20, this.storagePrefix = Li, this.subscribeTimeout = 1e4, this.restartInProgress = !1, this.batchSubscribeTopicsLimit = 500, this.init = async () => {
            this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), this.clientId = await this.relayer.core.crypto.getClientId())
        }, this.subscribe = async (s, o) => {
            await this.restartToComplete(), this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({
                type: "method",
                method: "subscribe",
                params: {
                    topic: s,
                    opts: o
                }
            });
            try {
                const c = du(o),
                    l = {
                        topic: s,
                        relay: c
                    };
                this.pending.set(s, l);
                const f = await this.rpcSubscribe(s, c);
                return this.onSubscribe(f, l), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({
                    type: "method",
                    method: "subscribe",
                    params: {
                        topic: s,
                        opts: o
                    }
                }), f
            } catch (c) {
                throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(c), c
            }
        }, this.unsubscribe = async (s, o) => {
            await this.restartToComplete(), this.isInitialized(), typeof(o == null ? void 0 : o.id) < "u" ? await this.unsubscribeById(s, o.id, o) : await this.unsubscribeByTopic(s, o)
        }, this.isSubscribed = async s => {
            if (this.topics.includes(s)) return !0;
            const o = `${this.pendingSubscriptionWatchLabel}_${s}`;
            return await new Promise((c, l) => {
                const f = new ve.Watch;
                f.start(o);
                const y = setInterval(() => {
                    !this.pending.has(s) && this.topics.includes(s) && (clearInterval(y), f.stop(o), c(!0)), f.elapsed(o) >= z2 && (clearInterval(y), f.stop(o), l(new Error("Subscription resolution timeout")))
                }, this.pollingInterval)
            }).catch(() => !1)
        }, this.on = (s, o) => {
            this.events.on(s, o)
        }, this.once = (s, o) => {
            this.events.once(s, o)
        }, this.off = (s, o) => {
            this.events.off(s, o)
        }, this.removeListener = (s, o) => {
            this.events.removeListener(s, o)
        }, this.restart = async () => {
            this.restartInProgress = !0, await this.restore(), await this.reset(), this.restartInProgress = !1
        }, this.relayer = e, this.logger = Ye.generateChildLogger(t, this.name), this.clientId = ""
    }
    get context() {
        return Ye.getLoggerContext(this.logger)
    }
    get storageKey() {
        return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name
    }
    get length() {
        return this.subscriptions.size
    }
    get ids() {
        return Array.from(this.subscriptions.keys())
    }
    get values() {
        return Array.from(this.subscriptions.values())
    }
    get topics() {
        return this.topicMap.topics
    }
    hasSubscription(e, t) {
        let s = !1;
        try {
            s = this.getSubscription(e).topic === t
        } catch {}
        return s
    }
    onEnable() {
        this.cached = [], this.initialized = !0
    }
    onDisable() {
        this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear()
    }
    async unsubscribeByTopic(e, t) {
        const s = this.topicMap.get(e);
        await Promise.all(s.map(async o => await this.unsubscribeById(e, o, t)))
    }
    async unsubscribeById(e, t, s) {
        this.logger.debug("Unsubscribing Topic"), this.logger.trace({
            type: "method",
            method: "unsubscribe",
            params: {
                topic: e,
                id: t,
                opts: s
            }
        });
        try {
            const o = du(s);
            await this.rpcUnsubscribe(e, t, o);
            const c = _t("USER_DISCONNECTED", `${this.name}, ${e}`);
            await this.onUnsubscribe(e, t, c), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({
                type: "method",
                method: "unsubscribe",
                params: {
                    topic: e,
                    id: t,
                    opts: s
                }
            })
        } catch (o) {
            throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(o), o
        }
    }
    async rpcSubscribe(e, t) {
        const s = {
            method: Vo(t.protocol).subscribe,
            params: {
                topic: e
            }
        };
        this.logger.debug("Outgoing Relay Payload"), this.logger.trace({
            type: "payload",
            direction: "outgoing",
            request: s
        });
        try {
            await await Es(this.relayer.request(s), this.subscribeTimeout)
        } catch {
            this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(Zt.connection_stalled)
        }
        return Ln(e + this.clientId)
    }
    async rpcBatchSubscribe(e) {
        if (!e.length) return;
        const t = e[0].relay,
            s = {
                method: Vo(t.protocol).batchSubscribe,
                params: {
                    topics: e.map(o => o.topic)
                }
            };
        this.logger.debug("Outgoing Relay Payload"), this.logger.trace({
            type: "payload",
            direction: "outgoing",
            request: s
        });
        try {
            return await await Es(this.relayer.request(s), this.subscribeTimeout)
        } catch {
            this.logger.debug("Outgoing Relay Payload stalled"), this.relayer.events.emit(Zt.connection_stalled)
        }
    }
    rpcUnsubscribe(e, t, s) {
        const o = {
            method: Vo(s.protocol).unsubscribe,
            params: {
                topic: e,
                id: t
            }
        };
        return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({
            type: "payload",
            direction: "outgoing",
            request: o
        }), this.relayer.request(o)
    }
    onSubscribe(e, t) {
        this.setSubscription(e, Qc(ps({}, t), {
            id: e
        })), this.pending.delete(t.topic)
    }
    onBatchSubscribe(e) {
        e.length && e.forEach(t => {
            this.setSubscription(t.id, ps({}, t)), this.pending.delete(t.topic)
        })
    }
    async onUnsubscribe(e, t, s) {
        this.events.removeAllListeners(t), this.hasSubscription(t, e) && this.deleteSubscription(t, s), await this.relayer.messages.del(e)
    }
    async setRelayerSubscriptions(e) {
        await this.relayer.core.storage.setItem(this.storageKey, e)
    }
    async getRelayerSubscriptions() {
        return await this.relayer.core.storage.getItem(this.storageKey)
    }
    setSubscription(e, t) {
        this.subscriptions.has(e) || (this.logger.debug("Setting subscription"), this.logger.trace({
            type: "method",
            method: "setSubscription",
            id: e,
            subscription: t
        }), this.addSubscription(e, t))
    }
    addSubscription(e, t) {
        this.subscriptions.set(e, ps({}, t)), this.topicMap.set(t.topic, e), this.events.emit(kr.created, t)
    }
    getSubscription(e) {
        this.logger.debug("Getting subscription"), this.logger.trace({
            type: "method",
            method: "getSubscription",
            id: e
        });
        const t = this.subscriptions.get(e);
        if (!t) {
            const {
                message: s
            } = ce("NO_MATCHING_KEY", `${this.name}: ${e}`);
            throw new Error(s)
        }
        return t
    }
    deleteSubscription(e, t) {
        this.logger.debug("Deleting subscription"), this.logger.trace({
            type: "method",
            method: "deleteSubscription",
            id: e,
            reason: t
        });
        const s = this.getSubscription(e);
        this.subscriptions.delete(e), this.topicMap.delete(s.topic, e), this.events.emit(kr.deleted, Qc(ps({}, s), {
            reason: t
        }))
    }
    async persist() {
        await this.setRelayerSubscriptions(this.values), this.events.emit(kr.sync)
    }
    async reset() {
        if (this.cached.length) {
            const e = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
            for (let t = 0; t < e; t++) {
                const s = this.cached.splice(0, this.batchSubscribeTopicsLimit);
                await this.batchSubscribe(s)
            }
        }
        this.events.emit(kr.resubscribed)
    }
    async restore() {
        try {
            const e = await this.getRelayerSubscriptions();
            if (typeof e > "u" || !e.length) return;
            if (this.subscriptions.size) {
                const {
                    message: t
                } = ce("RESTORE_WILL_OVERRIDE", this.name);
                throw this.logger.error(t), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(t)
            }
            this.cached = e, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({
                type: "method",
                method: "restore",
                subscriptions: this.values
            })
        } catch (e) {
            this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e)
        }
    }
    async batchSubscribe(e) {
        if (!e.length) return;
        const t = await this.rpcBatchSubscribe(e);
        ri(t) && this.onBatchSubscribe(t.map((s, o) => Qc(ps({}, e[o]), {
            id: s
        })))
    }
    async onConnect() {
        this.restartInProgress || (await this.restart(), this.onEnable())
    }
    onDisconnect() {
        this.onDisable()
    }
    async checkPending() {
        if (!this.initialized || this.relayer.transportExplicitlyClosed) return;
        const e = [];
        this.pending.forEach(t => {
            e.push(t)
        }), await this.batchSubscribe(e)
    }
    registerEventListeners() {
        this.relayer.core.heartbeat.on(Bn.HEARTBEAT_EVENTS.pulse, async () => {
            await this.checkPending()
        }), this.relayer.on(Zt.connect, async () => {
            await this.onConnect()
        }), this.relayer.on(Zt.disconnect, () => {
            this.onDisconnect()
        }), this.events.on(kr.created, async e => {
            const t = kr.created;
            this.logger.info(`Emitting ${t}`), this.logger.debug({
                type: "event",
                event: t,
                data: e
            }), await this.persist()
        }), this.events.on(kr.deleted, async e => {
            const t = kr.deleted;
            this.logger.info(`Emitting ${t}`), this.logger.debug({
                type: "event",
                event: t,
                data: e
            }), await this.persist()
        })
    }
    isInitialized() {
        if (!this.initialized) {
            const {
                message: e
            } = ce("NOT_INITIALIZED", this.name);
            throw new Error(e)
        }
    }
    async restartToComplete() {
        this.restartInProgress && await new Promise(e => {
            const t = setInterval(() => {
                this.restartInProgress || (clearInterval(t), e())
            }, this.pollingInterval)
        })
    }
}
var a6 = Object.defineProperty,
    fd = Object.getOwnPropertySymbols,
    c6 = Object.prototype.hasOwnProperty,
    u6 = Object.prototype.propertyIsEnumerable,
    dd = (i, e, t) => e in i ? a6(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t,
    h6 = (i, e) => {
        for (var t in e || (e = {})) c6.call(e, t) && dd(i, t, e[t]);
        if (fd)
            for (var t of fd(e)) u6.call(e, t) && dd(i, t, e[t]);
        return i
    };
class l6 extends R3 {
    constructor(e) {
        super(e), this.protocol = "wc", this.version = 2, this.events = new Ur.EventEmitter, this.name = A2, this.transportExplicitlyClosed = !1, this.initialized = !1, this.connectionAttemptInProgress = !1, this.connectionStatusPollingInterval = 20, this.staleConnectionErrors = ["socket hang up", "socket stalled"], this.hasExperiencedNetworkDisruption = !1, this.requestsInFlight = new Map, this.request = async t => {
            this.logger.debug("Publishing Request Payload");
            const s = t.id;
            try {
                await this.toEstablishConnection();
                const o = this.provider.request(t);
                return this.requestsInFlight.set(s, {
                    promise: o,
                    request: t
                }), await o
            } catch (o) {
                throw this.logger.debug("Failed to Publish Request"), this.logger.error(o), o
            } finally {
                this.requestsInFlight.delete(s)
            }
        }, this.onPayloadHandler = t => {
            this.onProviderPayload(t)
        }, this.onConnectHandler = () => {
            this.events.emit(Zt.connect)
        }, this.onDisconnectHandler = () => {
            this.onProviderDisconnect()
        }, this.onProviderErrorHandler = t => {
            this.logger.error(t), this.events.emit(Zt.error, t), this.logger.info("Fatal socket error received, closing transport"), this.transportClose()
        }, this.registerProviderListeners = () => {
            this.provider.on(vi.payload, this.onPayloadHandler), this.provider.on(vi.connect, this.onConnectHandler), this.provider.on(vi.disconnect, this.onDisconnectHandler), this.provider.on(vi.error, this.onProviderErrorHandler)
        }, this.core = e.core, this.logger = typeof e.logger < "u" && typeof e.logger != "string" ? Ye.generateChildLogger(e.logger, this.name) : Ye.pino(Ye.getDefaultLoggerOptions({
            level: e.logger || T2
        })), this.messages = new X2(this.logger, e.core), this.subscriber = new o6(this, this.logger), this.publisher = new Z2(this, this.logger), this.relayUrl = (e == null ? void 0 : e.relayUrl) || zp, this.projectId = e.projectId, this.bundleId = iE(), this.provider = {}
    }
    async init() {
        this.logger.trace("Initialized"), this.registerEventListeners(), await this.createProvider(), await Promise.all([this.messages.init(), this.subscriber.init()]);
        try {
            await this.transportOpen()
        } catch {
            this.logger.warn(`Connection via ${this.relayUrl} failed, attempting to connect via failover domain ${ud}...`), await this.restartTransport(ud)
        }
        this.initialized = !0, setTimeout(async () => {
            this.subscriber.topics.length === 0 && (this.logger.info("No topics subscribed to after init, closing transport"), await this.transportClose(), this.transportExplicitlyClosed = !1)
        }, j2)
    }
    get context() {
        return Ye.getLoggerContext(this.logger)
    }
    get connected() {
        return this.provider.connection.connected
    }
    get connecting() {
        return this.provider.connection.connecting
    }
    async publish(e, t, s) {
        this.isInitialized(), await this.publisher.publish(e, t, s), await this.recordMessageEvent({
            topic: e,
            message: t,
            publishedAt: Date.now()
        })
    }
    async subscribe(e, t) {
        var s;
        this.isInitialized();
        let o = ((s = this.subscriber.topicMap.get(e)) == null ? void 0 : s[0]) || "";
        if (o) return o;
        let c;
        const l = f => {
            f.topic === e && (this.subscriber.off(kr.created, l), c())
        };
        return await Promise.all([new Promise(f => {
            c = f, this.subscriber.on(kr.created, l)
        }), new Promise(async f => {
            o = await this.subscriber.subscribe(e, t), f()
        })]), o
    }
    async unsubscribe(e, t) {
        this.isInitialized(), await this.subscriber.unsubscribe(e, t)
    }
    on(e, t) {
        this.events.on(e, t)
    }
    once(e, t) {
        this.events.once(e, t)
    }
    off(e, t) {
        this.events.off(e, t)
    }
    removeListener(e, t) {
        this.events.removeListener(e, t)
    }
    async transportClose() {
        this.requestsInFlight.size > 0 && (this.logger.debug("Waiting for all in-flight requests to finish before closing transport..."), this.requestsInFlight.forEach(async e => {
            await e.promise
        })), this.transportExplicitlyClosed = !0, this.hasExperiencedNetworkDisruption && this.connected ? await Es(this.provider.disconnect(), 1e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.connected && await this.provider.disconnect()
    }
    async transportOpen(e) {
        if (this.transportExplicitlyClosed = !1, await this.confirmOnlineStateOrThrow(), !this.connectionAttemptInProgress) {
            e && e !== this.relayUrl && (this.relayUrl = e, await this.transportClose(), await this.createProvider()), this.connectionAttemptInProgress = !0;
            try {
                await Promise.all([new Promise(t => {
                    if (!this.initialized) return t();
                    this.subscriber.once(kr.resubscribed, () => {
                        t()
                    })
                }), new Promise(async (t, s) => {
                    try {
                        await Es(this.provider.connect(), 1e4, `Socket stalled when trying to connect to ${this.relayUrl}`)
                    } catch (o) {
                        s(o);
                        return
                    }
                    t()
                })])
            } catch (t) {
                this.logger.error(t);
                const s = t;
                if (!this.isConnectionStalled(s.message)) throw t;
                this.provider.events.emit(vi.disconnect)
            } finally {
                this.connectionAttemptInProgress = !1, this.hasExperiencedNetworkDisruption = !1
            }
        }
    }
    async restartTransport(e) {
        await this.confirmOnlineStateOrThrow(), !this.connectionAttemptInProgress && (this.relayUrl = e || this.relayUrl, await this.transportClose(), await this.createProvider(), await this.transportOpen())
    }
    async confirmOnlineStateOrThrow() {
        if (!await Rf()) throw new Error("No internet connection detected. Please restart your network and try again.")
    }
    isConnectionStalled(e) {
        return this.staleConnectionErrors.some(t => e.includes(t))
    }
    async createProvider() {
        this.provider.connection && this.unregisterProviderListeners();
        const e = await this.core.crypto.signJWT(this.relayUrl);
        this.provider = new Ei(new FS(uE({
            sdkVersion: $2,
            protocol: this.protocol,
            version: this.version,
            relayUrl: this.relayUrl,
            projectId: this.projectId,
            auth: e,
            useOnCloseEvent: !0,
            bundleId: this.bundleId
        }))), this.registerProviderListeners()
    }
    async recordMessageEvent(e) {
        const {
            topic: t,
            message: s
        } = e;
        await this.messages.set(t, s)
    }
    async shouldIgnoreMessageEvent(e) {
        const {
            topic: t,
            message: s
        } = e;
        if (!s || s.length === 0) return this.logger.debug(`Ignoring invalid/empty message: ${s}`), !0;
        if (!await this.subscriber.isSubscribed(t)) return this.logger.debug(`Ignoring message for non-subscribed topic ${t}`), !0;
        const o = this.messages.has(t, s);
        return o && this.logger.debug(`Ignoring duplicate message: ${s}`), o
    }
    async onProviderPayload(e) {
        if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({
                type: "payload",
                direction: "incoming",
                payload: e
            }), Wu(e)) {
            if (!e.method.endsWith(R2)) return;
            const t = e.params,
                {
                    topic: s,
                    message: o,
                    publishedAt: c
                } = t.data,
                l = {
                    topic: s,
                    message: o,
                    publishedAt: c
                };
            this.logger.debug("Emitting Relayer Payload"), this.logger.trace(h6({
                type: "event",
                event: t.id
            }, l)), this.events.emit(t.id, l), await this.acknowledgePayload(e), await this.onMessageEvent(l)
        } else ca(e) && this.events.emit(Zt.message_ack, e)
    }
    async onMessageEvent(e) {
        await this.shouldIgnoreMessageEvent(e) || (this.events.emit(Zt.message, e), await this.recordMessageEvent(e))
    }
    async acknowledgePayload(e) {
        const t = oa(e.id, !0);
        await this.provider.connection.send(t)
    }
    unregisterProviderListeners() {
        this.provider.off(vi.payload, this.onPayloadHandler), this.provider.off(vi.connect, this.onConnectHandler), this.provider.off(vi.disconnect, this.onDisconnectHandler), this.provider.off(vi.error, this.onProviderErrorHandler)
    }
    async registerEventListeners() {
        this.events.on(Zt.connection_stalled, () => {
            this.restartTransport().catch(t => this.logger.error(t))
        });
        let e = await Rf();
        iD(async t => {
            this.initialized && e !== t && (e = t, t ? await this.restartTransport().catch(s => this.logger.error(s)) : (this.hasExperiencedNetworkDisruption = !0, await this.transportClose().catch(s => this.logger.error(s))))
        })
    }
    onProviderDisconnect() {
        this.events.emit(Zt.disconnect), this.attemptToReconnect()
    }
    attemptToReconnect() {
        this.transportExplicitlyClosed || (this.logger.info("attemptToReconnect called. Connecting..."), setTimeout(async () => {
            await this.restartTransport().catch(e => this.logger.error(e))
        }, ve.toMiliseconds(N2)))
    }
    isInitialized() {
        if (!this.initialized) {
            const {
                message: e
            } = ce("NOT_INITIALIZED", this.name);
            throw new Error(e)
        }
    }
    async toEstablishConnection() {
        if (await this.confirmOnlineStateOrThrow(), !this.connected) {
            if (this.connectionAttemptInProgress) return await new Promise(e => {
                const t = setInterval(() => {
                    this.connected && (clearInterval(t), e())
                }, this.connectionStatusPollingInterval)
            });
            await this.restartTransport()
        }
    }
}
var f6 = Object.defineProperty,
    pd = Object.getOwnPropertySymbols,
    d6 = Object.prototype.hasOwnProperty,
    p6 = Object.prototype.propertyIsEnumerable,
    gd = (i, e, t) => e in i ? f6(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t,
    yd = (i, e) => {
        for (var t in e || (e = {})) d6.call(e, t) && gd(i, t, e[t]);
        if (pd)
            for (var t of pd(e)) p6.call(e, t) && gd(i, t, e[t]);
        return i
    };
class ha extends N3 {
    constructor(e, t, s, o = Li, c = void 0) {
        super(e, t, s, o), this.core = e, this.logger = t, this.name = s, this.map = new Map, this.version = L2, this.cached = [], this.initialized = !1, this.storagePrefix = Li, this.init = async () => {
            this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach(l => {
                this.getKey && l !== null && !cr(l) ? this.map.set(this.getKey(l), l) : $E(l) ? this.map.set(l.id, l) : jE(l) && this.map.set(l.topic, l)
            }), this.cached = [], this.initialized = !0)
        }, this.set = async (l, f) => {
            this.isInitialized(), this.map.has(l) ? await this.update(l, f) : (this.logger.debug("Setting value"), this.logger.trace({
                type: "method",
                method: "set",
                key: l,
                value: f
            }), this.map.set(l, f), await this.persist())
        }, this.get = l => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({
            type: "method",
            method: "get",
            key: l
        }), this.getData(l)), this.getAll = l => (this.isInitialized(), l ? this.values.filter(f => Object.keys(l).every(y => BS(f[y], l[y]))) : this.values), this.update = async (l, f) => {
            this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({
                type: "method",
                method: "update",
                key: l,
                update: f
            });
            const y = yd(yd({}, this.getData(l)), f);
            this.map.set(l, y), await this.persist()
        }, this.delete = async (l, f) => {
            this.isInitialized(), this.map.has(l) && (this.logger.debug("Deleting value"), this.logger.trace({
                type: "method",
                method: "delete",
                key: l,
                reason: f
            }), this.map.delete(l), await this.persist())
        }, this.logger = Ye.generateChildLogger(t, this.name), this.storagePrefix = o, this.getKey = c
    }
    get context() {
        return Ye.getLoggerContext(this.logger)
    }
    get storageKey() {
        return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name
    }
    get length() {
        return this.map.size
    }
    get keys() {
        return Array.from(this.map.keys())
    }
    get values() {
        return Array.from(this.map.values())
    }
    async setDataStore(e) {
        await this.core.storage.setItem(this.storageKey, e)
    }
    async getDataStore() {
        return await this.core.storage.getItem(this.storageKey)
    }
    getData(e) {
        const t = this.map.get(e);
        if (!t) {
            const {
                message: s
            } = ce("NO_MATCHING_KEY", `${this.name}: ${e}`);
            throw this.logger.error(s), new Error(s)
        }
        return t
    }
    async persist() {
        await this.setDataStore(this.values)
    }
    async restore() {
        try {
            const e = await this.getDataStore();
            if (typeof e > "u" || !e.length) return;
            if (this.map.size) {
                const {
                    message: t
                } = ce("RESTORE_WILL_OVERRIDE", this.name);
                throw this.logger.error(t), new Error(t)
            }
            this.cached = e, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({
                type: "method",
                method: "restore",
                value: this.values
            })
        } catch (e) {
            this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e)
        }
    }
    isInitialized() {
        if (!this.initialized) {
            const {
                message: e
            } = ce("NOT_INITIALIZED", this.name);
            throw new Error(e)
        }
    }
}
class g6 {
    constructor(e, t) {
        this.core = e, this.logger = t, this.name = F2, this.version = H2, this.events = new Ru, this.initialized = !1, this.storagePrefix = Li, this.ignoredPayloadTypes = [cn], this.registeredMethods = [], this.init = async () => {
            this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = !0, this.logger.trace("Initialized"))
        }, this.register = ({
            methods: s
        }) => {
            this.isInitialized(), this.registeredMethods = [...new Set([...this.registeredMethods, ...s])]
        }, this.create = async () => {
            this.isInitialized();
            const s = fu(),
                o = await this.core.crypto.setSymKey(s),
                c = xr(ve.FIVE_MINUTES),
                l = {
                    protocol: qp
                },
                f = {
                    topic: o,
                    expiry: c,
                    relay: l,
                    active: !1
                },
                y = IE({
                    protocol: this.core.protocol,
                    version: this.core.version,
                    topic: o,
                    symKey: s,
                    relay: l,
                    expiryTimestamp: c
                });
            return await this.pairings.set(o, f), await this.core.relayer.subscribe(o), this.core.expirer.set(o, c), {
                topic: o,
                uri: y
            }
        }, this.pair = async s => {
            this.isInitialized(), this.isValidPair(s);
            const {
                topic: o,
                symKey: c,
                relay: l,
                expiryTimestamp: f
            } = Of(s.uri);
            let y;
            if (this.pairings.keys.includes(o) && (y = this.pairings.get(o), y.active)) throw new Error(`Pairing already exists: ${o}. Please try again with a new connection URI.`);
            const p = f || xr(ve.FIVE_MINUTES),
                v = {
                    topic: o,
                    relay: l,
                    expiry: p,
                    active: !1
                };
            return await this.pairings.set(o, v), this.core.expirer.set(o, p), s.activatePairing && await this.activate({
                topic: o
            }), this.events.emit(vs.create, v), this.core.crypto.keychain.has(o) || (await this.core.crypto.setSymKey(c, o), await this.core.relayer.subscribe(o, {
                relay: l
            })), v
        }, this.activate = async ({
            topic: s
        }) => {
            this.isInitialized();
            const o = xr(ve.THIRTY_DAYS);
            await this.pairings.update(s, {
                active: !0,
                expiry: o
            }), this.core.expirer.set(s, o)
        }, this.ping = async s => {
            this.isInitialized(), await this.isValidPing(s);
            const {
                topic: o
            } = s;
            if (this.pairings.keys.includes(o)) {
                const c = await this.sendRequest(o, "wc_pairingPing", {}),
                    {
                        done: l,
                        resolve: f,
                        reject: y
                    } = $n();
                this.events.once(Nt("pairing_ping", c), ({
                    error: p
                }) => {
                    p ? y(p) : f()
                }), await l()
            }
        }, this.updateExpiry = async ({
            topic: s,
            expiry: o
        }) => {
            this.isInitialized(), await this.pairings.update(s, {
                expiry: o
            })
        }, this.updateMetadata = async ({
            topic: s,
            metadata: o
        }) => {
            this.isInitialized(), await this.pairings.update(s, {
                peerMetadata: o
            })
        }, this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = async s => {
            this.isInitialized(), await this.isValidDisconnect(s);
            const {
                topic: o
            } = s;
            this.pairings.keys.includes(o) && (await this.sendRequest(o, "wc_pairingDelete", _t("USER_DISCONNECTED")), await this.deletePairing(o))
        }, this.sendRequest = async (s, o, c) => {
            const l = Mn(o, c),
                f = await this.core.crypto.encode(s, l),
                y = ds[o].req;
            return this.core.history.set(s, l), this.core.relayer.publish(s, f, y), l.id
        }, this.sendResult = async (s, o, c) => {
            const l = oa(s, c),
                f = await this.core.crypto.encode(o, l),
                y = await this.core.history.get(o, s),
                p = ds[y.request.method].res;
            await this.core.relayer.publish(o, f, p), await this.core.history.resolve(l)
        }, this.sendError = async (s, o, c) => {
            const l = aa(s, c),
                f = await this.core.crypto.encode(o, l),
                y = await this.core.history.get(o, s),
                p = ds[y.request.method] ? ds[y.request.method].res : ds.unregistered_method.res;
            await this.core.relayer.publish(o, f, p), await this.core.history.resolve(l)
        }, this.deletePairing = async (s, o) => {
            await this.core.relayer.unsubscribe(s), await Promise.all([this.pairings.delete(s, _t("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(s), o ? Promise.resolve() : this.core.expirer.del(s)])
        }, this.cleanup = async () => {
            const s = this.pairings.getAll().filter(o => ji(o.expiry));
            await Promise.all(s.map(o => this.deletePairing(o.topic)))
        }, this.onRelayEventRequest = s => {
            const {
                topic: o,
                payload: c
            } = s;
            switch (c.method) {
                case "wc_pairingPing":
                    return this.onPairingPingRequest(o, c);
                case "wc_pairingDelete":
                    return this.onPairingDeleteRequest(o, c);
                default:
                    return this.onUnknownRpcMethodRequest(o, c)
            }
        }, this.onRelayEventResponse = async s => {
            const {
                topic: o,
                payload: c
            } = s, l = (await this.core.history.get(o, c.id)).request.method;
            switch (l) {
                case "wc_pairingPing":
                    return this.onPairingPingResponse(o, c);
                default:
                    return this.onUnknownRpcMethodResponse(l)
            }
        }, this.onPairingPingRequest = async (s, o) => {
            const {
                id: c
            } = o;
            try {
                this.isValidPing({
                    topic: s
                }), await this.sendResult(c, s, !0), this.events.emit(vs.ping, {
                    id: c,
                    topic: s
                })
            } catch (l) {
                await this.sendError(c, s, l), this.logger.error(l)
            }
        }, this.onPairingPingResponse = (s, o) => {
            const {
                id: c
            } = o;
            setTimeout(() => {
                bi(o) ? this.events.emit(Nt("pairing_ping", c), {}) : Vr(o) && this.events.emit(Nt("pairing_ping", c), {
                    error: o.error
                })
            }, 500)
        }, this.onPairingDeleteRequest = async (s, o) => {
            const {
                id: c
            } = o;
            try {
                this.isValidDisconnect({
                    topic: s
                }), await this.deletePairing(s), this.events.emit(vs.delete, {
                    id: c,
                    topic: s
                })
            } catch (l) {
                await this.sendError(c, s, l), this.logger.error(l)
            }
        }, this.onUnknownRpcMethodRequest = async (s, o) => {
            const {
                id: c,
                method: l
            } = o;
            try {
                if (this.registeredMethods.includes(l)) return;
                const f = _t("WC_METHOD_UNSUPPORTED", l);
                await this.sendError(c, s, f), this.logger.error(f)
            } catch (f) {
                await this.sendError(c, s, f), this.logger.error(f)
            }
        }, this.onUnknownRpcMethodResponse = s => {
            this.registeredMethods.includes(s) || this.logger.error(_t("WC_METHOD_UNSUPPORTED", s))
        }, this.isValidPair = s => {
            var o;
            if (!_r(s)) {
                const {
                    message: l
                } = ce("MISSING_OR_INVALID", `pair() params: ${s}`);
                throw new Error(l)
            }
            if (!NE(s.uri)) {
                const {
                    message: l
                } = ce("MISSING_OR_INVALID", `pair() uri: ${s.uri}`);
                throw new Error(l)
            }
            const c = Of(s.uri);
            if (!((o = c == null ? void 0 : c.relay) != null && o.protocol)) {
                const {
                    message: l
                } = ce("MISSING_OR_INVALID", "pair() uri#relay-protocol");
                throw new Error(l)
            }
            if (!(c != null && c.symKey)) {
                const {
                    message: l
                } = ce("MISSING_OR_INVALID", "pair() uri#symKey");
                throw new Error(l)
            }
            if (c != null && c.expiryTimestamp && ve.toMiliseconds(c == null ? void 0 : c.expiryTimestamp) < Date.now()) {
                const {
                    message: l
                } = ce("EXPIRED", "pair() URI has expired. Please try again with a new connection URI.");
                throw new Error(l)
            }
        }, this.isValidPing = async s => {
            if (!_r(s)) {
                const {
                    message: c
                } = ce("MISSING_OR_INVALID", `ping() params: ${s}`);
                throw new Error(c)
            }
            const {
                topic: o
            } = s;
            await this.isValidPairingTopic(o)
        }, this.isValidDisconnect = async s => {
            if (!_r(s)) {
                const {
                    message: c
                } = ce("MISSING_OR_INVALID", `disconnect() params: ${s}`);
                throw new Error(c)
            }
            const {
                topic: o
            } = s;
            await this.isValidPairingTopic(o)
        }, this.isValidPairingTopic = async s => {
            if (!Vt(s, !1)) {
                const {
                    message: o
                } = ce("MISSING_OR_INVALID", `pairing topic should be a string: ${s}`);
                throw new Error(o)
            }
            if (!this.pairings.keys.includes(s)) {
                const {
                    message: o
                } = ce("NO_MATCHING_KEY", `pairing topic doesn't exist: ${s}`);
                throw new Error(o)
            }
            if (ji(this.pairings.get(s).expiry)) {
                await this.deletePairing(s);
                const {
                    message: o
                } = ce("EXPIRED", `pairing topic: ${s}`);
                throw new Error(o)
            }
        }, this.core = e, this.logger = Ye.generateChildLogger(t, this.name), this.pairings = new ha(this.core, this.logger, this.name, this.storagePrefix)
    }
    get context() {
        return Ye.getLoggerContext(this.logger)
    }
    isInitialized() {
        if (!this.initialized) {
            const {
                message: e
            } = ce("NOT_INITIALIZED", this.name);
            throw new Error(e)
        }
    }
    registerRelayerEvents() {
        this.core.relayer.on(Zt.message, async e => {
            const {
                topic: t,
                message: s
            } = e;
            if (!this.pairings.keys.includes(t) || this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(s))) return;
            const o = await this.core.crypto.decode(t, s);
            try {
                Wu(o) ? (this.core.history.set(t, o), this.onRelayEventRequest({
                    topic: t,
                    payload: o
                })) : ca(o) && (await this.core.history.resolve(o), await this.onRelayEventResponse({
                    topic: t,
                    payload: o
                }), this.core.history.delete(t, o.id))
            } catch (c) {
                this.logger.error(c)
            }
        })
    }
    registerExpirerEvents() {
        this.core.expirer.on(Mr.expired, async e => {
            const {
                topic: t
            } = sp(e.target);
            t && this.pairings.keys.includes(t) && (await this.deletePairing(t, !0), this.events.emit(vs.expire, {
                topic: t
            }))
        })
    }
}
class y6 extends C3 {
    constructor(e, t) {
        super(e, t), this.core = e, this.logger = t, this.records = new Map, this.events = new Ur.EventEmitter, this.name = B2, this.version = K2, this.cached = [], this.initialized = !1, this.storagePrefix = Li, this.init = async () => {
            this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach(s => this.records.set(s.id, s)), this.cached = [], this.registerEventListeners(), this.initialized = !0)
        }, this.set = (s, o, c) => {
            if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({
                    type: "method",
                    method: "set",
                    topic: s,
                    request: o,
                    chainId: c
                }), this.records.has(o.id)) return;
            const l = {
                id: o.id,
                topic: s,
                request: {
                    method: o.method,
                    params: o.params || null
                },
                chainId: c,
                expiry: xr(ve.THIRTY_DAYS)
            };
            this.records.set(l.id, l), this.events.emit(ti.created, l)
        }, this.resolve = async s => {
            if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({
                    type: "method",
                    method: "update",
                    response: s
                }), !this.records.has(s.id)) return;
            const o = await this.getRecord(s.id);
            typeof o.response > "u" && (o.response = Vr(s) ? {
                error: s.error
            } : {
                result: s.result
            }, this.records.set(o.id, o), this.events.emit(ti.updated, o))
        }, this.get = async (s, o) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({
            type: "method",
            method: "get",
            topic: s,
            id: o
        }), await this.getRecord(o)), this.delete = (s, o) => {
            this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({
                type: "method",
                method: "delete",
                id: o
            }), this.values.forEach(c => {
                if (c.topic === s) {
                    if (typeof o < "u" && c.id !== o) return;
                    this.records.delete(c.id), this.events.emit(ti.deleted, c)
                }
            })
        }, this.exists = async (s, o) => (this.isInitialized(), this.records.has(o) ? (await this.getRecord(o)).topic === s : !1), this.on = (s, o) => {
            this.events.on(s, o)
        }, this.once = (s, o) => {
            this.events.once(s, o)
        }, this.off = (s, o) => {
            this.events.off(s, o)
        }, this.removeListener = (s, o) => {
            this.events.removeListener(s, o)
        }, this.logger = Ye.generateChildLogger(t, this.name)
    }
    get context() {
        return Ye.getLoggerContext(this.logger)
    }
    get storageKey() {
        return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name
    }
    get size() {
        return this.records.size
    }
    get keys() {
        return Array.from(this.records.keys())
    }
    get values() {
        return Array.from(this.records.values())
    }
    get pending() {
        const e = [];
        return this.values.forEach(t => {
            if (typeof t.response < "u") return;
            const s = {
                topic: t.topic,
                request: Mn(t.request.method, t.request.params, t.id),
                chainId: t.chainId
            };
            return e.push(s)
        }), e
    }
    async setJsonRpcRecords(e) {
        await this.core.storage.setItem(this.storageKey, e)
    }
    async getJsonRpcRecords() {
        return await this.core.storage.getItem(this.storageKey)
    }
    getRecord(e) {
        this.isInitialized();
        const t = this.records.get(e);
        if (!t) {
            const {
                message: s
            } = ce("NO_MATCHING_KEY", `${this.name}: ${e}`);
            throw new Error(s)
        }
        return t
    }
    async persist() {
        await this.setJsonRpcRecords(this.values), this.events.emit(ti.sync)
    }
    async restore() {
        try {
            const e = await this.getJsonRpcRecords();
            if (typeof e > "u" || !e.length) return;
            if (this.records.size) {
                const {
                    message: t
                } = ce("RESTORE_WILL_OVERRIDE", this.name);
                throw this.logger.error(t), new Error(t)
            }
            this.cached = e, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({
                type: "method",
                method: "restore",
                records: this.values
            })
        } catch (e) {
            this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e)
        }
    }
    registerEventListeners() {
        this.events.on(ti.created, e => {
            const t = ti.created;
            this.logger.info(`Emitting ${t}`), this.logger.debug({
                type: "event",
                event: t,
                record: e
            }), this.persist()
        }), this.events.on(ti.updated, e => {
            const t = ti.updated;
            this.logger.info(`Emitting ${t}`), this.logger.debug({
                type: "event",
                event: t,
                record: e
            }), this.persist()
        }), this.events.on(ti.deleted, e => {
            const t = ti.deleted;
            this.logger.info(`Emitting ${t}`), this.logger.debug({
                type: "event",
                event: t,
                record: e
            }), this.persist()
        }), this.core.heartbeat.on(Bn.HEARTBEAT_EVENTS.pulse, () => {
            this.cleanup()
        })
    }
    cleanup() {
        try {
            this.records.forEach(e => {
                ve.toMiliseconds(e.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${e.id}`), this.delete(e.topic, e.id))
            })
        } catch (e) {
            this.logger.warn(e)
        }
    }
    isInitialized() {
        if (!this.initialized) {
            const {
                message: e
            } = ce("NOT_INITIALIZED", this.name);
            throw new Error(e)
        }
    }
}
class v6 extends j3 {
    constructor(e, t) {
        super(e, t), this.core = e, this.logger = t, this.expirations = new Map, this.events = new Ur.EventEmitter, this.name = k2, this.version = V2, this.cached = [], this.initialized = !1, this.storagePrefix = Li, this.init = async () => {
            this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach(s => this.expirations.set(s.target, s)), this.cached = [], this.registerEventListeners(), this.initialized = !0)
        }, this.has = s => {
            try {
                const o = this.formatTarget(s);
                return typeof this.getExpiration(o) < "u"
            } catch {
                return !1
            }
        }, this.set = (s, o) => {
            this.isInitialized();
            const c = this.formatTarget(s),
                l = {
                    target: c,
                    expiry: o
                };
            this.expirations.set(c, l), this.checkExpiry(c, l), this.events.emit(Mr.created, {
                target: c,
                expiration: l
            })
        }, this.get = s => {
            this.isInitialized();
            const o = this.formatTarget(s);
            return this.getExpiration(o)
        }, this.del = s => {
            if (this.isInitialized(), this.has(s)) {
                const o = this.formatTarget(s),
                    c = this.getExpiration(o);
                this.expirations.delete(o), this.events.emit(Mr.deleted, {
                    target: o,
                    expiration: c
                })
            }
        }, this.on = (s, o) => {
            this.events.on(s, o)
        }, this.once = (s, o) => {
            this.events.once(s, o)
        }, this.off = (s, o) => {
            this.events.off(s, o)
        }, this.removeListener = (s, o) => {
            this.events.removeListener(s, o)
        }, this.logger = Ye.generateChildLogger(t, this.name)
    }
    get context() {
        return Ye.getLoggerContext(this.logger)
    }
    get storageKey() {
        return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name
    }
    get length() {
        return this.expirations.size
    }
    get keys() {
        return Array.from(this.expirations.keys())
    }
    get values() {
        return Array.from(this.expirations.values())
    }
    formatTarget(e) {
        if (typeof e == "string") return hE(e);
        if (typeof e == "number") return lE(e);
        const {
            message: t
        } = ce("UNKNOWN_TYPE", `Target type: ${typeof e}`);
        throw new Error(t)
    }
    async setExpirations(e) {
        await this.core.storage.setItem(this.storageKey, e)
    }
    async getExpirations() {
        return await this.core.storage.getItem(this.storageKey)
    }
    async persist() {
        await this.setExpirations(this.values), this.events.emit(Mr.sync)
    }
    async restore() {
        try {
            const e = await this.getExpirations();
            if (typeof e > "u" || !e.length) return;
            if (this.expirations.size) {
                const {
                    message: t
                } = ce("RESTORE_WILL_OVERRIDE", this.name);
                throw this.logger.error(t), new Error(t)
            }
            this.cached = e, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({
                type: "method",
                method: "restore",
                expirations: this.values
            })
        } catch (e) {
            this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e)
        }
    }
    getExpiration(e) {
        const t = this.expirations.get(e);
        if (!t) {
            const {
                message: s
            } = ce("NO_MATCHING_KEY", `${this.name}: ${e}`);
            throw this.logger.error(s), new Error(s)
        }
        return t
    }
    checkExpiry(e, t) {
        const {
            expiry: s
        } = t;
        ve.toMiliseconds(s) - Date.now() <= 0 && this.expire(e, t)
    }
    expire(e, t) {
        this.expirations.delete(e), this.events.emit(Mr.expired, {
            target: e,
            expiration: t
        })
    }
    checkExpirations() {
        this.core.relayer.connected && this.expirations.forEach((e, t) => this.checkExpiry(t, e))
    }
    registerEventListeners() {
        this.core.heartbeat.on(Bn.HEARTBEAT_EVENTS.pulse, () => this.checkExpirations()), this.events.on(Mr.created, e => {
            const t = Mr.created;
            this.logger.info(`Emitting ${t}`), this.logger.debug({
                type: "event",
                event: t,
                data: e
            }), this.persist()
        }), this.events.on(Mr.expired, e => {
            const t = Mr.expired;
            this.logger.info(`Emitting ${t}`), this.logger.debug({
                type: "event",
                event: t,
                data: e
            }), this.persist()
        }), this.events.on(Mr.deleted, e => {
            const t = Mr.deleted;
            this.logger.info(`Emitting ${t}`), this.logger.debug({
                type: "event",
                event: t,
                data: e
            }), this.persist()
        })
    }
    isInitialized() {
        if (!this.initialized) {
            const {
                message: e
            } = ce("NOT_INITIALIZED", this.name);
            throw new Error(e)
        }
    }
}
class _6 extends L3 {
    constructor(e, t) {
        super(e, t), this.projectId = e, this.logger = t, this.name = Jc, this.initialized = !1, this.queue = [], this.verifyDisabled = !1, this.init = async s => {
            if (this.verifyDisabled || zn() || !Fn()) return;
            const o = this.getVerifyUrl(s == null ? void 0 : s.verifyUrl);
            this.verifyUrl !== o && this.removeIframe(), this.verifyUrl = o;
            try {
                await this.createIframe()
            } catch (c) {
                this.logger.info(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.info(c)
            }
            if (!this.initialized) {
                this.removeIframe(), this.verifyUrl = xu;
                try {
                    await this.createIframe()
                } catch (c) {
                    this.logger.info(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.info(c), this.verifyDisabled = !0
                }
            }
        }, this.register = async s => {
            this.initialized ? this.sendPost(s.attestationId) : (this.addToQueue(s.attestationId), await this.init())
        }, this.resolve = async s => {
            if (this.isDevEnv) return "";
            const o = this.getVerifyUrl(s == null ? void 0 : s.verifyUrl);
            let c;
            try {
                c = await this.fetchAttestation(s.attestationId, o)
            } catch (l) {
                this.logger.info(`failed to resolve attestation: ${s.attestationId} from url: ${o}`), this.logger.info(l), c = await this.fetchAttestation(s.attestationId, xu)
            }
            return c
        }, this.fetchAttestation = async (s, o) => {
            this.logger.info(`resolving attestation: ${s} from url: ${o}`);
            const c = this.startAbortTimer(ve.ONE_SECOND * 2),
                l = await fetch(`${o}/attestation/${s}`, {
                    signal: this.abortController.signal
                });
            return clearTimeout(c), l.status === 200 ? await l.json() : void 0
        }, this.addToQueue = s => {
            this.queue.push(s)
        }, this.processQueue = () => {
            this.queue.length !== 0 && (this.queue.forEach(s => this.sendPost(s)), this.queue = [])
        }, this.sendPost = s => {
            var o;
            try {
                if (!this.iframe) return;
                (o = this.iframe.contentWindow) == null || o.postMessage(s, "*"), this.logger.info(`postMessage sent: ${s} ${this.verifyUrl}`)
            } catch {}
        }, this.createIframe = async () => {
            let s;
            const o = c => {
                c.data === "verify_ready" && (this.initialized = !0, this.processQueue(), window.removeEventListener("message", o), s())
            };
            await Promise.race([new Promise(c => {
                if (document.getElementById(Jc)) return c();
                window.addEventListener("message", o);
                const l = document.createElement("iframe");
                l.id = Jc, l.src = `${this.verifyUrl}/${this.projectId}`, l.style.display = "none", document.body.append(l), this.iframe = l, s = c
            }), new Promise((c, l) => setTimeout(() => {
                window.removeEventListener("message", o), l("verify iframe load timeout")
            }, ve.toMiliseconds(ve.FIVE_SECONDS)))])
        }, this.removeIframe = () => {
            this.iframe && (this.iframe.remove(), this.iframe = void 0, this.initialized = !1)
        }, this.getVerifyUrl = s => {
            let o = s || jn;
            return G2.includes(o) || (this.logger.info(`verify url: ${o}, not included in trusted list, assigning default: ${jn}`), o = jn), o
        }, this.logger = Ye.generateChildLogger(t, this.name), this.verifyUrl = jn, this.abortController = new AbortController, this.isDevEnv = Hu() && WS.IS_VITEST
    }
    get context() {
        return Ye.getLoggerContext(this.logger)
    }
    startAbortTimer(e) {
        return this.abortController = new AbortController, setTimeout(() => this.abortController.abort(), ve.toMiliseconds(e))
    }
}
class m6 extends M3 {
    constructor(e, t) {
        super(e, t), this.projectId = e, this.logger = t, this.context = W2, this.registerDeviceToken = async s => {
            const {
                clientId: o,
                token: c,
                notificationType: l,
                enableEncrypted: f = !1
            } = s, y = `${Y2}/${this.projectId}/clients`;
            await GS(y, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    client_id: o,
                    type: l,
                    token: c,
                    always_raw: f
                })
            })
        }, this.logger = Ye.generateChildLogger(t, this.context)
    }
}
var b6 = Object.defineProperty,
    vd = Object.getOwnPropertySymbols,
    w6 = Object.prototype.hasOwnProperty,
    E6 = Object.prototype.propertyIsEnumerable,
    _d = (i, e, t) => e in i ? b6(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t,
    md = (i, e) => {
        for (var t in e || (e = {})) w6.call(e, t) && _d(i, t, e[t]);
        if (vd)
            for (var t of vd(e)) E6.call(e, t) && _d(i, t, e[t]);
        return i
    };
class Ju extends P3 {
    constructor(e) {
        super(e), this.protocol = Up, this.version = m2, this.name = Yu, this.events = new Ur.EventEmitter, this.initialized = !1, this.on = (s, o) => this.events.on(s, o), this.once = (s, o) => this.events.once(s, o), this.off = (s, o) => this.events.off(s, o), this.removeListener = (s, o) => this.events.removeListener(s, o), this.projectId = e == null ? void 0 : e.projectId, this.relayUrl = (e == null ? void 0 : e.relayUrl) || zp, this.customStoragePrefix = e != null && e.customStoragePrefix ? `:${e.customStoragePrefix}` : "";
        const t = typeof(e == null ? void 0 : e.logger) < "u" && typeof(e == null ? void 0 : e.logger) != "string" ? e.logger : Ye.pino(Ye.getDefaultLoggerOptions({
            level: (e == null ? void 0 : e.logger) || b2.logger
        }));
        this.logger = Ye.generateChildLogger(t, this.name), this.heartbeat = new Bn.HeartBeat, this.crypto = new Q2(this, this.logger, e == null ? void 0 : e.keychain), this.history = new y6(this, this.logger), this.expirer = new v6(this, this.logger), this.storage = e != null && e.storage ? e.storage : new RD(md(md({}, w2), e == null ? void 0 : e.storageOptions)), this.relayer = new l6({
            core: this,
            logger: this.logger,
            relayUrl: this.relayUrl,
            projectId: this.projectId
        }), this.pairing = new g6(this, this.logger), this.verify = new _6(this.projectId || "", this.logger), this.echoClient = new m6(this.projectId || "", this.logger)
    }
    static async init(e) {
        const t = new Ju(e);
        await t.initialize();
        const s = await t.crypto.getClientId();
        return await t.storage.setItem(M2, s), t
    }
    get context() {
        return Ye.getLoggerContext(this.logger)
    }
    async start() {
        this.initialized || await this.initialize()
    }
    async initialize() {
        this.logger.trace("Initialized");
        try {
            await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.initialized = !0, this.logger.info("Core Initialization Success")
        } catch (e) {
            throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e), this.logger.error(e.message), e
        }
    }
}
const D6 = Ju,
    Fp = "wc",
    Hp = 2,
    Bp = "client",
    Qu = `${Fp}@${Hp}:${Bp}:`,
    Xc = {
        name: Bp,
        logger: "error",
        controller: !1,
        relayUrl: "wss://relay.walletconnect.com"
    },
    bd = "WALLETCONNECT_DEEPLINK_CHOICE",
    S6 = "proposal",
    Kp = "Proposal expired",
    I6 = "session",
    Bo = ve.SEVEN_DAYS,
    x6 = "engine",
    _i = {
        wc_sessionPropose: {
            req: {
                ttl: ve.FIVE_MINUTES,
                prompt: !0,
                tag: 1100
            },
            res: {
                ttl: ve.FIVE_MINUTES,
                prompt: !1,
                tag: 1101
            }
        },
        wc_sessionSettle: {
            req: {
                ttl: ve.FIVE_MINUTES,
                prompt: !1,
                tag: 1102
            },
            res: {
                ttl: ve.FIVE_MINUTES,
                prompt: !1,
                tag: 1103
            }
        },
        wc_sessionUpdate: {
            req: {
                ttl: ve.ONE_DAY,
                prompt: !1,
                tag: 1104
            },
            res: {
                ttl: ve.ONE_DAY,
                prompt: !1,
                tag: 1105
            }
        },
        wc_sessionExtend: {
            req: {
                ttl: ve.ONE_DAY,
                prompt: !1,
                tag: 1106
            },
            res: {
                ttl: ve.ONE_DAY,
                prompt: !1,
                tag: 1107
            }
        },
        wc_sessionRequest: {
            req: {
                ttl: ve.FIVE_MINUTES,
                prompt: !0,
                tag: 1108
            },
            res: {
                ttl: ve.FIVE_MINUTES,
                prompt: !1,
                tag: 1109
            }
        },
        wc_sessionEvent: {
            req: {
                ttl: ve.FIVE_MINUTES,
                prompt: !0,
                tag: 1110
            },
            res: {
                ttl: ve.FIVE_MINUTES,
                prompt: !1,
                tag: 1111
            }
        },
        wc_sessionDelete: {
            req: {
                ttl: ve.ONE_DAY,
                prompt: !1,
                tag: 1112
            },
            res: {
                ttl: ve.ONE_DAY,
                prompt: !1,
                tag: 1113
            }
        },
        wc_sessionPing: {
            req: {
                ttl: ve.THIRTY_SECONDS,
                prompt: !1,
                tag: 1114
            },
            res: {
                ttl: ve.THIRTY_SECONDS,
                prompt: !1,
                tag: 1115
            }
        }
    },
    Zc = {
        min: ve.FIVE_MINUTES,
        max: ve.SEVEN_DAYS
    },
    mi = {
        idle: "IDLE",
        active: "ACTIVE"
    },
    O6 = "request",
    P6 = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest"];
var C6 = Object.defineProperty,
    T6 = Object.defineProperties,
    A6 = Object.getOwnPropertyDescriptors,
    wd = Object.getOwnPropertySymbols,
    R6 = Object.prototype.hasOwnProperty,
    N6 = Object.prototype.propertyIsEnumerable,
    Ed = (i, e, t) => e in i ? C6(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t,
    ar = (i, e) => {
        for (var t in e || (e = {})) R6.call(e, t) && Ed(i, t, e[t]);
        if (wd)
            for (var t of wd(e)) N6.call(e, t) && Ed(i, t, e[t]);
        return i
    },
    Nn = (i, e) => T6(i, A6(e));
class $6 extends q3 {
    constructor(e) {
        super(e), this.name = x6, this.events = new Ru, this.initialized = !1, this.ignoredPayloadTypes = [cn], this.requestQueue = {
            state: mi.idle,
            queue: []
        }, this.sessionRequestQueue = {
            state: mi.idle,
            queue: []
        }, this.requestQueueDelay = ve.ONE_SECOND, this.init = async () => {
            this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), this.client.core.pairing.register({
                methods: Object.keys(_i)
            }), this.initialized = !0, setTimeout(() => {
                this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue()
            }, ve.toMiliseconds(this.requestQueueDelay)))
        }, this.connect = async t => {
            await this.isInitialized();
            const s = Nn(ar({}, t), {
                requiredNamespaces: t.requiredNamespaces || {},
                optionalNamespaces: t.optionalNamespaces || {}
            });
            await this.isValidConnect(s);
            const {
                pairingTopic: o,
                requiredNamespaces: c,
                optionalNamespaces: l,
                sessionProperties: f,
                relays: y
            } = s;
            let p = o,
                v, D = !1;
            if (p && (D = this.client.core.pairing.pairings.get(p).active), !p || !D) {
                const {
                    topic: C,
                    uri: A
                } = await this.client.core.pairing.create();
                p = C, v = A
            }
            const S = await this.client.core.crypto.generateKeyPair(),
                x = _i.wc_sessionPropose.req.ttl || ve.FIVE_MINUTES,
                O = xr(x),
                F = ar({
                    requiredNamespaces: c,
                    optionalNamespaces: l,
                    relays: y ? ? [{
                        protocol: qp
                    }],
                    proposer: {
                        publicKey: S,
                        metadata: this.client.metadata
                    },
                    expiryTimestamp: O
                }, f && {
                    sessionProperties: f
                }),
                {
                    reject: K,
                    resolve: ne,
                    done: $
                } = $n(x, Kp);
            if (this.events.once(Nt("session_connect"), async ({
                    error: C,
                    session: A
                }) => {
                    if (C) K(C);
                    else if (A) {
                        A.self.publicKey = S;
                        const E = Nn(ar({}, A), {
                            requiredNamespaces: F.requiredNamespaces,
                            optionalNamespaces: F.optionalNamespaces
                        });
                        await this.client.session.set(A.topic, E), await this.setExpiry(A.topic, A.expiry), p && await this.client.core.pairing.updateMetadata({
                            topic: p,
                            metadata: A.peer.metadata
                        }), ne(E)
                    }
                }), !p) {
                const {
                    message: C
                } = ce("NO_MATCHING_KEY", `connect() pairing topic: ${p}`);
                throw new Error(C)
            }
            const U = await this.sendRequest({
                topic: p,
                method: "wc_sessionPropose",
                params: F,
                throwOnFailedPublish: !0
            });
            return await this.setProposal(U, ar({
                id: U
            }, F)), {
                uri: v,
                approval: $
            }
        }, this.pair = async t => (await this.isInitialized(), await this.client.core.pairing.pair(t)), this.approve = async t => {
            await this.isInitialized(), await this.isValidApprove(t);
            const {
                id: s,
                relayProtocol: o,
                namespaces: c,
                sessionProperties: l
            } = t, f = this.client.proposal.get(s);
            let {
                pairingTopic: y,
                proposer: p,
                requiredNamespaces: v,
                optionalNamespaces: D
            } = f;
            y = y || "";
            const S = await this.client.core.crypto.generateKeyPair(),
                x = p.publicKey,
                O = await this.client.core.crypto.generateSharedKey(S, x);
            y && s && (await this.client.core.pairing.updateMetadata({
                topic: y,
                metadata: p.metadata
            }), await this.sendResult({
                id: s,
                topic: y,
                result: {
                    relay: {
                        protocol: o ? ? "irn"
                    },
                    responderPublicKey: S
                }
            }), await this.client.proposal.delete(s, _t("USER_DISCONNECTED")), await this.client.core.pairing.activate({
                topic: y
            }));
            const F = ar({
                relay: {
                    protocol: o ? ? "irn"
                },
                namespaces: c,
                pairingTopic: y,
                controller: {
                    publicKey: S,
                    metadata: this.client.metadata
                },
                expiry: xr(Bo)
            }, l && {
                sessionProperties: l
            });
            await this.client.core.relayer.subscribe(O);
            const K = Nn(ar({}, F), {
                topic: O,
                requiredNamespaces: v,
                optionalNamespaces: D,
                pairingTopic: y,
                acknowledged: !1,
                self: F.controller,
                peer: {
                    publicKey: p.publicKey,
                    metadata: p.metadata
                },
                controller: S
            });
            await this.client.session.set(O, K);
            try {
                await this.sendRequest({
                    topic: O,
                    method: "wc_sessionSettle",
                    params: F,
                    throwOnFailedPublish: !0
                })
            } catch (ne) {
                throw this.client.logger.error(ne), this.client.session.delete(O, _t("USER_DISCONNECTED")), await this.client.core.relayer.unsubscribe(O), ne
            }
            return await this.setExpiry(O, xr(Bo)), {
                topic: O,
                acknowledged: () => new Promise(ne => setTimeout(() => ne(this.client.session.get(O)), 500))
            }
        }, this.reject = async t => {
            await this.isInitialized(), await this.isValidReject(t);
            const {
                id: s,
                reason: o
            } = t, {
                pairingTopic: c
            } = this.client.proposal.get(s);
            c && (await this.sendError(s, c, o), await this.client.proposal.delete(s, _t("USER_DISCONNECTED")))
        }, this.update = async t => {
            await this.isInitialized(), await this.isValidUpdate(t);
            const {
                topic: s,
                namespaces: o
            } = t, c = await this.sendRequest({
                topic: s,
                method: "wc_sessionUpdate",
                params: {
                    namespaces: o
                }
            }), {
                done: l,
                resolve: f,
                reject: y
            } = $n();
            return this.events.once(Nt("session_update", c), ({
                error: p
            }) => {
                p ? y(p) : f()
            }), await this.client.session.update(s, {
                namespaces: o
            }), {
                acknowledged: l
            }
        }, this.extend = async t => {
            await this.isInitialized(), await this.isValidExtend(t);
            const {
                topic: s
            } = t, o = await this.sendRequest({
                topic: s,
                method: "wc_sessionExtend",
                params: {}
            }), {
                done: c,
                resolve: l,
                reject: f
            } = $n();
            return this.events.once(Nt("session_extend", o), ({
                error: y
            }) => {
                y ? f(y) : l()
            }), await this.setExpiry(s, xr(Bo)), {
                acknowledged: c
            }
        }, this.request = async t => {
            await this.isInitialized(), await this.isValidRequest(t);
            const {
                chainId: s,
                request: o,
                topic: c,
                expiry: l = _i.wc_sessionRequest.req.ttl
            } = t, f = Gu(), {
                done: y,
                resolve: p,
                reject: v
            } = $n(l, "Request expired. Please try again.");
            return this.events.once(Nt("session_request", f), ({
                error: D,
                result: S
            }) => {
                D ? v(D) : p(S)
            }), await Promise.all([new Promise(async D => {
                await this.sendRequest({
                    clientRpcId: f,
                    topic: c,
                    method: "wc_sessionRequest",
                    params: {
                        request: Nn(ar({}, o), {
                            expiryTimestamp: xr(l)
                        }),
                        chainId: s
                    },
                    expiry: l,
                    throwOnFailedPublish: !0
                }).catch(S => v(S)), this.client.events.emit("session_request_sent", {
                    topic: c,
                    request: o,
                    chainId: s,
                    id: f
                }), D()
            }), new Promise(async D => {
                const S = await dE(this.client.core.storage, bd);
                fE({
                    id: f,
                    topic: c,
                    wcDeepLink: S
                }), D()
            }), y()]).then(D => D[2])
        }, this.respond = async t => {
            await this.isInitialized(), await this.isValidRespond(t);
            const {
                topic: s,
                response: o
            } = t, {
                id: c
            } = o;
            bi(o) ? await this.sendResult({
                id: c,
                topic: s,
                result: o.result,
                throwOnFailedPublish: !0
            }) : Vr(o) && await this.sendError(c, s, o.error), this.cleanupAfterResponse(t)
        }, this.ping = async t => {
            await this.isInitialized(), await this.isValidPing(t);
            const {
                topic: s
            } = t;
            if (this.client.session.keys.includes(s)) {
                const o = await this.sendRequest({
                        topic: s,
                        method: "wc_sessionPing",
                        params: {}
                    }),
                    {
                        done: c,
                        resolve: l,
                        reject: f
                    } = $n();
                this.events.once(Nt("session_ping", o), ({
                    error: y
                }) => {
                    y ? f(y) : l()
                }), await c()
            } else this.client.core.pairing.pairings.keys.includes(s) && await this.client.core.pairing.ping({
                topic: s
            })
        }, this.emit = async t => {
            await this.isInitialized(), await this.isValidEmit(t);
            const {
                topic: s,
                event: o,
                chainId: c
            } = t;
            await this.sendRequest({
                topic: s,
                method: "wc_sessionEvent",
                params: {
                    event: o,
                    chainId: c
                }
            })
        }, this.disconnect = async t => {
            await this.isInitialized(), await this.isValidDisconnect(t);
            const {
                topic: s
            } = t;
            if (this.client.session.keys.includes(s)) await this.sendRequest({
                topic: s,
                method: "wc_sessionDelete",
                params: _t("USER_DISCONNECTED"),
                throwOnFailedPublish: !0
            }), await this.deleteSession({
                topic: s,
                emitEvent: !1
            });
            else if (this.client.core.pairing.pairings.keys.includes(s)) await this.client.core.pairing.disconnect({
                topic: s
            });
            else {
                const {
                    message: o
                } = ce("MISMATCHED_TOPIC", `Session or pairing topic not found: ${s}`);
                throw new Error(o)
            }
        }, this.find = t => (this.isInitialized(), this.client.session.getAll().filter(s => AE(s, t))), this.getPendingSessionRequests = () => this.client.pendingRequest.getAll(), this.cleanupDuplicatePairings = async t => {
            if (t.pairingTopic) try {
                const s = this.client.core.pairing.pairings.get(t.pairingTopic),
                    o = this.client.core.pairing.pairings.getAll().filter(c => {
                        var l, f;
                        return ((l = c.peerMetadata) == null ? void 0 : l.url) && ((f = c.peerMetadata) == null ? void 0 : f.url) === t.peer.metadata.url && c.topic && c.topic !== s.topic
                    });
                if (o.length === 0) return;
                this.client.logger.info(`Cleaning up ${o.length} duplicate pairing(s)`), await Promise.all(o.map(c => this.client.core.pairing.disconnect({
                    topic: c.topic
                }))), this.client.logger.info("Duplicate pairings clean up finished")
            } catch (s) {
                this.client.logger.error(s)
            }
        }, this.deleteSession = async t => {
            const {
                topic: s,
                expirerHasDeleted: o = !1,
                emitEvent: c = !0,
                id: l = 0
            } = t, {
                self: f
            } = this.client.session.get(s);
            await this.client.core.relayer.unsubscribe(s), await this.client.session.delete(s, _t("USER_DISCONNECTED")), this.client.core.crypto.keychain.has(f.publicKey) && await this.client.core.crypto.deleteKeyPair(f.publicKey), this.client.core.crypto.keychain.has(s) && await this.client.core.crypto.deleteSymKey(s), o || this.client.core.expirer.del(s), this.client.core.storage.removeItem(bd).catch(y => this.client.logger.warn(y)), this.getPendingSessionRequests().forEach(y => {
                y.topic === s && this.deletePendingSessionRequest(y.id, _t("USER_DISCONNECTED"))
            }), c && this.client.events.emit("session_delete", {
                id: l,
                topic: s
            })
        }, this.deleteProposal = async (t, s) => {
            await Promise.all([this.client.proposal.delete(t, _t("USER_DISCONNECTED")), s ? Promise.resolve() : this.client.core.expirer.del(t)])
        }, this.deletePendingSessionRequest = async (t, s, o = !1) => {
            await Promise.all([this.client.pendingRequest.delete(t, s), o ? Promise.resolve() : this.client.core.expirer.del(t)]), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter(c => c.id !== t), o && (this.sessionRequestQueue.state = mi.idle, this.client.events.emit("session_request_expire", {
                id: t
            }))
        }, this.setExpiry = async (t, s) => {
            this.client.session.keys.includes(t) && await this.client.session.update(t, {
                expiry: s
            }), this.client.core.expirer.set(t, s)
        }, this.setProposal = async (t, s) => {
            await this.client.proposal.set(t, s), this.client.core.expirer.set(t, xr(_i.wc_sessionPropose.req.ttl))
        }, this.setPendingSessionRequest = async t => {
            const {
                id: s,
                topic: o,
                params: c,
                verifyContext: l
            } = t, f = c.request.expiryTimestamp || xr(_i.wc_sessionRequest.req.ttl);
            await this.client.pendingRequest.set(s, {
                id: s,
                topic: o,
                params: c,
                verifyContext: l
            }), f && this.client.core.expirer.set(s, f)
        }, this.sendRequest = async t => {
            const {
                topic: s,
                method: o,
                params: c,
                expiry: l,
                relayRpcId: f,
                clientRpcId: y,
                throwOnFailedPublish: p
            } = t, v = Mn(o, c, y);
            if (Fn() && P6.includes(o)) {
                const x = Ln(JSON.stringify(v));
                this.client.core.verify.register({
                    attestationId: x
                })
            }
            const D = await this.client.core.crypto.encode(s, v),
                S = _i[o].req;
            return l && (S.ttl = l), f && (S.id = f), this.client.core.history.set(s, v), p ? (S.internal = Nn(ar({}, S.internal), {
                throwOnFailedPublish: !0
            }), await this.client.core.relayer.publish(s, D, S)) : this.client.core.relayer.publish(s, D, S).catch(x => this.client.logger.error(x)), v.id
        }, this.sendResult = async t => {
            const {
                id: s,
                topic: o,
                result: c,
                throwOnFailedPublish: l
            } = t, f = oa(s, c), y = await this.client.core.crypto.encode(o, f), p = await this.client.core.history.get(o, s), v = _i[p.request.method].res;
            l ? (v.internal = Nn(ar({}, v.internal), {
                throwOnFailedPublish: !0
            }), await this.client.core.relayer.publish(o, y, v)) : this.client.core.relayer.publish(o, y, v).catch(D => this.client.logger.error(D)), await this.client.core.history.resolve(f)
        }, this.sendError = async (t, s, o) => {
            const c = aa(t, o),
                l = await this.client.core.crypto.encode(s, c),
                f = await this.client.core.history.get(s, t),
                y = _i[f.request.method].res;
            this.client.core.relayer.publish(s, l, y), await this.client.core.history.resolve(c)
        }, this.cleanup = async () => {
            const t = [],
                s = [];
            this.client.session.getAll().forEach(o => {
                let c = !1;
                ji(o.expiry) && (c = !0), this.client.core.crypto.keychain.has(o.topic) || (c = !0), c && t.push(o.topic)
            }), this.client.proposal.getAll().forEach(o => {
                ji(o.expiryTimestamp) && s.push(o.id)
            }), await Promise.all([...t.map(o => this.deleteSession({
                topic: o
            })), ...s.map(o => this.deleteProposal(o))])
        }, this.onRelayEventRequest = async t => {
            this.requestQueue.queue.push(t), await this.processRequestsQueue()
        }, this.processRequestsQueue = async () => {
            if (this.requestQueue.state === mi.active) {
                this.client.logger.info("Request queue already active, skipping...");
                return
            }
            for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0;) {
                this.requestQueue.state = mi.active;
                const t = this.requestQueue.queue.shift();
                if (t) try {
                    this.processRequest(t), await new Promise(s => setTimeout(s, 300))
                } catch (s) {
                    this.client.logger.warn(s)
                }
            }
            this.requestQueue.state = mi.idle
        }, this.processRequest = t => {
            const {
                topic: s,
                payload: o
            } = t, c = o.method;
            switch (c) {
                case "wc_sessionPropose":
                    return this.onSessionProposeRequest(s, o);
                case "wc_sessionSettle":
                    return this.onSessionSettleRequest(s, o);
                case "wc_sessionUpdate":
                    return this.onSessionUpdateRequest(s, o);
                case "wc_sessionExtend":
                    return this.onSessionExtendRequest(s, o);
                case "wc_sessionPing":
                    return this.onSessionPingRequest(s, o);
                case "wc_sessionDelete":
                    return this.onSessionDeleteRequest(s, o);
                case "wc_sessionRequest":
                    return this.onSessionRequest(s, o);
                case "wc_sessionEvent":
                    return this.onSessionEventRequest(s, o);
                default:
                    return this.client.logger.info(`Unsupported request method ${c}`)
            }
        }, this.onRelayEventResponse = async t => {
            const {
                topic: s,
                payload: o
            } = t, c = (await this.client.core.history.get(s, o.id)).request.method;
            switch (c) {
                case "wc_sessionPropose":
                    return this.onSessionProposeResponse(s, o);
                case "wc_sessionSettle":
                    return this.onSessionSettleResponse(s, o);
                case "wc_sessionUpdate":
                    return this.onSessionUpdateResponse(s, o);
                case "wc_sessionExtend":
                    return this.onSessionExtendResponse(s, o);
                case "wc_sessionPing":
                    return this.onSessionPingResponse(s, o);
                case "wc_sessionRequest":
                    return this.onSessionRequestResponse(s, o);
                default:
                    return this.client.logger.info(`Unsupported response method ${c}`)
            }
        }, this.onRelayEventUnknownPayload = t => {
            const {
                topic: s
            } = t, {
                message: o
            } = ce("MISSING_OR_INVALID", `Decoded payload on topic ${s} is not identifiable as a JSON-RPC request or a response.`);
            throw new Error(o)
        }, this.onSessionProposeRequest = async (t, s) => {
            const {
                params: o,
                id: c
            } = s;
            try {
                this.isValidConnect(ar({}, s.params));
                const l = o.expiryTimestamp || xr(_i.wc_sessionPropose.req.ttl),
                    f = ar({
                        id: c,
                        pairingTopic: t,
                        expiryTimestamp: l
                    }, o);
                await this.setProposal(c, f);
                const y = Ln(JSON.stringify(s)),
                    p = await this.getVerifyContext(y, f.proposer.metadata);
                this.client.events.emit("session_proposal", {
                    id: c,
                    params: f,
                    verifyContext: p
                })
            } catch (l) {
                await this.sendError(c, t, l), this.client.logger.error(l)
            }
        }, this.onSessionProposeResponse = async (t, s) => {
            const {
                id: o
            } = s;
            if (bi(s)) {
                const {
                    result: c
                } = s;
                this.client.logger.trace({
                    type: "method",
                    method: "onSessionProposeResponse",
                    result: c
                });
                const l = this.client.proposal.get(o);
                this.client.logger.trace({
                    type: "method",
                    method: "onSessionProposeResponse",
                    proposal: l
                });
                const f = l.proposer.publicKey;
                this.client.logger.trace({
                    type: "method",
                    method: "onSessionProposeResponse",
                    selfPublicKey: f
                });
                const y = c.responderPublicKey;
                this.client.logger.trace({
                    type: "method",
                    method: "onSessionProposeResponse",
                    peerPublicKey: y
                });
                const p = await this.client.core.crypto.generateSharedKey(f, y);
                this.client.logger.trace({
                    type: "method",
                    method: "onSessionProposeResponse",
                    sessionTopic: p
                });
                const v = await this.client.core.relayer.subscribe(p);
                this.client.logger.trace({
                    type: "method",
                    method: "onSessionProposeResponse",
                    subscriptionId: v
                }), await this.client.core.pairing.activate({
                    topic: t
                })
            } else Vr(s) && (await this.client.proposal.delete(o, _t("USER_DISCONNECTED")), this.events.emit(Nt("session_connect"), {
                error: s.error
            }))
        }, this.onSessionSettleRequest = async (t, s) => {
            const {
                id: o,
                params: c
            } = s;
            try {
                this.isValidSessionSettleRequest(c);
                const {
                    relay: l,
                    controller: f,
                    expiry: y,
                    namespaces: p,
                    sessionProperties: v,
                    pairingTopic: D
                } = s.params, S = ar({
                    topic: t,
                    relay: l,
                    expiry: y,
                    namespaces: p,
                    acknowledged: !0,
                    pairingTopic: D,
                    requiredNamespaces: {},
                    optionalNamespaces: {},
                    controller: f.publicKey,
                    self: {
                        publicKey: "",
                        metadata: this.client.metadata
                    },
                    peer: {
                        publicKey: f.publicKey,
                        metadata: f.metadata
                    }
                }, v && {
                    sessionProperties: v
                });
                await this.sendResult({
                    id: s.id,
                    topic: t,
                    result: !0
                }), this.events.emit(Nt("session_connect"), {
                    session: S
                }), this.cleanupDuplicatePairings(S)
            } catch (l) {
                await this.sendError(o, t, l), this.client.logger.error(l)
            }
        }, this.onSessionSettleResponse = async (t, s) => {
            const {
                id: o
            } = s;
            bi(s) ? (await this.client.session.update(t, {
                acknowledged: !0
            }), this.events.emit(Nt("session_approve", o), {})) : Vr(s) && (await this.client.session.delete(t, _t("USER_DISCONNECTED")), this.events.emit(Nt("session_approve", o), {
                error: s.error
            }))
        }, this.onSessionUpdateRequest = async (t, s) => {
            const {
                params: o,
                id: c
            } = s;
            try {
                const l = `${t}_session_update`,
                    f = Fo.get(l);
                if (f && this.isRequestOutOfSync(f, c)) {
                    this.client.logger.info(`Discarding out of sync request - ${c}`);
                    return
                }
                this.isValidUpdate(ar({
                    topic: t
                }, o)), await this.client.session.update(t, {
                    namespaces: o.namespaces
                }), await this.sendResult({
                    id: c,
                    topic: t,
                    result: !0
                }), this.client.events.emit("session_update", {
                    id: c,
                    topic: t,
                    params: o
                }), Fo.set(l, c)
            } catch (l) {
                await this.sendError(c, t, l), this.client.logger.error(l)
            }
        }, this.isRequestOutOfSync = (t, s) => parseInt(s.toString().slice(0, -3)) <= parseInt(t.toString().slice(0, -3)), this.onSessionUpdateResponse = (t, s) => {
            const {
                id: o
            } = s;
            bi(s) ? this.events.emit(Nt("session_update", o), {}) : Vr(s) && this.events.emit(Nt("session_update", o), {
                error: s.error
            })
        }, this.onSessionExtendRequest = async (t, s) => {
            const {
                id: o
            } = s;
            try {
                this.isValidExtend({
                    topic: t
                }), await this.setExpiry(t, xr(Bo)), await this.sendResult({
                    id: o,
                    topic: t,
                    result: !0
                }), this.client.events.emit("session_extend", {
                    id: o,
                    topic: t
                })
            } catch (c) {
                await this.sendError(o, t, c), this.client.logger.error(c)
            }
        }, this.onSessionExtendResponse = (t, s) => {
            const {
                id: o
            } = s;
            bi(s) ? this.events.emit(Nt("session_extend", o), {}) : Vr(s) && this.events.emit(Nt("session_extend", o), {
                error: s.error
            })
        }, this.onSessionPingRequest = async (t, s) => {
            const {
                id: o
            } = s;
            try {
                this.isValidPing({
                    topic: t
                }), await this.sendResult({
                    id: o,
                    topic: t,
                    result: !0
                }), this.client.events.emit("session_ping", {
                    id: o,
                    topic: t
                })
            } catch (c) {
                await this.sendError(o, t, c), this.client.logger.error(c)
            }
        }, this.onSessionPingResponse = (t, s) => {
            const {
                id: o
            } = s;
            setTimeout(() => {
                bi(s) ? this.events.emit(Nt("session_ping", o), {}) : Vr(s) && this.events.emit(Nt("session_ping", o), {
                    error: s.error
                })
            }, 500)
        }, this.onSessionDeleteRequest = async (t, s) => {
            const {
                id: o
            } = s;
            try {
                this.isValidDisconnect({
                    topic: t,
                    reason: s.params
                }), await Promise.all([new Promise(c => {
                    this.client.core.relayer.once(Zt.publish, async () => {
                        c(await this.deleteSession({
                            topic: t,
                            id: o
                        }))
                    })
                }), this.sendResult({
                    id: o,
                    topic: t,
                    result: !0
                }), this.cleanupPendingSentRequestsForTopic({
                    topic: t,
                    error: _t("USER_DISCONNECTED")
                })])
            } catch (c) {
                this.client.logger.error(c)
            }
        }, this.onSessionRequest = async (t, s) => {
            const {
                id: o,
                params: c
            } = s;
            try {
                this.isValidRequest(ar({
                    topic: t
                }, c));
                const l = Ln(JSON.stringify(Mn("wc_sessionRequest", c, o))),
                    f = this.client.session.get(t),
                    y = await this.getVerifyContext(l, f.peer.metadata),
                    p = {
                        id: o,
                        topic: t,
                        params: c,
                        verifyContext: y
                    };
                await this.setPendingSessionRequest(p), this.addSessionRequestToSessionRequestQueue(p), this.processSessionRequestQueue()
            } catch (l) {
                await this.sendError(o, t, l), this.client.logger.error(l)
            }
        }, this.onSessionRequestResponse = (t, s) => {
            const {
                id: o
            } = s;
            bi(s) ? this.events.emit(Nt("session_request", o), {
                result: s.result
            }) : Vr(s) && this.events.emit(Nt("session_request", o), {
                error: s.error
            })
        }, this.onSessionEventRequest = async (t, s) => {
            const {
                id: o,
                params: c
            } = s;
            try {
                const l = `${t}_session_event_${c.event.name}`,
                    f = Fo.get(l);
                if (f && this.isRequestOutOfSync(f, o)) {
                    this.client.logger.info(`Discarding out of sync request - ${o}`);
                    return
                }
                this.isValidEmit(ar({
                    topic: t
                }, c)), this.client.events.emit("session_event", {
                    id: o,
                    topic: t,
                    params: c
                }), Fo.set(l, o)
            } catch (l) {
                await this.sendError(o, t, l), this.client.logger.error(l)
            }
        }, this.addSessionRequestToSessionRequestQueue = t => {
            this.sessionRequestQueue.queue.push(t)
        }, this.cleanupAfterResponse = t => {
            this.deletePendingSessionRequest(t.response.id, {
                message: "fulfilled",
                code: 0
            }), setTimeout(() => {
                this.sessionRequestQueue.state = mi.idle, this.processSessionRequestQueue()
            }, ve.toMiliseconds(this.requestQueueDelay))
        }, this.cleanupPendingSentRequestsForTopic = ({
            topic: t,
            error: s
        }) => {
            const o = this.client.core.history.pending;
            o.length > 0 && o.filter(c => c.topic === t && c.request.method === "wc_sessionRequest").forEach(c => {
                this.events.emit(Nt("session_request", c.request.id), {
                    error: s
                })
            })
        }, this.processSessionRequestQueue = () => {
            if (this.sessionRequestQueue.state === mi.active) {
                this.client.logger.info("session request queue is already active.");
                return
            }
            const t = this.sessionRequestQueue.queue[0];
            if (!t) {
                this.client.logger.info("session request queue is empty.");
                return
            }
            try {
                this.sessionRequestQueue.state = mi.active, this.client.events.emit("session_request", t)
            } catch (s) {
                this.client.logger.error(s)
            }
        }, this.onPairingCreated = t => {
            if (t.active) return;
            const s = this.client.proposal.getAll().find(o => o.pairingTopic === t.topic);
            s && this.onSessionProposeRequest(t.topic, Mn("wc_sessionPropose", {
                requiredNamespaces: s.requiredNamespaces,
                optionalNamespaces: s.optionalNamespaces,
                relays: s.relays,
                proposer: s.proposer,
                sessionProperties: s.sessionProperties
            }, s.id))
        }, this.isValidConnect = async t => {
            if (!_r(t)) {
                const {
                    message: y
                } = ce("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(t)}`);
                throw new Error(y)
            }
            const {
                pairingTopic: s,
                requiredNamespaces: o,
                optionalNamespaces: c,
                sessionProperties: l,
                relays: f
            } = t;
            if (cr(s) || await this.isValidPairingTopic(s), !BE(f, !0)) {
                const {
                    message: y
                } = ce("MISSING_OR_INVALID", `connect() relays: ${f}`);
                throw new Error(y)
            }!cr(o) && Ds(o) !== 0 && this.validateNamespaces(o, "requiredNamespaces"), !cr(c) && Ds(c) !== 0 && this.validateNamespaces(c, "optionalNamespaces"), cr(l) || this.validateSessionProps(l, "sessionProperties")
        }, this.validateNamespaces = (t, s) => {
            const o = HE(t, "connect()", s);
            if (o) throw new Error(o.message)
        }, this.isValidApprove = async t => {
            if (!_r(t)) throw new Error(ce("MISSING_OR_INVALID", `approve() params: ${t}`).message);
            const {
                id: s,
                namespaces: o,
                relayProtocol: c,
                sessionProperties: l
            } = t;
            await this.isValidProposalId(s);
            const f = this.client.proposal.get(s),
                y = Fc(o, "approve()");
            if (y) throw new Error(y.message);
            const p = Tf(f.requiredNamespaces, o, "approve()");
            if (p) throw new Error(p.message);
            if (!Vt(c, !0)) {
                const {
                    message: v
                } = ce("MISSING_OR_INVALID", `approve() relayProtocol: ${c}`);
                throw new Error(v)
            }
            cr(l) || this.validateSessionProps(l, "sessionProperties")
        }, this.isValidReject = async t => {
            if (!_r(t)) {
                const {
                    message: c
                } = ce("MISSING_OR_INVALID", `reject() params: ${t}`);
                throw new Error(c)
            }
            const {
                id: s,
                reason: o
            } = t;
            if (await this.isValidProposalId(s), !kE(o)) {
                const {
                    message: c
                } = ce("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(o)}`);
                throw new Error(c)
            }
        }, this.isValidSessionSettleRequest = t => {
            if (!_r(t)) {
                const {
                    message: p
                } = ce("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${t}`);
                throw new Error(p)
            }
            const {
                relay: s,
                controller: o,
                namespaces: c,
                expiry: l
            } = t;
            if (!ap(s)) {
                const {
                    message: p
                } = ce("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
                throw new Error(p)
            }
            const f = LE(o, "onSessionSettleRequest()");
            if (f) throw new Error(f.message);
            const y = Fc(c, "onSessionSettleRequest()");
            if (y) throw new Error(y.message);
            if (ji(l)) {
                const {
                    message: p
                } = ce("EXPIRED", "onSessionSettleRequest()");
                throw new Error(p)
            }
        }, this.isValidUpdate = async t => {
            if (!_r(t)) {
                const {
                    message: y
                } = ce("MISSING_OR_INVALID", `update() params: ${t}`);
                throw new Error(y)
            }
            const {
                topic: s,
                namespaces: o
            } = t;
            await this.isValidSessionTopic(s);
            const c = this.client.session.get(s),
                l = Fc(o, "update()");
            if (l) throw new Error(l.message);
            const f = Tf(c.requiredNamespaces, o, "update()");
            if (f) throw new Error(f.message)
        }, this.isValidExtend = async t => {
            if (!_r(t)) {
                const {
                    message: o
                } = ce("MISSING_OR_INVALID", `extend() params: ${t}`);
                throw new Error(o)
            }
            const {
                topic: s
            } = t;
            await this.isValidSessionTopic(s)
        }, this.isValidRequest = async t => {
            if (!_r(t)) {
                const {
                    message: y
                } = ce("MISSING_OR_INVALID", `request() params: ${t}`);
                throw new Error(y)
            }
            const {
                topic: s,
                request: o,
                chainId: c,
                expiry: l
            } = t;
            await this.isValidSessionTopic(s);
            const {
                namespaces: f
            } = this.client.session.get(s);
            if (!Cf(f, c)) {
                const {
                    message: y
                } = ce("MISSING_OR_INVALID", `request() chainId: ${c}`);
                throw new Error(y)
            }
            if (!VE(o)) {
                const {
                    message: y
                } = ce("MISSING_OR_INVALID", `request() ${JSON.stringify(o)}`);
                throw new Error(y)
            }
            if (!YE(f, c, o.method)) {
                const {
                    message: y
                } = ce("MISSING_OR_INVALID", `request() method: ${o.method}`);
                throw new Error(y)
            }
            if (l && !ZE(l, Zc)) {
                const {
                    message: y
                } = ce("MISSING_OR_INVALID", `request() expiry: ${l}. Expiry must be a number (in seconds) between ${Zc.min} and ${Zc.max}`);
                throw new Error(y)
            }
        }, this.isValidRespond = async t => {
            var s;
            if (!_r(t)) {
                const {
                    message: l
                } = ce("MISSING_OR_INVALID", `respond() params: ${t}`);
                throw new Error(l)
            }
            const {
                topic: o,
                response: c
            } = t;
            try {
                await this.isValidSessionTopic(o)
            } catch (l) {
                throw (s = t == null ? void 0 : t.response) != null && s.id && this.cleanupAfterResponse(t), l
            }
            if (!GE(c)) {
                const {
                    message: l
                } = ce("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(c)}`);
                throw new Error(l)
            }
        }, this.isValidPing = async t => {
            if (!_r(t)) {
                const {
                    message: o
                } = ce("MISSING_OR_INVALID", `ping() params: ${t}`);
                throw new Error(o)
            }
            const {
                topic: s
            } = t;
            await this.isValidSessionOrPairingTopic(s)
        }, this.isValidEmit = async t => {
            if (!_r(t)) {
                const {
                    message: f
                } = ce("MISSING_OR_INVALID", `emit() params: ${t}`);
                throw new Error(f)
            }
            const {
                topic: s,
                event: o,
                chainId: c
            } = t;
            await this.isValidSessionTopic(s);
            const {
                namespaces: l
            } = this.client.session.get(s);
            if (!Cf(l, c)) {
                const {
                    message: f
                } = ce("MISSING_OR_INVALID", `emit() chainId: ${c}`);
                throw new Error(f)
            }
            if (!WE(o)) {
                const {
                    message: f
                } = ce("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(o)}`);
                throw new Error(f)
            }
            if (!JE(l, c, o.name)) {
                const {
                    message: f
                } = ce("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(o)}`);
                throw new Error(f)
            }
        }, this.isValidDisconnect = async t => {
            if (!_r(t)) {
                const {
                    message: o
                } = ce("MISSING_OR_INVALID", `disconnect() params: ${t}`);
                throw new Error(o)
            }
            const {
                topic: s
            } = t;
            await this.isValidSessionOrPairingTopic(s)
        }, this.getVerifyContext = async (t, s) => {
            const o = {
                verified: {
                    verifyUrl: s.verifyUrl || jn,
                    validation: "UNKNOWN",
                    origin: s.url || ""
                }
            };
            try {
                const c = await this.client.core.verify.resolve({
                    attestationId: t,
                    verifyUrl: s.verifyUrl
                });
                c && (o.verified.origin = c.origin, o.verified.isScam = c.isScam, o.verified.validation = c.origin === new URL(s.url).origin ? "VALID" : "INVALID")
            } catch (c) {
                this.client.logger.info(c)
            }
            return this.client.logger.info(`Verify context: ${JSON.stringify(o)}`), o
        }, this.validateSessionProps = (t, s) => {
            Object.values(t).forEach(o => {
                if (!Vt(o, !1)) {
                    const {
                        message: c
                    } = ce("MISSING_OR_INVALID", `${s} must be in Record<string, string> format. Received: ${JSON.stringify(o)}`);
                    throw new Error(c)
                }
            })
        }
    }
    async isInitialized() {
        if (!this.initialized) {
            const {
                message: e
            } = ce("NOT_INITIALIZED", this.name);
            throw new Error(e)
        }
        await this.client.core.relayer.confirmOnlineStateOrThrow()
    }
    registerRelayerEvents() {
        this.client.core.relayer.on(Zt.message, async e => {
            const {
                topic: t,
                message: s
            } = e;
            if (this.ignoredPayloadTypes.includes(this.client.core.crypto.getPayloadType(s))) return;
            const o = await this.client.core.crypto.decode(t, s);
            try {
                Wu(o) ? (this.client.core.history.set(t, o), this.onRelayEventRequest({
                    topic: t,
                    payload: o
                })) : ca(o) ? (await this.client.core.history.resolve(o), await this.onRelayEventResponse({
                    topic: t,
                    payload: o
                }), this.client.core.history.delete(t, o.id)) : this.onRelayEventUnknownPayload({
                    topic: t,
                    payload: o
                })
            } catch (c) {
                this.client.logger.error(c)
            }
        })
    }
    registerExpirerEvents() {
        this.client.core.expirer.on(Mr.expired, async e => {
            const {
                topic: t,
                id: s
            } = sp(e.target);
            if (s && this.client.pendingRequest.keys.includes(s)) return await this.deletePendingSessionRequest(s, ce("EXPIRED"), !0);
            t ? this.client.session.keys.includes(t) && (await this.deleteSession({
                topic: t,
                expirerHasDeleted: !0
            }), this.client.events.emit("session_expire", {
                topic: t
            })) : s && (await this.deleteProposal(s, !0), this.client.events.emit("proposal_expire", {
                id: s
            }))
        })
    }
    registerPairingEvents() {
        this.client.core.pairing.events.on(vs.create, e => this.onPairingCreated(e))
    }
    isValidPairingTopic(e) {
        if (!Vt(e, !1)) {
            const {
                message: t
            } = ce("MISSING_OR_INVALID", `pairing topic should be a string: ${e}`);
            throw new Error(t)
        }
        if (!this.client.core.pairing.pairings.keys.includes(e)) {
            const {
                message: t
            } = ce("NO_MATCHING_KEY", `pairing topic doesn't exist: ${e}`);
            throw new Error(t)
        }
        if (ji(this.client.core.pairing.pairings.get(e).expiry)) {
            const {
                message: t
            } = ce("EXPIRED", `pairing topic: ${e}`);
            throw new Error(t)
        }
    }
    async isValidSessionTopic(e) {
        if (!Vt(e, !1)) {
            const {
                message: t
            } = ce("MISSING_OR_INVALID", `session topic should be a string: ${e}`);
            throw new Error(t)
        }
        if (!this.client.session.keys.includes(e)) {
            const {
                message: t
            } = ce("NO_MATCHING_KEY", `session topic doesn't exist: ${e}`);
            throw new Error(t)
        }
        if (ji(this.client.session.get(e).expiry)) {
            await this.deleteSession({
                topic: e
            });
            const {
                message: t
            } = ce("EXPIRED", `session topic: ${e}`);
            throw new Error(t)
        }
        if (!this.client.core.crypto.keychain.has(e)) {
            const {
                message: t
            } = ce("MISSING_OR_INVALID", `session topic does not exist in keychain: ${e}`);
            throw await this.deleteSession({
                topic: e
            }), new Error(t)
        }
    }
    async isValidSessionOrPairingTopic(e) {
        if (this.client.session.keys.includes(e)) await this.isValidSessionTopic(e);
        else if (this.client.core.pairing.pairings.keys.includes(e)) this.isValidPairingTopic(e);
        else if (Vt(e, !1)) {
            const {
                message: t
            } = ce("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${e}`);
            throw new Error(t)
        } else {
            const {
                message: t
            } = ce("MISSING_OR_INVALID", `session or pairing topic should be a string: ${e}`);
            throw new Error(t)
        }
    }
    async isValidProposalId(e) {
        if (!KE(e)) {
            const {
                message: t
            } = ce("MISSING_OR_INVALID", `proposal id should be a number: ${e}`);
            throw new Error(t)
        }
        if (!this.client.proposal.keys.includes(e)) {
            const {
                message: t
            } = ce("NO_MATCHING_KEY", `proposal id doesn't exist: ${e}`);
            throw new Error(t)
        }
        if (ji(this.client.proposal.get(e).expiryTimestamp)) {
            await this.deleteProposal(e);
            const {
                message: t
            } = ce("EXPIRED", `proposal id: ${e}`);
            throw new Error(t)
        }
    }
}
class j6 extends ha {
    constructor(e, t) {
        super(e, t, S6, Qu), this.core = e, this.logger = t
    }
}
let L6 = class extends ha {
    constructor(e, t) {
        super(e, t, I6, Qu), this.core = e, this.logger = t
    }
};
class M6 extends ha {
    constructor(e, t) {
        super(e, t, O6, Qu, s => s.id), this.core = e, this.logger = t
    }
}
let U6 = class kp extends U3 {
    constructor(e) {
        super(e), this.protocol = Fp, this.version = Hp, this.name = Xc.name, this.events = new Ur.EventEmitter, this.on = (s, o) => this.events.on(s, o), this.once = (s, o) => this.events.once(s, o), this.off = (s, o) => this.events.off(s, o), this.removeListener = (s, o) => this.events.removeListener(s, o), this.removeAllListeners = s => this.events.removeAllListeners(s), this.connect = async s => {
            try {
                return await this.engine.connect(s)
            } catch (o) {
                throw this.logger.error(o.message), o
            }
        }, this.pair = async s => {
            try {
                return await this.engine.pair(s)
            } catch (o) {
                throw this.logger.error(o.message), o
            }
        }, this.approve = async s => {
            try {
                return await this.engine.approve(s)
            } catch (o) {
                throw this.logger.error(o.message), o
            }
        }, this.reject = async s => {
            try {
                return await this.engine.reject(s)
            } catch (o) {
                throw this.logger.error(o.message), o
            }
        }, this.update = async s => {
            try {
                return await this.engine.update(s)
            } catch (o) {
                throw this.logger.error(o.message), o
            }
        }, this.extend = async s => {
            try {
                return await this.engine.extend(s)
            } catch (o) {
                throw this.logger.error(o.message), o
            }
        }, this.request = async s => {
            try {
                return await this.engine.request(s)
            } catch (o) {
                throw this.logger.error(o.message), o
            }
        }, this.respond = async s => {
            try {
                return await this.engine.respond(s)
            } catch (o) {
                throw this.logger.error(o.message), o
            }
        }, this.ping = async s => {
            try {
                return await this.engine.ping(s)
            } catch (o) {
                throw this.logger.error(o.message), o
            }
        }, this.emit = async s => {
            try {
                return await this.engine.emit(s)
            } catch (o) {
                throw this.logger.error(o.message), o
            }
        }, this.disconnect = async s => {
            try {
                return await this.engine.disconnect(s)
            } catch (o) {
                throw this.logger.error(o.message), o
            }
        }, this.find = s => {
            try {
                return this.engine.find(s)
            } catch (o) {
                throw this.logger.error(o.message), o
            }
        }, this.getPendingSessionRequests = () => {
            try {
                return this.engine.getPendingSessionRequests()
            } catch (s) {
                throw this.logger.error(s.message), s
            }
        }, this.name = (e == null ? void 0 : e.name) || Xc.name, this.metadata = (e == null ? void 0 : e.metadata) || sE();
        const t = typeof(e == null ? void 0 : e.logger) < "u" && typeof(e == null ? void 0 : e.logger) != "string" ? e.logger : Ye.pino(Ye.getDefaultLoggerOptions({
            level: (e == null ? void 0 : e.logger) || Xc.logger
        }));
        this.core = (e == null ? void 0 : e.core) || new D6(e), this.logger = Ye.generateChildLogger(t, this.name), this.session = new L6(this.core, this.logger), this.proposal = new j6(this.core, this.logger), this.pendingRequest = new M6(this.core, this.logger), this.engine = new $6(this)
    }
    static async init(e) {
        const t = new kp(e);
        return await t.initialize(), t
    }
    get context() {
        return Ye.getLoggerContext(this.logger)
    }
    get pairing() {
        return this.core.pairing.pairings
    }
    async initialize() {
        this.logger.trace("Initialized");
        try {
            await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.engine.init(), this.core.verify.init({
                verifyUrl: this.metadata.verifyUrl
            }), this.logger.info("SignClient Initialization Success")
        } catch (e) {
            throw this.logger.info("SignClient Initialization Failure"), this.logger.error(e.message), e
        }
    }
};
var Ou = {
    exports: {}
};
(function(i, e) {
    var t = typeof self < "u" ? self : Gr,
        s = function() {
            function c() {
                this.fetch = !1, this.DOMException = t.DOMException
            }
            return c.prototype = t, new c
        }();
    (function(c) {
        (function(l) {
            var f = {
                searchParams: "URLSearchParams" in c,
                iterable: "Symbol" in c && "iterator" in Symbol,
                blob: "FileReader" in c && "Blob" in c && function() {
                    try {
                        return new Blob, !0
                    } catch {
                        return !1
                    }
                }(),
                formData: "FormData" in c,
                arrayBuffer: "ArrayBuffer" in c
            };

            function y(w) {
                return w && DataView.prototype.isPrototypeOf(w)
            }
            if (f.arrayBuffer) var p = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"],
                v = ArrayBuffer.isView || function(w) {
                    return w && p.indexOf(Object.prototype.toString.call(w)) > -1
                };

            function D(w) {
                if (typeof w != "string" && (w = String(w)), /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(w)) throw new TypeError("Invalid character in header field name");
                return w.toLowerCase()
            }

            function S(w) {
                return typeof w != "string" && (w = String(w)), w
            }

            function x(w) {
                var T = {
                    next: function() {
                        var ee = w.shift();
                        return {
                            done: ee === void 0,
                            value: ee
                        }
                    }
                };
                return f.iterable && (T[Symbol.iterator] = function() {
                    return T
                }), T
            }

            function O(w) {
                this.map = {}, w instanceof O ? w.forEach(function(T, ee) {
                    this.append(ee, T)
                }, this) : Array.isArray(w) ? w.forEach(function(T) {
                    this.append(T[0], T[1])
                }, this) : w && Object.getOwnPropertyNames(w).forEach(function(T) {
                    this.append(T, w[T])
                }, this)
            }
            O.prototype.append = function(w, T) {
                w = D(w), T = S(T);
                var ee = this.map[w];
                this.map[w] = ee ? ee + ", " + T : T
            }, O.prototype.delete = function(w) {
                delete this.map[D(w)]
            }, O.prototype.get = function(w) {
                return w = D(w), this.has(w) ? this.map[w] : null
            }, O.prototype.has = function(w) {
                return this.map.hasOwnProperty(D(w))
            }, O.prototype.set = function(w, T) {
                this.map[D(w)] = S(T)
            }, O.prototype.forEach = function(w, T) {
                for (var ee in this.map) this.map.hasOwnProperty(ee) && w.call(T, this.map[ee], ee, this)
            }, O.prototype.keys = function() {
                var w = [];
                return this.forEach(function(T, ee) {
                    w.push(ee)
                }), x(w)
            }, O.prototype.values = function() {
                var w = [];
                return this.forEach(function(T) {
                    w.push(T)
                }), x(w)
            }, O.prototype.entries = function() {
                var w = [];
                return this.forEach(function(T, ee) {
                    w.push([ee, T])
                }), x(w)
            }, f.iterable && (O.prototype[Symbol.iterator] = O.prototype.entries);

            function F(w) {
                if (w.bodyUsed) return Promise.reject(new TypeError("Already read"));
                w.bodyUsed = !0
            }

            function K(w) {
                return new Promise(function(T, ee) {
                    w.onload = function() {
                        T(w.result)
                    }, w.onerror = function() {
                        ee(w.error)
                    }
                })
            }

            function ne(w) {
                var T = new FileReader,
                    ee = K(T);
                return T.readAsArrayBuffer(w), ee
            }

            function $(w) {
                var T = new FileReader,
                    ee = K(T);
                return T.readAsText(w), ee
            }

            function U(w) {
                for (var T = new Uint8Array(w), ee = new Array(T.length), Q = 0; Q < T.length; Q++) ee[Q] = String.fromCharCode(T[Q]);
                return ee.join("")
            }

            function C(w) {
                if (w.slice) return w.slice(0);
                var T = new Uint8Array(w.byteLength);
                return T.set(new Uint8Array(w)), T.buffer
            }

            function A() {
                return this.bodyUsed = !1, this._initBody = function(w) {
                    this._bodyInit = w, w ? typeof w == "string" ? this._bodyText = w : f.blob && Blob.prototype.isPrototypeOf(w) ? this._bodyBlob = w : f.formData && FormData.prototype.isPrototypeOf(w) ? this._bodyFormData = w : f.searchParams && URLSearchParams.prototype.isPrototypeOf(w) ? this._bodyText = w.toString() : f.arrayBuffer && f.blob && y(w) ? (this._bodyArrayBuffer = C(w.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : f.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(w) || v(w)) ? this._bodyArrayBuffer = C(w) : this._bodyText = w = Object.prototype.toString.call(w) : this._bodyText = "", this.headers.get("content-type") || (typeof w == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : f.searchParams && URLSearchParams.prototype.isPrototypeOf(w) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"))
                }, f.blob && (this.blob = function() {
                    var w = F(this);
                    if (w) return w;
                    if (this._bodyBlob) return Promise.resolve(this._bodyBlob);
                    if (this._bodyArrayBuffer) return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                    if (this._bodyFormData) throw new Error("could not read FormData body as blob");
                    return Promise.resolve(new Blob([this._bodyText]))
                }, this.arrayBuffer = function() {
                    return this._bodyArrayBuffer ? F(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(ne)
                }), this.text = function() {
                    var w = F(this);
                    if (w) return w;
                    if (this._bodyBlob) return $(this._bodyBlob);
                    if (this._bodyArrayBuffer) return Promise.resolve(U(this._bodyArrayBuffer));
                    if (this._bodyFormData) throw new Error("could not read FormData body as text");
                    return Promise.resolve(this._bodyText)
                }, f.formData && (this.formData = function() {
                    return this.text().then(G)
                }), this.json = function() {
                    return this.text().then(JSON.parse)
                }, this
            }
            var E = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];

            function u(w) {
                var T = w.toUpperCase();
                return E.indexOf(T) > -1 ? T : w
            }

            function b(w, T) {
                T = T || {};
                var ee = T.body;
                if (w instanceof b) {
                    if (w.bodyUsed) throw new TypeError("Already read");
                    this.url = w.url, this.credentials = w.credentials, T.headers || (this.headers = new O(w.headers)), this.method = w.method, this.mode = w.mode, this.signal = w.signal, !ee && w._bodyInit != null && (ee = w._bodyInit, w.bodyUsed = !0)
                } else this.url = String(w);
                if (this.credentials = T.credentials || this.credentials || "same-origin", (T.headers || !this.headers) && (this.headers = new O(T.headers)), this.method = u(T.method || this.method || "GET"), this.mode = T.mode || this.mode || null, this.signal = T.signal || this.signal, this.referrer = null, (this.method === "GET" || this.method === "HEAD") && ee) throw new TypeError("Body not allowed for GET or HEAD requests");
                this._initBody(ee)
            }
            b.prototype.clone = function() {
                return new b(this, {
                    body: this._bodyInit
                })
            };

            function G(w) {
                var T = new FormData;
                return w.trim().split("&").forEach(function(ee) {
                    if (ee) {
                        var Q = ee.split("="),
                            k = Q.shift().replace(/\+/g, " "),
                            V = Q.join("=").replace(/\+/g, " ");
                        T.append(decodeURIComponent(k), decodeURIComponent(V))
                    }
                }), T
            }

            function W(w) {
                var T = new O,
                    ee = w.replace(/\r?\n[\t ]+/g, " ");
                return ee.split(/\r?\n/).forEach(function(Q) {
                    var k = Q.split(":"),
                        V = k.shift().trim();
                    if (V) {
                        var J = k.join(":").trim();
                        T.append(V, J)
                    }
                }), T
            }
            A.call(b.prototype);

            function se(w, T) {
                T || (T = {}), this.type = "default", this.status = T.status === void 0 ? 200 : T.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = "statusText" in T ? T.statusText : "OK", this.headers = new O(T.headers), this.url = T.url || "", this._initBody(w)
            }
            A.call(se.prototype), se.prototype.clone = function() {
                return new se(this._bodyInit, {
                    status: this.status,
                    statusText: this.statusText,
                    headers: new O(this.headers),
                    url: this.url
                })
            }, se.error = function() {
                var w = new se(null, {
                    status: 0,
                    statusText: ""
                });
                return w.type = "error", w
            };
            var ue = [301, 302, 303, 307, 308];
            se.redirect = function(w, T) {
                if (ue.indexOf(T) === -1) throw new RangeError("Invalid status code");
                return new se(null, {
                    status: T,
                    headers: {
                        location: w
                    }
                })
            }, l.DOMException = c.DOMException;
            try {
                new l.DOMException
            } catch {
                l.DOMException = function(T, ee) {
                    this.message = T, this.name = ee;
                    var Q = Error(T);
                    this.stack = Q.stack
                }, l.DOMException.prototype = Object.create(Error.prototype), l.DOMException.prototype.constructor = l.DOMException
            }

            function de(w, T) {
                return new Promise(function(ee, Q) {
                    var k = new b(w, T);
                    if (k.signal && k.signal.aborted) return Q(new l.DOMException("Aborted", "AbortError"));
                    var V = new XMLHttpRequest;

                    function J() {
                        V.abort()
                    }
                    V.onload = function() {
                        var re = {
                            status: V.status,
                            statusText: V.statusText,
                            headers: W(V.getAllResponseHeaders() || "")
                        };
                        re.url = "responseURL" in V ? V.responseURL : re.headers.get("X-Request-URL");
                        var be = "response" in V ? V.response : V.responseText;
                        ee(new se(be, re))
                    }, V.onerror = function() {
                        Q(new TypeError("Network request failed"))
                    }, V.ontimeout = function() {
                        Q(new TypeError("Network request failed"))
                    }, V.onabort = function() {
                        Q(new l.DOMException("Aborted", "AbortError"))
                    }, V.open(k.method, k.url, !0), k.credentials === "include" ? V.withCredentials = !0 : k.credentials === "omit" && (V.withCredentials = !1), "responseType" in V && f.blob && (V.responseType = "blob"), k.headers.forEach(function(re, be) {
                        V.setRequestHeader(be, re)
                    }), k.signal && (k.signal.addEventListener("abort", J), V.onreadystatechange = function() {
                        V.readyState === 4 && k.signal.removeEventListener("abort", J)
                    }), V.send(typeof k._bodyInit > "u" ? null : k._bodyInit)
                })
            }
            return de.polyfill = !0, c.fetch || (c.fetch = de, c.Headers = O, c.Request = b, c.Response = se), l.Headers = O, l.Request = b, l.Response = se, l.fetch = de, Object.defineProperty(l, "__esModule", {
                value: !0
            }), l
        })({})
    })(s), s.fetch.ponyfill = !0, delete s.fetch.polyfill;
    var o = s;
    e = o.fetch, e.default = o.fetch, e.fetch = o.fetch, e.Headers = o.Headers, e.Request = o.Request, e.Response = o.Response, i.exports = e
})(Ou, Ou.exports);
var q6 = Ou.exports;
const Dd = Au(q6),
    z6 = {
        Accept: "application/json",
        "Content-Type": "application/json"
    },
    F6 = "POST",
    Sd = {
        headers: z6,
        method: F6
    },
    Id = 10;
class qi {
    constructor(e, t = !1) {
        if (this.url = e, this.disableProviderPing = t, this.events = new Ur.EventEmitter, this.isAvailable = !1, this.registering = !1, !Qf(e)) throw new Error(`Provided URL is not compatible with HTTP connection: ${e}`);
        this.url = e, this.disableProviderPing = t
    }
    get connected() {
        return this.isAvailable
    }
    get connecting() {
        return this.registering
    }
    on(e, t) {
        this.events.on(e, t)
    }
    once(e, t) {
        this.events.once(e, t)
    }
    off(e, t) {
        this.events.off(e, t)
    }
    removeListener(e, t) {
        this.events.removeListener(e, t)
    }
    async open(e = this.url) {
        await this.register(e)
    }
    async close() {
        if (!this.isAvailable) throw new Error("Connection already closed");
        this.onClose()
    }
    async send(e, t) {
        this.isAvailable || await this.register();
        try {
            const s = on(e),
                c = await (await Dd(this.url, Object.assign(Object.assign({}, Sd), {
                    body: s
                }))).json();
            this.onPayload({
                data: c
            })
        } catch (s) {
            this.onError(e.id, s)
        }
    }
    async register(e = this.url) {
        if (!Qf(e)) throw new Error(`Provided URL is not compatible with HTTP connection: ${e}`);
        if (this.registering) {
            const t = this.events.getMaxListeners();
            return (this.events.listenerCount("register_error") >= t || this.events.listenerCount("open") >= t) && this.events.setMaxListeners(t + 1), new Promise((s, o) => {
                this.events.once("register_error", c => {
                    this.resetMaxListeners(), o(c)
                }), this.events.once("open", () => {
                    if (this.resetMaxListeners(), typeof this.isAvailable > "u") return o(new Error("HTTP connection is missing or invalid"));
                    s()
                })
            })
        }
        this.url = e, this.registering = !0;
        try {
            if (!this.disableProviderPing) {
                const t = on({
                    id: 1,
                    jsonrpc: "2.0",
                    method: "test",
                    params: []
                });
                await Dd(e, Object.assign(Object.assign({}, Sd), {
                    body: t
                }))
            }
            this.onOpen()
        } catch (t) {
            const s = this.parseError(t);
            throw this.events.emit("register_error", s), this.onClose(), s
        }
    }
    onOpen() {
        this.isAvailable = !0, this.registering = !1, this.events.emit("open")
    }
    onClose() {
        this.isAvailable = !1, this.registering = !1, this.events.emit("close")
    }
    onPayload(e) {
        if (typeof e.data > "u") return;
        const t = typeof e.data == "string" ? Ns(e.data) : e.data;
        this.events.emit("payload", t)
    }
    onError(e, t) {
        const s = this.parseError(t),
            o = s.message || s.toString(),
            c = aa(e, o);
        this.events.emit("payload", c)
    }
    parseError(e, t = this.url) {
        return wp(e, t, "HTTP")
    }
    resetMaxListeners() {
        this.events.getMaxListeners() > Id && this.events.setMaxListeners(Id)
    }
}
const xd = "error",
    H6 = "wss://relay.walletconnect.com",
    B6 = "wc",
    K6 = "universal_provider",
    Od = `${B6}@2:${K6}:`,
    k6 = "https://rpc.walletconnect.com/v1/",
    Di = {
        DEFAULT_CHAIN_CHANGED: "default_chain_changed"
    };
var gs = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {},
    Pu = {
        exports: {}
    };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
(function(i, e) {
    (function() {
        var t, s = "4.17.21",
            o = 200,
            c = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.",
            l = "Expected a function",
            f = "Invalid `variable` option passed into `_.template`",
            y = "__lodash_hash_undefined__",
            p = 500,
            v = "__lodash_placeholder__",
            D = 1,
            S = 2,
            x = 4,
            O = 1,
            F = 2,
            K = 1,
            ne = 2,
            $ = 4,
            U = 8,
            C = 16,
            A = 32,
            E = 64,
            u = 128,
            b = 256,
            G = 512,
            W = 30,
            se = "...",
            ue = 800,
            de = 16,
            w = 1,
            T = 2,
            ee = 3,
            Q = 1 / 0,
            k = 9007199254740991,
            V = 17976931348623157e292,
            J = NaN,
            re = 4294967295,
            be = re - 1,
            oe = re >>> 1,
            we = [
                ["ary", u],
                ["bind", K],
                ["bindKey", ne],
                ["curry", U],
                ["curryRight", C],
                ["flip", G],
                ["partial", A],
                ["partialRight", E],
                ["rearg", b]
            ],
            le = "[object Arguments]",
            _e = "[object Array]",
            H = "[object AsyncFunction]",
            z = "[object Boolean]",
            j = "[object Date]",
            d = "[object DOMException]",
            R = "[object Error]",
            ae = "[object Function]",
            fe = "[object GeneratorFunction]",
            Ie = "[object Map]",
            Fe = "[object Number]",
            Ke = "[object Null]",
            Le = "[object Object]",
            dt = "[object Promise]",
            pt = "[object Proxy]",
            Ue = "[object RegExp]",
            xe = "[object Set]",
            Ne = "[object String]",
            $e = "[object Symbol]",
            qe = "[object Undefined]",
            Pe = "[object WeakMap]",
            je = "[object WeakSet]",
            Se = "[object ArrayBuffer]",
            Ce = "[object DataView]",
            He = "[object Float32Array]",
            Oe = "[object Float64Array]",
            ke = "[object Int8Array]",
            Ge = "[object Int16Array]",
            Ze = "[object Int32Array]",
            et = "[object Uint8Array]",
            Je = "[object Uint8ClampedArray]",
            er = "[object Uint16Array]",
            lr = "[object Uint32Array]",
            Wr = /\b__p \+= '';/g,
            tr = /\b(__p \+=) '' \+/g,
            ii = /(__e\(.*?\)|\b__t\)) \+\n'';/g,
            Si = /&(?:amp|lt|gt|quot|#39);/g,
            zi = /[&<>"']/g,
            Et = RegExp(Si.source),
            gt = RegExp(zi.source),
            Dt = /<%-([\s\S]+?)%>/g,
            St = /<%([\s\S]+?)%>/g,
            bt = /<%=([\s\S]+?)%>/g,
            yt = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
            $t = /^\w*$/,
            jt = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
            It = /[\\^$.*+?()[\]{}|]/g,
            Lt = RegExp(It.source),
            xt = /^\s+/,
            Ct = /\s/,
            Ot = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
            ut = /\{\n\/\* \[wrapped with (.+)\] \*/,
            Mt = /,? & /,
            Ut = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,
            la = /[()=,{}\[\]\/\s]/,
            fa = /\\(\\)?/g,
            da = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,
            Pr = /\w*$/,
            pa = /^[-+]0x[0-9a-f]+$/i,
            ga = /^0b[01]+$/i,
            ya = /^\[object .+?Constructor\]$/,
            va = /^0o[0-7]+$/i,
            _a = /^(?:0|[1-9]\d*)$/,
            ni = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,
            fn = /($^)/,
            ma = /['\n\r\u2028\u2029\\]/g,
            dn = "\\ud800-\\udfff",
            ba = "\\u0300-\\u036f",
            wa = "\\ufe20-\\ufe2f",
            pn = "\\u20d0-\\u20ff",
            js = ba + wa + pn,
            Ls = "\\u2700-\\u27bf",
            qr = "a-z\\xdf-\\xf6\\xf8-\\xff",
            Ea = "\\xac\\xb1\\xd7\\xf7",
            Da = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf",
            Sa = "\\u2000-\\u206f",
            Ia = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",
            Ms = "A-Z\\xc0-\\xd6\\xd8-\\xde",
            Us = "\\ufe0e\\ufe0f",
            Fi = Ea + Da + Sa + Ia,
            Kn = "['’]",
            Hi = "[" + dn + "]",
            kn = "[" + Fi + "]",
            Bi = "[" + js + "]",
            qs = "\\d+",
            xa = "[" + Ls + "]",
            zs = "[" + qr + "]",
            Fs = "[^" + dn + Fi + qs + Ls + qr + Ms + "]",
            gn = "\\ud83c[\\udffb-\\udfff]",
            Oa = "(?:" + Bi + "|" + gn + ")",
            Hs = "[^" + dn + "]",
            yn = "(?:\\ud83c[\\udde6-\\uddff]){2}",
            Ii = "[\\ud800-\\udbff][\\udc00-\\udfff]",
            br = "[" + Ms + "]",
            Bs = "\\u200d",
            Ks = "(?:" + zs + "|" + Fs + ")",
            Yr = "(?:" + br + "|" + Fs + ")",
            ks = "(?:" + Kn + "(?:d|ll|m|re|s|t|ve))?",
            Vs = "(?:" + Kn + "(?:D|LL|M|RE|S|T|VE))?",
            Gs = Oa + "?",
            Ws = "[" + Us + "]?",
            Pa = "(?:" + Bs + "(?:" + [Hs, yn, Ii].join("|") + ")" + Ws + Gs + ")*",
            si = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])",
            Ys = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])",
            Js = Ws + Gs + Pa,
            vn = "(?:" + [xa, yn, Ii].join("|") + ")" + Js,
            Ca = "(?:" + [Hs + Bi + "?", Bi, yn, Ii, Hi].join("|") + ")",
            Vn = RegExp(Kn, "g"),
            Ta = RegExp(Bi, "g"),
            _n = RegExp(gn + "(?=" + gn + ")|" + Ca + Js, "g"),
            Qs = RegExp([br + "?" + zs + "+" + ks + "(?=" + [kn, br, "$"].join("|") + ")", Yr + "+" + Vs + "(?=" + [kn, br + Ks, "$"].join("|") + ")", br + "?" + Ks + "+" + ks, br + "+" + Vs, Ys, si, qs, vn].join("|"), "g"),
            Xs = RegExp("[" + Bs + dn + js + Us + "]"),
            Ki = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,
            Zs = ["Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "clearTimeout", "isFinite", "parseInt", "setTimeout"],
            Aa = -1,
            st = {};
        st[He] = st[Oe] = st[ke] = st[Ge] = st[Ze] = st[et] = st[Je] = st[er] = st[lr] = !0, st[le] = st[_e] = st[Se] = st[z] = st[Ce] = st[j] = st[R] = st[ae] = st[Ie] = st[Fe] = st[Le] = st[Ue] = st[xe] = st[Ne] = st[Pe] = !1;
        var nt = {};
        nt[le] = nt[_e] = nt[Se] = nt[Ce] = nt[z] = nt[j] = nt[He] = nt[Oe] = nt[ke] = nt[Ge] = nt[Ze] = nt[Ie] = nt[Fe] = nt[Le] = nt[Ue] = nt[xe] = nt[Ne] = nt[$e] = nt[et] = nt[Je] = nt[er] = nt[lr] = !0, nt[R] = nt[ae] = nt[Pe] = !1;
        var I = {
                À: "A",
                Á: "A",
                Â: "A",
                Ã: "A",
                Ä: "A",
                Å: "A",
                à: "a",
                á: "a",
                â: "a",
                ã: "a",
                ä: "a",
                å: "a",
                Ç: "C",
                ç: "c",
                Ð: "D",
                ð: "d",
                È: "E",
                É: "E",
                Ê: "E",
                Ë: "E",
                è: "e",
                é: "e",
                ê: "e",
                ë: "e",
                Ì: "I",
                Í: "I",
                Î: "I",
                Ï: "I",
                ì: "i",
                í: "i",
                î: "i",
                ï: "i",
                Ñ: "N",
                ñ: "n",
                Ò: "O",
                Ó: "O",
                Ô: "O",
                Õ: "O",
                Ö: "O",
                Ø: "O",
                ò: "o",
                ó: "o",
                ô: "o",
                õ: "o",
                ö: "o",
                ø: "o",
                Ù: "U",
                Ú: "U",
                Û: "U",
                Ü: "U",
                ù: "u",
                ú: "u",
                û: "u",
                ü: "u",
                Ý: "Y",
                ý: "y",
                ÿ: "y",
                Æ: "Ae",
                æ: "ae",
                Þ: "Th",
                þ: "th",
                ß: "ss",
                Ā: "A",
                Ă: "A",
                Ą: "A",
                ā: "a",
                ă: "a",
                ą: "a",
                Ć: "C",
                Ĉ: "C",
                Ċ: "C",
                Č: "C",
                ć: "c",
                ĉ: "c",
                ċ: "c",
                č: "c",
                Ď: "D",
                Đ: "D",
                ď: "d",
                đ: "d",
                Ē: "E",
                Ĕ: "E",
                Ė: "E",
                Ę: "E",
                Ě: "E",
                ē: "e",
                ĕ: "e",
                ė: "e",
                ę: "e",
                ě: "e",
                Ĝ: "G",
                Ğ: "G",
                Ġ: "G",
                Ģ: "G",
                ĝ: "g",
                ğ: "g",
                ġ: "g",
                ģ: "g",
                Ĥ: "H",
                Ħ: "H",
                ĥ: "h",
                ħ: "h",
                Ĩ: "I",
                Ī: "I",
                Ĭ: "I",
                Į: "I",
                İ: "I",
                ĩ: "i",
                ī: "i",
                ĭ: "i",
                į: "i",
                ı: "i",
                Ĵ: "J",
                ĵ: "j",
                Ķ: "K",
                ķ: "k",
                ĸ: "k",
                Ĺ: "L",
                Ļ: "L",
                Ľ: "L",
                Ŀ: "L",
                Ł: "L",
                ĺ: "l",
                ļ: "l",
                ľ: "l",
                ŀ: "l",
                ł: "l",
                Ń: "N",
                Ņ: "N",
                Ň: "N",
                Ŋ: "N",
                ń: "n",
                ņ: "n",
                ň: "n",
                ŋ: "n",
                Ō: "O",
                Ŏ: "O",
                Ő: "O",
                ō: "o",
                ŏ: "o",
                ő: "o",
                Ŕ: "R",
                Ŗ: "R",
                Ř: "R",
                ŕ: "r",
                ŗ: "r",
                ř: "r",
                Ś: "S",
                Ŝ: "S",
                Ş: "S",
                Š: "S",
                ś: "s",
                ŝ: "s",
                ş: "s",
                š: "s",
                Ţ: "T",
                Ť: "T",
                Ŧ: "T",
                ţ: "t",
                ť: "t",
                ŧ: "t",
                Ũ: "U",
                Ū: "U",
                Ŭ: "U",
                Ů: "U",
                Ű: "U",
                Ų: "U",
                ũ: "u",
                ū: "u",
                ŭ: "u",
                ů: "u",
                ű: "u",
                ų: "u",
                Ŵ: "W",
                ŵ: "w",
                Ŷ: "Y",
                ŷ: "y",
                Ÿ: "Y",
                Ź: "Z",
                Ż: "Z",
                Ž: "Z",
                ź: "z",
                ż: "z",
                ž: "z",
                Ĳ: "IJ",
                ĳ: "ij",
                Œ: "Oe",
                œ: "oe",
                ŉ: "'n",
                ſ: "s"
            },
            L = {
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;",
                '"': "&quot;",
                "'": "&#39;"
            },
            te = {
                "&amp;": "&",
                "&lt;": "<",
                "&gt;": ">",
                "&quot;": '"',
                "&#39;": "'"
            },
            pe = {
                "\\": "\\",
                "'": "'",
                "\n": "n",
                "\r": "r",
                "\u2028": "u2028",
                "\u2029": "u2029"
            },
            ot = parseFloat,
            Ae = parseInt,
            lt = typeof gs == "object" && gs && gs.Object === Object && gs,
            qt = typeof self == "object" && self && self.Object === Object && self,
            Qe = lt || qt || Function("return this")(),
            at = e && !e.nodeType && e,
            Tt = at && !0 && i && !i.nodeType && i,
            fr = Tt && Tt.exports === at,
            zt = fr && lt.process,
            ft = function() {
                try {
                    var M = Tt && Tt.require && Tt.require("util").types;
                    return M || zt && zt.binding && zt.binding("util")
                } catch {}
            }(),
            rr = ft && ft.isArrayBuffer,
            zr = ft && ft.isDate,
            Cr = ft && ft.isMap,
            Jr = ft && ft.isRegExp,
            Gn = ft && ft.isSet,
            ki = ft && ft.isTypedArray;

        function Bt(M, Y, B) {
            switch (B.length) {
                case 0:
                    return M.call(Y);
                case 1:
                    return M.call(Y, B[0]);
                case 2:
                    return M.call(Y, B[0], B[1]);
                case 3:
                    return M.call(Y, B[0], B[1], B[2])
            }
            return M.apply(Y, B)
        }

        function Wp(M, Y, B, ge) {
            for (var Te = -1, tt = M == null ? 0 : M.length; ++Te < tt;) {
                var Ft = M[Te];
                Y(ge, Ft, B(Ft), M)
            }
            return ge
        }

        function Tr(M, Y) {
            for (var B = -1, ge = M == null ? 0 : M.length; ++B < ge && Y(M[B], B, M) !== !1;);
            return M
        }

        function Yp(M, Y) {
            for (var B = M == null ? 0 : M.length; B-- && Y(M[B], B, M) !== !1;);
            return M
        }

        function eh(M, Y) {
            for (var B = -1, ge = M == null ? 0 : M.length; ++B < ge;)
                if (!Y(M[B], B, M)) return !1;
            return !0
        }

        function xi(M, Y) {
            for (var B = -1, ge = M == null ? 0 : M.length, Te = 0, tt = []; ++B < ge;) {
                var Ft = M[B];
                Y(Ft, B, M) && (tt[Te++] = Ft)
            }
            return tt
        }

        function eo(M, Y) {
            var B = M == null ? 0 : M.length;
            return !!B && mn(M, Y, 0) > -1
        }

        function Ra(M, Y, B) {
            for (var ge = -1, Te = M == null ? 0 : M.length; ++ge < Te;)
                if (B(Y, M[ge])) return !0;
            return !1
        }

        function vt(M, Y) {
            for (var B = -1, ge = M == null ? 0 : M.length, Te = Array(ge); ++B < ge;) Te[B] = Y(M[B], B, M);
            return Te
        }

        function Oi(M, Y) {
            for (var B = -1, ge = Y.length, Te = M.length; ++B < ge;) M[Te + B] = Y[B];
            return M
        }

        function Na(M, Y, B, ge) {
            var Te = -1,
                tt = M == null ? 0 : M.length;
            for (ge && tt && (B = M[++Te]); ++Te < tt;) B = Y(B, M[Te], Te, M);
            return B
        }

        function Jp(M, Y, B, ge) {
            var Te = M == null ? 0 : M.length;
            for (ge && Te && (B = M[--Te]); Te--;) B = Y(B, M[Te], Te, M);
            return B
        }

        function $a(M, Y) {
            for (var B = -1, ge = M == null ? 0 : M.length; ++B < ge;)
                if (Y(M[B], B, M)) return !0;
            return !1
        }
        var Qp = ja("length");

        function Xp(M) {
            return M.split("")
        }

        function Zp(M) {
            return M.match(Ut) || []
        }

        function th(M, Y, B) {
            var ge;
            return B(M, function(Te, tt, Ft) {
                if (Y(Te, tt, Ft)) return ge = tt, !1
            }), ge
        }

        function to(M, Y, B, ge) {
            for (var Te = M.length, tt = B + (ge ? 1 : -1); ge ? tt-- : ++tt < Te;)
                if (Y(M[tt], tt, M)) return tt;
            return -1
        }

        function mn(M, Y, B) {
            return Y === Y ? lg(M, Y, B) : to(M, rh, B)
        }

        function eg(M, Y, B, ge) {
            for (var Te = B - 1, tt = M.length; ++Te < tt;)
                if (ge(M[Te], Y)) return Te;
            return -1
        }

        function rh(M) {
            return M !== M
        }

        function ih(M, Y) {
            var B = M == null ? 0 : M.length;
            return B ? Ma(M, Y) / B : J
        }

        function ja(M) {
            return function(Y) {
                return Y == null ? t : Y[M]
            }
        }

        function La(M) {
            return function(Y) {
                return M == null ? t : M[Y]
            }
        }

        function nh(M, Y, B, ge, Te) {
            return Te(M, function(tt, Ft, ct) {
                B = ge ? (ge = !1, tt) : Y(B, tt, Ft, ct)
            }), B
        }

        function tg(M, Y) {
            var B = M.length;
            for (M.sort(Y); B--;) M[B] = M[B].value;
            return M
        }

        function Ma(M, Y) {
            for (var B, ge = -1, Te = M.length; ++ge < Te;) {
                var tt = Y(M[ge]);
                tt !== t && (B = B === t ? tt : B + tt)
            }
            return B
        }

        function Ua(M, Y) {
            for (var B = -1, ge = Array(M); ++B < M;) ge[B] = Y(B);
            return ge
        }

        function rg(M, Y) {
            return vt(Y, function(B) {
                return [B, M[B]]
            })
        }

        function sh(M) {
            return M && M.slice(0, uh(M) + 1).replace(xt, "")
        }

        function wr(M) {
            return function(Y) {
                return M(Y)
            }
        }

        function qa(M, Y) {
            return vt(Y, function(B) {
                return M[B]
            })
        }

        function Wn(M, Y) {
            return M.has(Y)
        }

        function oh(M, Y) {
            for (var B = -1, ge = M.length; ++B < ge && mn(Y, M[B], 0) > -1;);
            return B
        }

        function ah(M, Y) {
            for (var B = M.length; B-- && mn(Y, M[B], 0) > -1;);
            return B
        }

        function ig(M, Y) {
            for (var B = M.length, ge = 0; B--;) M[B] === Y && ++ge;
            return ge
        }
        var ng = La(I),
            sg = La(L);

        function og(M) {
            return "\\" + pe[M]
        }

        function ag(M, Y) {
            return M == null ? t : M[Y]
        }

        function bn(M) {
            return Xs.test(M)
        }

        function cg(M) {
            return Ki.test(M)
        }

        function ug(M) {
            for (var Y, B = []; !(Y = M.next()).done;) B.push(Y.value);
            return B
        }

        function za(M) {
            var Y = -1,
                B = Array(M.size);
            return M.forEach(function(ge, Te) {
                B[++Y] = [Te, ge]
            }), B
        }

        function ch(M, Y) {
            return function(B) {
                return M(Y(B))
            }
        }

        function Pi(M, Y) {
            for (var B = -1, ge = M.length, Te = 0, tt = []; ++B < ge;) {
                var Ft = M[B];
                (Ft === Y || Ft === v) && (M[B] = v, tt[Te++] = B)
            }
            return tt
        }

        function ro(M) {
            var Y = -1,
                B = Array(M.size);
            return M.forEach(function(ge) {
                B[++Y] = ge
            }), B
        }

        function hg(M) {
            var Y = -1,
                B = Array(M.size);
            return M.forEach(function(ge) {
                B[++Y] = [ge, ge]
            }), B
        }

        function lg(M, Y, B) {
            for (var ge = B - 1, Te = M.length; ++ge < Te;)
                if (M[ge] === Y) return ge;
            return -1
        }

        function fg(M, Y, B) {
            for (var ge = B + 1; ge--;)
                if (M[ge] === Y) return ge;
            return ge
        }

        function wn(M) {
            return bn(M) ? pg(M) : Qp(M)
        }

        function Fr(M) {
            return bn(M) ? gg(M) : Xp(M)
        }

        function uh(M) {
            for (var Y = M.length; Y-- && Ct.test(M.charAt(Y)););
            return Y
        }
        var dg = La(te);

        function pg(M) {
            for (var Y = _n.lastIndex = 0; _n.test(M);) ++Y;
            return Y
        }

        function gg(M) {
            return M.match(_n) || []
        }

        function yg(M) {
            return M.match(Qs) || []
        }
        var vg = function M(Y) {
                Y = Y == null ? Qe : En.defaults(Qe.Object(), Y, En.pick(Qe, Zs));
                var B = Y.Array,
                    ge = Y.Date,
                    Te = Y.Error,
                    tt = Y.Function,
                    Ft = Y.Math,
                    ct = Y.Object,
                    Fa = Y.RegExp,
                    _g = Y.String,
                    Ar = Y.TypeError,
                    io = B.prototype,
                    mg = tt.prototype,
                    Dn = ct.prototype,
                    no = Y["__core-js_shared__"],
                    so = mg.toString,
                    it = Dn.hasOwnProperty,
                    bg = 0,
                    hh = function() {
                        var r = /[^.]+$/.exec(no && no.keys && no.keys.IE_PROTO || "");
                        return r ? "Symbol(src)_1." + r : ""
                    }(),
                    oo = Dn.toString,
                    wg = so.call(ct),
                    Eg = Qe._,
                    Dg = Fa("^" + so.call(it).replace(It, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
                    ao = fr ? Y.Buffer : t,
                    Ci = Y.Symbol,
                    co = Y.Uint8Array,
                    lh = ao ? ao.allocUnsafe : t,
                    uo = ch(ct.getPrototypeOf, ct),
                    fh = ct.create,
                    dh = Dn.propertyIsEnumerable,
                    ho = io.splice,
                    ph = Ci ? Ci.isConcatSpreadable : t,
                    Yn = Ci ? Ci.iterator : t,
                    Vi = Ci ? Ci.toStringTag : t,
                    lo = function() {
                        try {
                            var r = Qi(ct, "defineProperty");
                            return r({}, "", {}), r
                        } catch {}
                    }(),
                    Sg = Y.clearTimeout !== Qe.clearTimeout && Y.clearTimeout,
                    Ig = ge && ge.now !== Qe.Date.now && ge.now,
                    xg = Y.setTimeout !== Qe.setTimeout && Y.setTimeout,
                    fo = Ft.ceil,
                    po = Ft.floor,
                    Ha = ct.getOwnPropertySymbols,
                    Og = ao ? ao.isBuffer : t,
                    gh = Y.isFinite,
                    Pg = io.join,
                    Cg = ch(ct.keys, ct),
                    Ht = Ft.max,
                    Jt = Ft.min,
                    Tg = ge.now,
                    Ag = Y.parseInt,
                    yh = Ft.random,
                    Rg = io.reverse,
                    Ba = Qi(Y, "DataView"),
                    Jn = Qi(Y, "Map"),
                    Ka = Qi(Y, "Promise"),
                    Sn = Qi(Y, "Set"),
                    Qn = Qi(Y, "WeakMap"),
                    Xn = Qi(ct, "create"),
                    go = Qn && new Qn,
                    In = {},
                    Ng = Xi(Ba),
                    $g = Xi(Jn),
                    jg = Xi(Ka),
                    Lg = Xi(Sn),
                    Mg = Xi(Qn),
                    yo = Ci ? Ci.prototype : t,
                    Zn = yo ? yo.valueOf : t,
                    vh = yo ? yo.toString : t;

                function _(r) {
                    if (Pt(r) && !Re(r) && !(r instanceof We)) {
                        if (r instanceof Rr) return r;
                        if (it.call(r, "__wrapped__")) return _l(r)
                    }
                    return new Rr(r)
                }
                var xn = function() {
                    function r() {}
                    return function(n) {
                        if (!wt(n)) return {};
                        if (fh) return fh(n);
                        r.prototype = n;
                        var a = new r;
                        return r.prototype = t, a
                    }
                }();

                function vo() {}

                function Rr(r, n) {
                    this.__wrapped__ = r, this.__actions__ = [], this.__chain__ = !!n, this.__index__ = 0, this.__values__ = t
                }
                _.templateSettings = {
                    escape: Dt,
                    evaluate: St,
                    interpolate: bt,
                    variable: "",
                    imports: {
                        _
                    }
                }, _.prototype = vo.prototype, _.prototype.constructor = _, Rr.prototype = xn(vo.prototype), Rr.prototype.constructor = Rr;

                function We(r) {
                    this.__wrapped__ = r, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = re, this.__views__ = []
                }

                function Ug() {
                    var r = new We(this.__wrapped__);
                    return r.__actions__ = dr(this.__actions__), r.__dir__ = this.__dir__, r.__filtered__ = this.__filtered__, r.__iteratees__ = dr(this.__iteratees__), r.__takeCount__ = this.__takeCount__, r.__views__ = dr(this.__views__), r
                }

                function qg() {
                    if (this.__filtered__) {
                        var r = new We(this);
                        r.__dir__ = -1, r.__filtered__ = !0
                    } else r = this.clone(), r.__dir__ *= -1;
                    return r
                }

                function zg() {
                    var r = this.__wrapped__.value(),
                        n = this.__dir__,
                        a = Re(r),
                        h = n < 0,
                        g = a ? r.length : 0,
                        m = Xy(0, g, this.__views__),
                        P = m.start,
                        N = m.end,
                        q = N - P,
                        X = h ? N : P - 1,
                        Z = this.__iteratees__,
                        ie = Z.length,
                        he = 0,
                        ye = Jt(q, this.__takeCount__);
                    if (!a || !h && g == q && ye == q) return Fh(r, this.__actions__);
                    var Ee = [];
                    e: for (; q-- && he < ye;) {
                        X += n;
                        for (var ze = -1, De = r[X]; ++ze < ie;) {
                            var Ve = Z[ze],
                                Xe = Ve.iteratee,
                                Sr = Ve.type,
                                sr = Xe(De);
                            if (Sr == T) De = sr;
                            else if (!sr) {
                                if (Sr == w) continue e;
                                break e
                            }
                        }
                        Ee[he++] = De
                    }
                    return Ee
                }
                We.prototype = xn(vo.prototype), We.prototype.constructor = We;

                function Gi(r) {
                    var n = -1,
                        a = r == null ? 0 : r.length;
                    for (this.clear(); ++n < a;) {
                        var h = r[n];
                        this.set(h[0], h[1])
                    }
                }

                function Fg() {
                    this.__data__ = Xn ? Xn(null) : {}, this.size = 0
                }

                function Hg(r) {
                    var n = this.has(r) && delete this.__data__[r];
                    return this.size -= n ? 1 : 0, n
                }

                function Bg(r) {
                    var n = this.__data__;
                    if (Xn) {
                        var a = n[r];
                        return a === y ? t : a
                    }
                    return it.call(n, r) ? n[r] : t
                }

                function Kg(r) {
                    var n = this.__data__;
                    return Xn ? n[r] !== t : it.call(n, r)
                }

                function kg(r, n) {
                    var a = this.__data__;
                    return this.size += this.has(r) ? 0 : 1, a[r] = Xn && n === t ? y : n, this
                }
                Gi.prototype.clear = Fg, Gi.prototype.delete = Hg, Gi.prototype.get = Bg, Gi.prototype.has = Kg, Gi.prototype.set = kg;

                function oi(r) {
                    var n = -1,
                        a = r == null ? 0 : r.length;
                    for (this.clear(); ++n < a;) {
                        var h = r[n];
                        this.set(h[0], h[1])
                    }
                }

                function Vg() {
                    this.__data__ = [], this.size = 0
                }

                function Gg(r) {
                    var n = this.__data__,
                        a = _o(n, r);
                    if (a < 0) return !1;
                    var h = n.length - 1;
                    return a == h ? n.pop() : ho.call(n, a, 1), --this.size, !0
                }

                function Wg(r) {
                    var n = this.__data__,
                        a = _o(n, r);
                    return a < 0 ? t : n[a][1]
                }

                function Yg(r) {
                    return _o(this.__data__, r) > -1
                }

                function Jg(r, n) {
                    var a = this.__data__,
                        h = _o(a, r);
                    return h < 0 ? (++this.size, a.push([r, n])) : a[h][1] = n, this
                }
                oi.prototype.clear = Vg, oi.prototype.delete = Gg, oi.prototype.get = Wg, oi.prototype.has = Yg, oi.prototype.set = Jg;

                function ai(r) {
                    var n = -1,
                        a = r == null ? 0 : r.length;
                    for (this.clear(); ++n < a;) {
                        var h = r[n];
                        this.set(h[0], h[1])
                    }
                }

                function Qg() {
                    this.size = 0, this.__data__ = {
                        hash: new Gi,
                        map: new(Jn || oi),
                        string: new Gi
                    }
                }

                function Xg(r) {
                    var n = To(this, r).delete(r);
                    return this.size -= n ? 1 : 0, n
                }

                function Zg(r) {
                    return To(this, r).get(r)
                }

                function ey(r) {
                    return To(this, r).has(r)
                }

                function ty(r, n) {
                    var a = To(this, r),
                        h = a.size;
                    return a.set(r, n), this.size += a.size == h ? 0 : 1, this
                }
                ai.prototype.clear = Qg, ai.prototype.delete = Xg, ai.prototype.get = Zg, ai.prototype.has = ey, ai.prototype.set = ty;

                function Wi(r) {
                    var n = -1,
                        a = r == null ? 0 : r.length;
                    for (this.__data__ = new ai; ++n < a;) this.add(r[n])
                }

                function ry(r) {
                    return this.__data__.set(r, y), this
                }

                function iy(r) {
                    return this.__data__.has(r)
                }
                Wi.prototype.add = Wi.prototype.push = ry, Wi.prototype.has = iy;

                function Hr(r) {
                    var n = this.__data__ = new oi(r);
                    this.size = n.size
                }

                function ny() {
                    this.__data__ = new oi, this.size = 0
                }

                function sy(r) {
                    var n = this.__data__,
                        a = n.delete(r);
                    return this.size = n.size, a
                }

                function oy(r) {
                    return this.__data__.get(r)
                }

                function ay(r) {
                    return this.__data__.has(r)
                }

                function cy(r, n) {
                    var a = this.__data__;
                    if (a instanceof oi) {
                        var h = a.__data__;
                        if (!Jn || h.length < o - 1) return h.push([r, n]), this.size = ++a.size, this;
                        a = this.__data__ = new ai(h)
                    }
                    return a.set(r, n), this.size = a.size, this
                }
                Hr.prototype.clear = ny, Hr.prototype.delete = sy, Hr.prototype.get = oy, Hr.prototype.has = ay, Hr.prototype.set = cy;

                function _h(r, n) {
                    var a = Re(r),
                        h = !a && Zi(r),
                        g = !a && !h && $i(r),
                        m = !a && !h && !g && Tn(r),
                        P = a || h || g || m,
                        N = P ? Ua(r.length, _g) : [],
                        q = N.length;
                    for (var X in r)(n || it.call(r, X)) && !(P && (X == "length" || g && (X == "offset" || X == "parent") || m && (X == "buffer" || X == "byteLength" || X == "byteOffset") || li(X, q))) && N.push(X);
                    return N
                }

                function mh(r) {
                    var n = r.length;
                    return n ? r[tc(0, n - 1)] : t
                }

                function uy(r, n) {
                    return Ao(dr(r), Yi(n, 0, r.length))
                }

                function hy(r) {
                    return Ao(dr(r))
                }

                function ka(r, n, a) {
                    (a !== t && !Br(r[n], a) || a === t && !(n in r)) && ci(r, n, a)
                }

                function es(r, n, a) {
                    var h = r[n];
                    (!(it.call(r, n) && Br(h, a)) || a === t && !(n in r)) && ci(r, n, a)
                }

                function _o(r, n) {
                    for (var a = r.length; a--;)
                        if (Br(r[a][0], n)) return a;
                    return -1
                }

                function ly(r, n, a, h) {
                    return Ti(r, function(g, m, P) {
                        n(h, g, a(g), P)
                    }), h
                }

                function bh(r, n) {
                    return r && Xr(n, Kt(n), r)
                }

                function fy(r, n) {
                    return r && Xr(n, gr(n), r)
                }

                function ci(r, n, a) {
                    n == "__proto__" && lo ? lo(r, n, {
                        configurable: !0,
                        enumerable: !0,
                        value: a,
                        writable: !0
                    }) : r[n] = a
                }

                function Va(r, n) {
                    for (var a = -1, h = n.length, g = B(h), m = r == null; ++a < h;) g[a] = m ? t : xc(r, n[a]);
                    return g
                }

                function Yi(r, n, a) {
                    return r === r && (a !== t && (r = r <= a ? r : a), n !== t && (r = r >= n ? r : n)), r
                }

                function Nr(r, n, a, h, g, m) {
                    var P, N = n & D,
                        q = n & S,
                        X = n & x;
                    if (a && (P = g ? a(r, h, g, m) : a(r)), P !== t) return P;
                    if (!wt(r)) return r;
                    var Z = Re(r);
                    if (Z) {
                        if (P = e0(r), !N) return dr(r, P)
                    } else {
                        var ie = Qt(r),
                            he = ie == ae || ie == fe;
                        if ($i(r)) return Kh(r, N);
                        if (ie == Le || ie == le || he && !g) {
                            if (P = q || he ? {} : ul(r), !N) return q ? By(r, fy(P, r)) : Hy(r, bh(P, r))
                        } else {
                            if (!nt[ie]) return g ? r : {};
                            P = t0(r, ie, N)
                        }
                    }
                    m || (m = new Hr);
                    var ye = m.get(r);
                    if (ye) return ye;
                    m.set(r, P), Ul(r) ? r.forEach(function(De) {
                        P.add(Nr(De, n, a, De, r, m))
                    }) : Ll(r) && r.forEach(function(De, Ve) {
                        P.set(Ve, Nr(De, n, a, Ve, r, m))
                    });
                    var Ee = X ? q ? fc : lc : q ? gr : Kt,
                        ze = Z ? t : Ee(r);
                    return Tr(ze || r, function(De, Ve) {
                        ze && (Ve = De, De = r[Ve]), es(P, Ve, Nr(De, n, a, Ve, r, m))
                    }), P
                }

                function dy(r) {
                    var n = Kt(r);
                    return function(a) {
                        return wh(a, r, n)
                    }
                }

                function wh(r, n, a) {
                    var h = a.length;
                    if (r == null) return !h;
                    for (r = ct(r); h--;) {
                        var g = a[h],
                            m = n[g],
                            P = r[g];
                        if (P === t && !(g in r) || !m(P)) return !1
                    }
                    return !0
                }

                function Eh(r, n, a) {
                    if (typeof r != "function") throw new Ar(l);
                    return as(function() {
                        r.apply(t, a)
                    }, n)
                }

                function ts(r, n, a, h) {
                    var g = -1,
                        m = eo,
                        P = !0,
                        N = r.length,
                        q = [],
                        X = n.length;
                    if (!N) return q;
                    a && (n = vt(n, wr(a))), h ? (m = Ra, P = !1) : n.length >= o && (m = Wn, P = !1, n = new Wi(n));
                    e: for (; ++g < N;) {
                        var Z = r[g],
                            ie = a == null ? Z : a(Z);
                        if (Z = h || Z !== 0 ? Z : 0, P && ie === ie) {
                            for (var he = X; he--;)
                                if (n[he] === ie) continue e;
                            q.push(Z)
                        } else m(n, ie, h) || q.push(Z)
                    }
                    return q
                }
                var Ti = Yh(Qr),
                    Dh = Yh(Wa, !0);

                function py(r, n) {
                    var a = !0;
                    return Ti(r, function(h, g, m) {
                        return a = !!n(h, g, m), a
                    }), a
                }

                function mo(r, n, a) {
                    for (var h = -1, g = r.length; ++h < g;) {
                        var m = r[h],
                            P = n(m);
                        if (P != null && (N === t ? P === P && !Dr(P) : a(P, N))) var N = P,
                            q = m
                    }
                    return q
                }

                function gy(r, n, a, h) {
                    var g = r.length;
                    for (a = Me(a), a < 0 && (a = -a > g ? 0 : g + a), h = h === t || h > g ? g : Me(h), h < 0 && (h += g), h = a > h ? 0 : zl(h); a < h;) r[a++] = n;
                    return r
                }

                function Sh(r, n) {
                    var a = [];
                    return Ti(r, function(h, g, m) {
                        n(h, g, m) && a.push(h)
                    }), a
                }

                function Gt(r, n, a, h, g) {
                    var m = -1,
                        P = r.length;
                    for (a || (a = i0), g || (g = []); ++m < P;) {
                        var N = r[m];
                        n > 0 && a(N) ? n > 1 ? Gt(N, n - 1, a, h, g) : Oi(g, N) : h || (g[g.length] = N)
                    }
                    return g
                }
                var Ga = Jh(),
                    Ih = Jh(!0);

                function Qr(r, n) {
                    return r && Ga(r, n, Kt)
                }

                function Wa(r, n) {
                    return r && Ih(r, n, Kt)
                }

                function bo(r, n) {
                    return xi(n, function(a) {
                        return fi(r[a])
                    })
                }

                function Ji(r, n) {
                    n = Ri(n, r);
                    for (var a = 0, h = n.length; r != null && a < h;) r = r[Zr(n[a++])];
                    return a && a == h ? r : t
                }

                function xh(r, n, a) {
                    var h = n(r);
                    return Re(r) ? h : Oi(h, a(r))
                }

                function ir(r) {
                    return r == null ? r === t ? qe : Ke : Vi && Vi in ct(r) ? Qy(r) : h0(r)
                }

                function Ya(r, n) {
                    return r > n
                }

                function yy(r, n) {
                    return r != null && it.call(r, n)
                }

                function vy(r, n) {
                    return r != null && n in ct(r)
                }

                function _y(r, n, a) {
                    return r >= Jt(n, a) && r < Ht(n, a)
                }

                function Ja(r, n, a) {
                    for (var h = a ? Ra : eo, g = r[0].length, m = r.length, P = m, N = B(m), q = 1 / 0, X = []; P--;) {
                        var Z = r[P];
                        P && n && (Z = vt(Z, wr(n))), q = Jt(Z.length, q), N[P] = !a && (n || g >= 120 && Z.length >= 120) ? new Wi(P && Z) : t
                    }
                    Z = r[0];
                    var ie = -1,
                        he = N[0];
                    e: for (; ++ie < g && X.length < q;) {
                        var ye = Z[ie],
                            Ee = n ? n(ye) : ye;
                        if (ye = a || ye !== 0 ? ye : 0, !(he ? Wn(he, Ee) : h(X, Ee, a))) {
                            for (P = m; --P;) {
                                var ze = N[P];
                                if (!(ze ? Wn(ze, Ee) : h(r[P], Ee, a))) continue e
                            }
                            he && he.push(Ee), X.push(ye)
                        }
                    }
                    return X
                }

                function my(r, n, a, h) {
                    return Qr(r, function(g, m, P) {
                        n(h, a(g), m, P)
                    }), h
                }

                function rs(r, n, a) {
                    n = Ri(n, r), r = dl(r, n);
                    var h = r == null ? r : r[Zr(jr(n))];
                    return h == null ? t : Bt(h, r, a)
                }

                function Oh(r) {
                    return Pt(r) && ir(r) == le
                }

                function by(r) {
                    return Pt(r) && ir(r) == Se
                }

                function wy(r) {
                    return Pt(r) && ir(r) == j
                }

                function is(r, n, a, h, g) {
                    return r === n ? !0 : r == null || n == null || !Pt(r) && !Pt(n) ? r !== r && n !== n : Ey(r, n, a, h, is, g)
                }

                function Ey(r, n, a, h, g, m) {
                    var P = Re(r),
                        N = Re(n),
                        q = P ? _e : Qt(r),
                        X = N ? _e : Qt(n);
                    q = q == le ? Le : q, X = X == le ? Le : X;
                    var Z = q == Le,
                        ie = X == Le,
                        he = q == X;
                    if (he && $i(r)) {
                        if (!$i(n)) return !1;
                        P = !0, Z = !1
                    }
                    if (he && !Z) return m || (m = new Hr), P || Tn(r) ? ol(r, n, a, h, g, m) : Yy(r, n, q, a, h, g, m);
                    if (!(a & O)) {
                        var ye = Z && it.call(r, "__wrapped__"),
                            Ee = ie && it.call(n, "__wrapped__");
                        if (ye || Ee) {
                            var ze = ye ? r.value() : r,
                                De = Ee ? n.value() : n;
                            return m || (m = new Hr), g(ze, De, a, h, m)
                        }
                    }
                    return he ? (m || (m = new Hr), Jy(r, n, a, h, g, m)) : !1
                }

                function Dy(r) {
                    return Pt(r) && Qt(r) == Ie
                }

                function Qa(r, n, a, h) {
                    var g = a.length,
                        m = g,
                        P = !h;
                    if (r == null) return !m;
                    for (r = ct(r); g--;) {
                        var N = a[g];
                        if (P && N[2] ? N[1] !== r[N[0]] : !(N[0] in r)) return !1
                    }
                    for (; ++g < m;) {
                        N = a[g];
                        var q = N[0],
                            X = r[q],
                            Z = N[1];
                        if (P && N[2]) {
                            if (X === t && !(q in r)) return !1
                        } else {
                            var ie = new Hr;
                            if (h) var he = h(X, Z, q, r, n, ie);
                            if (!(he === t ? is(Z, X, O | F, h, ie) : he)) return !1
                        }
                    }
                    return !0
                }

                function Ph(r) {
                    if (!wt(r) || s0(r)) return !1;
                    var n = fi(r) ? Dg : ya;
                    return n.test(Xi(r))
                }

                function Sy(r) {
                    return Pt(r) && ir(r) == Ue
                }

                function Iy(r) {
                    return Pt(r) && Qt(r) == xe
                }

                function xy(r) {
                    return Pt(r) && Mo(r.length) && !!st[ir(r)]
                }

                function Ch(r) {
                    return typeof r == "function" ? r : r == null ? yr : typeof r == "object" ? Re(r) ? Rh(r[0], r[1]) : Ah(r) : Ql(r)
                }

                function Xa(r) {
                    if (!os(r)) return Cg(r);
                    var n = [];
                    for (var a in ct(r)) it.call(r, a) && a != "constructor" && n.push(a);
                    return n
                }

                function Oy(r) {
                    if (!wt(r)) return u0(r);
                    var n = os(r),
                        a = [];
                    for (var h in r) h == "constructor" && (n || !it.call(r, h)) || a.push(h);
                    return a
                }

                function Za(r, n) {
                    return r < n
                }

                function Th(r, n) {
                    var a = -1,
                        h = pr(r) ? B(r.length) : [];
                    return Ti(r, function(g, m, P) {
                        h[++a] = n(g, m, P)
                    }), h
                }

                function Ah(r) {
                    var n = pc(r);
                    return n.length == 1 && n[0][2] ? ll(n[0][0], n[0][1]) : function(a) {
                        return a === r || Qa(a, r, n)
                    }
                }

                function Rh(r, n) {
                    return yc(r) && hl(n) ? ll(Zr(r), n) : function(a) {
                        var h = xc(a, r);
                        return h === t && h === n ? Oc(a, r) : is(n, h, O | F)
                    }
                }

                function wo(r, n, a, h, g) {
                    r !== n && Ga(n, function(m, P) {
                        if (g || (g = new Hr), wt(m)) Py(r, n, P, a, wo, h, g);
                        else {
                            var N = h ? h(_c(r, P), m, P + "", r, n, g) : t;
                            N === t && (N = m), ka(r, P, N)
                        }
                    }, gr)
                }

                function Py(r, n, a, h, g, m, P) {
                    var N = _c(r, a),
                        q = _c(n, a),
                        X = P.get(q);
                    if (X) {
                        ka(r, a, X);
                        return
                    }
                    var Z = m ? m(N, q, a + "", r, n, P) : t,
                        ie = Z === t;
                    if (ie) {
                        var he = Re(q),
                            ye = !he && $i(q),
                            Ee = !he && !ye && Tn(q);
                        Z = q, he || ye || Ee ? Re(N) ? Z = N : At(N) ? Z = dr(N) : ye ? (ie = !1, Z = Kh(q, !0)) : Ee ? (ie = !1, Z = kh(q, !0)) : Z = [] : cs(q) || Zi(q) ? (Z = N, Zi(N) ? Z = Fl(N) : (!wt(N) || fi(N)) && (Z = ul(q))) : ie = !1
                    }
                    ie && (P.set(q, Z), g(Z, q, h, m, P), P.delete(q)), ka(r, a, Z)
                }

                function Nh(r, n) {
                    var a = r.length;
                    if (a) return n += n < 0 ? a : 0, li(n, a) ? r[n] : t
                }

                function $h(r, n, a) {
                    n.length ? n = vt(n, function(m) {
                        return Re(m) ? function(P) {
                            return Ji(P, m.length === 1 ? m[0] : m)
                        } : m
                    }) : n = [yr];
                    var h = -1;
                    n = vt(n, wr(me()));
                    var g = Th(r, function(m, P, N) {
                        var q = vt(n, function(X) {
                            return X(m)
                        });
                        return {
                            criteria: q,
                            index: ++h,
                            value: m
                        }
                    });
                    return tg(g, function(m, P) {
                        return Fy(m, P, a)
                    })
                }

                function Cy(r, n) {
                    return jh(r, n, function(a, h) {
                        return Oc(r, h)
                    })
                }

                function jh(r, n, a) {
                    for (var h = -1, g = n.length, m = {}; ++h < g;) {
                        var P = n[h],
                            N = Ji(r, P);
                        a(N, P) && ns(m, Ri(P, r), N)
                    }
                    return m
                }

                function Ty(r) {
                    return function(n) {
                        return Ji(n, r)
                    }
                }

                function ec(r, n, a, h) {
                    var g = h ? eg : mn,
                        m = -1,
                        P = n.length,
                        N = r;
                    for (r === n && (n = dr(n)), a && (N = vt(r, wr(a))); ++m < P;)
                        for (var q = 0, X = n[m], Z = a ? a(X) : X;
                            (q = g(N, Z, q, h)) > -1;) N !== r && ho.call(N, q, 1), ho.call(r, q, 1);
                    return r
                }

                function Lh(r, n) {
                    for (var a = r ? n.length : 0, h = a - 1; a--;) {
                        var g = n[a];
                        if (a == h || g !== m) {
                            var m = g;
                            li(g) ? ho.call(r, g, 1) : nc(r, g)
                        }
                    }
                    return r
                }

                function tc(r, n) {
                    return r + po(yh() * (n - r + 1))
                }

                function Ay(r, n, a, h) {
                    for (var g = -1, m = Ht(fo((n - r) / (a || 1)), 0), P = B(m); m--;) P[h ? m : ++g] = r, r += a;
                    return P
                }

                function rc(r, n) {
                    var a = "";
                    if (!r || n < 1 || n > k) return a;
                    do n % 2 && (a += r), n = po(n / 2), n && (r += r); while (n);
                    return a
                }

                function Be(r, n) {
                    return mc(fl(r, n, yr), r + "")
                }

                function Ry(r) {
                    return mh(An(r))
                }

                function Ny(r, n) {
                    var a = An(r);
                    return Ao(a, Yi(n, 0, a.length))
                }

                function ns(r, n, a, h) {
                    if (!wt(r)) return r;
                    n = Ri(n, r);
                    for (var g = -1, m = n.length, P = m - 1, N = r; N != null && ++g < m;) {
                        var q = Zr(n[g]),
                            X = a;
                        if (q === "__proto__" || q === "constructor" || q === "prototype") return r;
                        if (g != P) {
                            var Z = N[q];
                            X = h ? h(Z, q, N) : t, X === t && (X = wt(Z) ? Z : li(n[g + 1]) ? [] : {})
                        }
                        es(N, q, X), N = N[q]
                    }
                    return r
                }
                var Mh = go ? function(r, n) {
                        return go.set(r, n), r
                    } : yr,
                    $y = lo ? function(r, n) {
                        return lo(r, "toString", {
                            configurable: !0,
                            enumerable: !1,
                            value: Cc(n),
                            writable: !0
                        })
                    } : yr;

                function jy(r) {
                    return Ao(An(r))
                }

                function $r(r, n, a) {
                    var h = -1,
                        g = r.length;
                    n < 0 && (n = -n > g ? 0 : g + n), a = a > g ? g : a, a < 0 && (a += g), g = n > a ? 0 : a - n >>> 0, n >>>= 0;
                    for (var m = B(g); ++h < g;) m[h] = r[h + n];
                    return m
                }

                function Ly(r, n) {
                    var a;
                    return Ti(r, function(h, g, m) {
                        return a = n(h, g, m), !a
                    }), !!a
                }

                function Eo(r, n, a) {
                    var h = 0,
                        g = r == null ? h : r.length;
                    if (typeof n == "number" && n === n && g <= oe) {
                        for (; h < g;) {
                            var m = h + g >>> 1,
                                P = r[m];
                            P !== null && !Dr(P) && (a ? P <= n : P < n) ? h = m + 1 : g = m
                        }
                        return g
                    }
                    return ic(r, n, yr, a)
                }

                function ic(r, n, a, h) {
                    var g = 0,
                        m = r == null ? 0 : r.length;
                    if (m === 0) return 0;
                    n = a(n);
                    for (var P = n !== n, N = n === null, q = Dr(n), X = n === t; g < m;) {
                        var Z = po((g + m) / 2),
                            ie = a(r[Z]),
                            he = ie !== t,
                            ye = ie === null,
                            Ee = ie === ie,
                            ze = Dr(ie);
                        if (P) var De = h || Ee;
                        else X ? De = Ee && (h || he) : N ? De = Ee && he && (h || !ye) : q ? De = Ee && he && !ye && (h || !ze) : ye || ze ? De = !1 : De = h ? ie <= n : ie < n;
                        De ? g = Z + 1 : m = Z
                    }
                    return Jt(m, be)
                }

                function Uh(r, n) {
                    for (var a = -1, h = r.length, g = 0, m = []; ++a < h;) {
                        var P = r[a],
                            N = n ? n(P) : P;
                        if (!a || !Br(N, q)) {
                            var q = N;
                            m[g++] = P === 0 ? 0 : P
                        }
                    }
                    return m
                }

                function qh(r) {
                    return typeof r == "number" ? r : Dr(r) ? J : +r
                }

                function Er(r) {
                    if (typeof r == "string") return r;
                    if (Re(r)) return vt(r, Er) + "";
                    if (Dr(r)) return vh ? vh.call(r) : "";
                    var n = r + "";
                    return n == "0" && 1 / r == -Q ? "-0" : n
                }

                function Ai(r, n, a) {
                    var h = -1,
                        g = eo,
                        m = r.length,
                        P = !0,
                        N = [],
                        q = N;
                    if (a) P = !1, g = Ra;
                    else if (m >= o) {
                        var X = n ? null : Gy(r);
                        if (X) return ro(X);
                        P = !1, g = Wn, q = new Wi
                    } else q = n ? [] : N;
                    e: for (; ++h < m;) {
                        var Z = r[h],
                            ie = n ? n(Z) : Z;
                        if (Z = a || Z !== 0 ? Z : 0, P && ie === ie) {
                            for (var he = q.length; he--;)
                                if (q[he] === ie) continue e;
                            n && q.push(ie), N.push(Z)
                        } else g(q, ie, a) || (q !== N && q.push(ie), N.push(Z))
                    }
                    return N
                }

                function nc(r, n) {
                    return n = Ri(n, r), r = dl(r, n), r == null || delete r[Zr(jr(n))]
                }

                function zh(r, n, a, h) {
                    return ns(r, n, a(Ji(r, n)), h)
                }

                function Do(r, n, a, h) {
                    for (var g = r.length, m = h ? g : -1;
                        (h ? m-- : ++m < g) && n(r[m], m, r););
                    return a ? $r(r, h ? 0 : m, h ? m + 1 : g) : $r(r, h ? m + 1 : 0, h ? g : m)
                }

                function Fh(r, n) {
                    var a = r;
                    return a instanceof We && (a = a.value()), Na(n, function(h, g) {
                        return g.func.apply(g.thisArg, Oi([h], g.args))
                    }, a)
                }

                function sc(r, n, a) {
                    var h = r.length;
                    if (h < 2) return h ? Ai(r[0]) : [];
                    for (var g = -1, m = B(h); ++g < h;)
                        for (var P = r[g], N = -1; ++N < h;) N != g && (m[g] = ts(m[g] || P, r[N], n, a));
                    return Ai(Gt(m, 1), n, a)
                }

                function Hh(r, n, a) {
                    for (var h = -1, g = r.length, m = n.length, P = {}; ++h < g;) {
                        var N = h < m ? n[h] : t;
                        a(P, r[h], N)
                    }
                    return P
                }

                function oc(r) {
                    return At(r) ? r : []
                }

                function ac(r) {
                    return typeof r == "function" ? r : yr
                }

                function Ri(r, n) {
                    return Re(r) ? r : yc(r, n) ? [r] : vl(rt(r))
                }
                var My = Be;

                function Ni(r, n, a) {
                    var h = r.length;
                    return a = a === t ? h : a, !n && a >= h ? r : $r(r, n, a)
                }
                var Bh = Sg || function(r) {
                    return Qe.clearTimeout(r)
                };

                function Kh(r, n) {
                    if (n) return r.slice();
                    var a = r.length,
                        h = lh ? lh(a) : new r.constructor(a);
                    return r.copy(h), h
                }

                function cc(r) {
                    var n = new r.constructor(r.byteLength);
                    return new co(n).set(new co(r)), n
                }

                function Uy(r, n) {
                    var a = n ? cc(r.buffer) : r.buffer;
                    return new r.constructor(a, r.byteOffset, r.byteLength)
                }

                function qy(r) {
                    var n = new r.constructor(r.source, Pr.exec(r));
                    return n.lastIndex = r.lastIndex, n
                }

                function zy(r) {
                    return Zn ? ct(Zn.call(r)) : {}
                }

                function kh(r, n) {
                    var a = n ? cc(r.buffer) : r.buffer;
                    return new r.constructor(a, r.byteOffset, r.length)
                }

                function Vh(r, n) {
                    if (r !== n) {
                        var a = r !== t,
                            h = r === null,
                            g = r === r,
                            m = Dr(r),
                            P = n !== t,
                            N = n === null,
                            q = n === n,
                            X = Dr(n);
                        if (!N && !X && !m && r > n || m && P && q && !N && !X || h && P && q || !a && q || !g) return 1;
                        if (!h && !m && !X && r < n || X && a && g && !h && !m || N && a && g || !P && g || !q) return -1
                    }
                    return 0
                }

                function Fy(r, n, a) {
                    for (var h = -1, g = r.criteria, m = n.criteria, P = g.length, N = a.length; ++h < P;) {
                        var q = Vh(g[h], m[h]);
                        if (q) {
                            if (h >= N) return q;
                            var X = a[h];
                            return q * (X == "desc" ? -1 : 1)
                        }
                    }
                    return r.index - n.index
                }

                function Gh(r, n, a, h) {
                    for (var g = -1, m = r.length, P = a.length, N = -1, q = n.length, X = Ht(m - P, 0), Z = B(q + X), ie = !h; ++N < q;) Z[N] = n[N];
                    for (; ++g < P;)(ie || g < m) && (Z[a[g]] = r[g]);
                    for (; X--;) Z[N++] = r[g++];
                    return Z
                }

                function Wh(r, n, a, h) {
                    for (var g = -1, m = r.length, P = -1, N = a.length, q = -1, X = n.length, Z = Ht(m - N, 0), ie = B(Z + X), he = !h; ++g < Z;) ie[g] = r[g];
                    for (var ye = g; ++q < X;) ie[ye + q] = n[q];
                    for (; ++P < N;)(he || g < m) && (ie[ye + a[P]] = r[g++]);
                    return ie
                }

                function dr(r, n) {
                    var a = -1,
                        h = r.length;
                    for (n || (n = B(h)); ++a < h;) n[a] = r[a];
                    return n
                }

                function Xr(r, n, a, h) {
                    var g = !a;
                    a || (a = {});
                    for (var m = -1, P = n.length; ++m < P;) {
                        var N = n[m],
                            q = h ? h(a[N], r[N], N, a, r) : t;
                        q === t && (q = r[N]), g ? ci(a, N, q) : es(a, N, q)
                    }
                    return a
                }

                function Hy(r, n) {
                    return Xr(r, gc(r), n)
                }

                function By(r, n) {
                    return Xr(r, al(r), n)
                }

                function So(r, n) {
                    return function(a, h) {
                        var g = Re(a) ? Wp : ly,
                            m = n ? n() : {};
                        return g(a, r, me(h, 2), m)
                    }
                }

                function On(r) {
                    return Be(function(n, a) {
                        var h = -1,
                            g = a.length,
                            m = g > 1 ? a[g - 1] : t,
                            P = g > 2 ? a[2] : t;
                        for (m = r.length > 3 && typeof m == "function" ? (g--, m) : t, P && nr(a[0], a[1], P) && (m = g < 3 ? t : m, g = 1), n = ct(n); ++h < g;) {
                            var N = a[h];
                            N && r(n, N, h, m)
                        }
                        return n
                    })
                }

                function Yh(r, n) {
                    return function(a, h) {
                        if (a == null) return a;
                        if (!pr(a)) return r(a, h);
                        for (var g = a.length, m = n ? g : -1, P = ct(a);
                            (n ? m-- : ++m < g) && h(P[m], m, P) !== !1;);
                        return a
                    }
                }

                function Jh(r) {
                    return function(n, a, h) {
                        for (var g = -1, m = ct(n), P = h(n), N = P.length; N--;) {
                            var q = P[r ? N : ++g];
                            if (a(m[q], q, m) === !1) break
                        }
                        return n
                    }
                }

                function Ky(r, n, a) {
                    var h = n & K,
                        g = ss(r);

                    function m() {
                        var P = this && this !== Qe && this instanceof m ? g : r;
                        return P.apply(h ? a : this, arguments)
                    }
                    return m
                }

                function Qh(r) {
                    return function(n) {
                        n = rt(n);
                        var a = bn(n) ? Fr(n) : t,
                            h = a ? a[0] : n.charAt(0),
                            g = a ? Ni(a, 1).join("") : n.slice(1);
                        return h[r]() + g
                    }
                }

                function Pn(r) {
                    return function(n) {
                        return Na(Yl(Wl(n).replace(Vn, "")), r, "")
                    }
                }

                function ss(r) {
                    return function() {
                        var n = arguments;
                        switch (n.length) {
                            case 0:
                                return new r;
                            case 1:
                                return new r(n[0]);
                            case 2:
                                return new r(n[0], n[1]);
                            case 3:
                                return new r(n[0], n[1], n[2]);
                            case 4:
                                return new r(n[0], n[1], n[2], n[3]);
                            case 5:
                                return new r(n[0], n[1], n[2], n[3], n[4]);
                            case 6:
                                return new r(n[0], n[1], n[2], n[3], n[4], n[5]);
                            case 7:
                                return new r(n[0], n[1], n[2], n[3], n[4], n[5], n[6])
                        }
                        var a = xn(r.prototype),
                            h = r.apply(a, n);
                        return wt(h) ? h : a
                    }
                }

                function ky(r, n, a) {
                    var h = ss(r);

                    function g() {
                        for (var m = arguments.length, P = B(m), N = m, q = Cn(g); N--;) P[N] = arguments[N];
                        var X = m < 3 && P[0] !== q && P[m - 1] !== q ? [] : Pi(P, q);
                        if (m -= X.length, m < a) return rl(r, n, Io, g.placeholder, t, P, X, t, t, a - m);
                        var Z = this && this !== Qe && this instanceof g ? h : r;
                        return Bt(Z, this, P)
                    }
                    return g
                }

                function Xh(r) {
                    return function(n, a, h) {
                        var g = ct(n);
                        if (!pr(n)) {
                            var m = me(a, 3);
                            n = Kt(n), a = function(N) {
                                return m(g[N], N, g)
                            }
                        }
                        var P = r(n, a, h);
                        return P > -1 ? g[m ? n[P] : P] : t
                    }
                }

                function Zh(r) {
                    return hi(function(n) {
                        var a = n.length,
                            h = a,
                            g = Rr.prototype.thru;
                        for (r && n.reverse(); h--;) {
                            var m = n[h];
                            if (typeof m != "function") throw new Ar(l);
                            if (g && !P && Co(m) == "wrapper") var P = new Rr([], !0)
                        }
                        for (h = P ? h : a; ++h < a;) {
                            m = n[h];
                            var N = Co(m),
                                q = N == "wrapper" ? dc(m) : t;
                            q && vc(q[0]) && q[1] == (u | U | A | b) && !q[4].length && q[9] == 1 ? P = P[Co(q[0])].apply(P, q[3]) : P = m.length == 1 && vc(m) ? P[N]() : P.thru(m)
                        }
                        return function() {
                            var X = arguments,
                                Z = X[0];
                            if (P && X.length == 1 && Re(Z)) return P.plant(Z).value();
                            for (var ie = 0, he = a ? n[ie].apply(this, X) : Z; ++ie < a;) he = n[ie].call(this, he);
                            return he
                        }
                    })
                }

                function Io(r, n, a, h, g, m, P, N, q, X) {
                    var Z = n & u,
                        ie = n & K,
                        he = n & ne,
                        ye = n & (U | C),
                        Ee = n & G,
                        ze = he ? t : ss(r);

                    function De() {
                        for (var Ve = arguments.length, Xe = B(Ve), Sr = Ve; Sr--;) Xe[Sr] = arguments[Sr];
                        if (ye) var sr = Cn(De),
                            Ir = ig(Xe, sr);
                        if (h && (Xe = Gh(Xe, h, g, ye)), m && (Xe = Wh(Xe, m, P, ye)), Ve -= Ir, ye && Ve < X) {
                            var Rt = Pi(Xe, sr);
                            return rl(r, n, Io, De.placeholder, a, Xe, Rt, N, q, X - Ve)
                        }
                        var Kr = ie ? a : this,
                            pi = he ? Kr[r] : r;
                        return Ve = Xe.length, N ? Xe = l0(Xe, N) : Ee && Ve > 1 && Xe.reverse(), Z && q < Ve && (Xe.length = q), this && this !== Qe && this instanceof De && (pi = ze || ss(pi)), pi.apply(Kr, Xe)
                    }
                    return De
                }

                function el(r, n) {
                    return function(a, h) {
                        return my(a, r, n(h), {})
                    }
                }

                function xo(r, n) {
                    return function(a, h) {
                        var g;
                        if (a === t && h === t) return n;
                        if (a !== t && (g = a), h !== t) {
                            if (g === t) return h;
                            typeof a == "string" || typeof h == "string" ? (a = Er(a), h = Er(h)) : (a = qh(a), h = qh(h)), g = r(a, h)
                        }
                        return g
                    }
                }

                function uc(r) {
                    return hi(function(n) {
                        return n = vt(n, wr(me())), Be(function(a) {
                            var h = this;
                            return r(n, function(g) {
                                return Bt(g, h, a)
                            })
                        })
                    })
                }

                function Oo(r, n) {
                    n = n === t ? " " : Er(n);
                    var a = n.length;
                    if (a < 2) return a ? rc(n, r) : n;
                    var h = rc(n, fo(r / wn(n)));
                    return bn(n) ? Ni(Fr(h), 0, r).join("") : h.slice(0, r)
                }

                function Vy(r, n, a, h) {
                    var g = n & K,
                        m = ss(r);

                    function P() {
                        for (var N = -1, q = arguments.length, X = -1, Z = h.length, ie = B(Z + q), he = this && this !== Qe && this instanceof P ? m : r; ++X < Z;) ie[X] = h[X];
                        for (; q--;) ie[X++] = arguments[++N];
                        return Bt(he, g ? a : this, ie)
                    }
                    return P
                }

                function tl(r) {
                    return function(n, a, h) {
                        return h && typeof h != "number" && nr(n, a, h) && (a = h = t), n = di(n), a === t ? (a = n, n = 0) : a = di(a), h = h === t ? n < a ? 1 : -1 : di(h), Ay(n, a, h, r)
                    }
                }

                function Po(r) {
                    return function(n, a) {
                        return typeof n == "string" && typeof a == "string" || (n = Lr(n), a = Lr(a)), r(n, a)
                    }
                }

                function rl(r, n, a, h, g, m, P, N, q, X) {
                    var Z = n & U,
                        ie = Z ? P : t,
                        he = Z ? t : P,
                        ye = Z ? m : t,
                        Ee = Z ? t : m;
                    n |= Z ? A : E, n &= ~(Z ? E : A), n & $ || (n &= ~(K | ne));
                    var ze = [r, n, g, ye, ie, Ee, he, N, q, X],
                        De = a.apply(t, ze);
                    return vc(r) && pl(De, ze), De.placeholder = h, gl(De, r, n)
                }

                function hc(r) {
                    var n = Ft[r];
                    return function(a, h) {
                        if (a = Lr(a), h = h == null ? 0 : Jt(Me(h), 292), h && gh(a)) {
                            var g = (rt(a) + "e").split("e"),
                                m = n(g[0] + "e" + (+g[1] + h));
                            return g = (rt(m) + "e").split("e"), +(g[0] + "e" + (+g[1] - h))
                        }
                        return n(a)
                    }
                }
                var Gy = Sn && 1 / ro(new Sn([, -0]))[1] == Q ? function(r) {
                    return new Sn(r)
                } : Rc;

                function il(r) {
                    return function(n) {
                        var a = Qt(n);
                        return a == Ie ? za(n) : a == xe ? hg(n) : rg(n, r(n))
                    }
                }

                function ui(r, n, a, h, g, m, P, N) {
                    var q = n & ne;
                    if (!q && typeof r != "function") throw new Ar(l);
                    var X = h ? h.length : 0;
                    if (X || (n &= ~(A | E), h = g = t), P = P === t ? P : Ht(Me(P), 0), N = N === t ? N : Me(N), X -= g ? g.length : 0, n & E) {
                        var Z = h,
                            ie = g;
                        h = g = t
                    }
                    var he = q ? t : dc(r),
                        ye = [r, n, a, h, g, Z, ie, m, P, N];
                    if (he && c0(ye, he), r = ye[0], n = ye[1], a = ye[2], h = ye[3], g = ye[4], N = ye[9] = ye[9] === t ? q ? 0 : r.length : Ht(ye[9] - X, 0), !N && n & (U | C) && (n &= ~(U | C)), !n || n == K) var Ee = Ky(r, n, a);
                    else n == U || n == C ? Ee = ky(r, n, N) : (n == A || n == (K | A)) && !g.length ? Ee = Vy(r, n, a, h) : Ee = Io.apply(t, ye);
                    var ze = he ? Mh : pl;
                    return gl(ze(Ee, ye), r, n)
                }

                function nl(r, n, a, h) {
                    return r === t || Br(r, Dn[a]) && !it.call(h, a) ? n : r
                }

                function sl(r, n, a, h, g, m) {
                    return wt(r) && wt(n) && (m.set(n, r), wo(r, n, t, sl, m), m.delete(n)), r
                }

                function Wy(r) {
                    return cs(r) ? t : r
                }

                function ol(r, n, a, h, g, m) {
                    var P = a & O,
                        N = r.length,
                        q = n.length;
                    if (N != q && !(P && q > N)) return !1;
                    var X = m.get(r),
                        Z = m.get(n);
                    if (X && Z) return X == n && Z == r;
                    var ie = -1,
                        he = !0,
                        ye = a & F ? new Wi : t;
                    for (m.set(r, n), m.set(n, r); ++ie < N;) {
                        var Ee = r[ie],
                            ze = n[ie];
                        if (h) var De = P ? h(ze, Ee, ie, n, r, m) : h(Ee, ze, ie, r, n, m);
                        if (De !== t) {
                            if (De) continue;
                            he = !1;
                            break
                        }
                        if (ye) {
                            if (!$a(n, function(Ve, Xe) {
                                    if (!Wn(ye, Xe) && (Ee === Ve || g(Ee, Ve, a, h, m))) return ye.push(Xe)
                                })) {
                                he = !1;
                                break
                            }
                        } else if (!(Ee === ze || g(Ee, ze, a, h, m))) {
                            he = !1;
                            break
                        }
                    }
                    return m.delete(r), m.delete(n), he
                }

                function Yy(r, n, a, h, g, m, P) {
                    switch (a) {
                        case Ce:
                            if (r.byteLength != n.byteLength || r.byteOffset != n.byteOffset) return !1;
                            r = r.buffer, n = n.buffer;
                        case Se:
                            return !(r.byteLength != n.byteLength || !m(new co(r), new co(n)));
                        case z:
                        case j:
                        case Fe:
                            return Br(+r, +n);
                        case R:
                            return r.name == n.name && r.message == n.message;
                        case Ue:
                        case Ne:
                            return r == n + "";
                        case Ie:
                            var N = za;
                        case xe:
                            var q = h & O;
                            if (N || (N = ro), r.size != n.size && !q) return !1;
                            var X = P.get(r);
                            if (X) return X == n;
                            h |= F, P.set(r, n);
                            var Z = ol(N(r), N(n), h, g, m, P);
                            return P.delete(r), Z;
                        case $e:
                            if (Zn) return Zn.call(r) == Zn.call(n)
                    }
                    return !1
                }

                function Jy(r, n, a, h, g, m) {
                    var P = a & O,
                        N = lc(r),
                        q = N.length,
                        X = lc(n),
                        Z = X.length;
                    if (q != Z && !P) return !1;
                    for (var ie = q; ie--;) {
                        var he = N[ie];
                        if (!(P ? he in n : it.call(n, he))) return !1
                    }
                    var ye = m.get(r),
                        Ee = m.get(n);
                    if (ye && Ee) return ye == n && Ee == r;
                    var ze = !0;
                    m.set(r, n), m.set(n, r);
                    for (var De = P; ++ie < q;) {
                        he = N[ie];
                        var Ve = r[he],
                            Xe = n[he];
                        if (h) var Sr = P ? h(Xe, Ve, he, n, r, m) : h(Ve, Xe, he, r, n, m);
                        if (!(Sr === t ? Ve === Xe || g(Ve, Xe, a, h, m) : Sr)) {
                            ze = !1;
                            break
                        }
                        De || (De = he == "constructor")
                    }
                    if (ze && !De) {
                        var sr = r.constructor,
                            Ir = n.constructor;
                        sr != Ir && "constructor" in r && "constructor" in n && !(typeof sr == "function" && sr instanceof sr && typeof Ir == "function" && Ir instanceof Ir) && (ze = !1)
                    }
                    return m.delete(r), m.delete(n), ze
                }

                function hi(r) {
                    return mc(fl(r, t, wl), r + "")
                }

                function lc(r) {
                    return xh(r, Kt, gc)
                }

                function fc(r) {
                    return xh(r, gr, al)
                }
                var dc = go ? function(r) {
                    return go.get(r)
                } : Rc;

                function Co(r) {
                    for (var n = r.name + "", a = In[n], h = it.call(In, n) ? a.length : 0; h--;) {
                        var g = a[h],
                            m = g.func;
                        if (m == null || m == r) return g.name
                    }
                    return n
                }

                function Cn(r) {
                    var n = it.call(_, "placeholder") ? _ : r;
                    return n.placeholder
                }

                function me() {
                    var r = _.iteratee || Tc;
                    return r = r === Tc ? Ch : r, arguments.length ? r(arguments[0], arguments[1]) : r
                }

                function To(r, n) {
                    var a = r.__data__;
                    return n0(n) ? a[typeof n == "string" ? "string" : "hash"] : a.map
                }

                function pc(r) {
                    for (var n = Kt(r), a = n.length; a--;) {
                        var h = n[a],
                            g = r[h];
                        n[a] = [h, g, hl(g)]
                    }
                    return n
                }

                function Qi(r, n) {
                    var a = ag(r, n);
                    return Ph(a) ? a : t
                }

                function Qy(r) {
                    var n = it.call(r, Vi),
                        a = r[Vi];
                    try {
                        r[Vi] = t;
                        var h = !0
                    } catch {}
                    var g = oo.call(r);
                    return h && (n ? r[Vi] = a : delete r[Vi]), g
                }
                var gc = Ha ? function(r) {
                        return r == null ? [] : (r = ct(r), xi(Ha(r), function(n) {
                            return dh.call(r, n)
                        }))
                    } : Nc,
                    al = Ha ? function(r) {
                        for (var n = []; r;) Oi(n, gc(r)), r = uo(r);
                        return n
                    } : Nc,
                    Qt = ir;
                (Ba && Qt(new Ba(new ArrayBuffer(1))) != Ce || Jn && Qt(new Jn) != Ie || Ka && Qt(Ka.resolve()) != dt || Sn && Qt(new Sn) != xe || Qn && Qt(new Qn) != Pe) && (Qt = function(r) {
                    var n = ir(r),
                        a = n == Le ? r.constructor : t,
                        h = a ? Xi(a) : "";
                    if (h) switch (h) {
                        case Ng:
                            return Ce;
                        case $g:
                            return Ie;
                        case jg:
                            return dt;
                        case Lg:
                            return xe;
                        case Mg:
                            return Pe
                    }
                    return n
                });

                function Xy(r, n, a) {
                    for (var h = -1, g = a.length; ++h < g;) {
                        var m = a[h],
                            P = m.size;
                        switch (m.type) {
                            case "drop":
                                r += P;
                                break;
                            case "dropRight":
                                n -= P;
                                break;
                            case "take":
                                n = Jt(n, r + P);
                                break;
                            case "takeRight":
                                r = Ht(r, n - P);
                                break
                        }
                    }
                    return {
                        start: r,
                        end: n
                    }
                }

                function Zy(r) {
                    var n = r.match(ut);
                    return n ? n[1].split(Mt) : []
                }

                function cl(r, n, a) {
                    n = Ri(n, r);
                    for (var h = -1, g = n.length, m = !1; ++h < g;) {
                        var P = Zr(n[h]);
                        if (!(m = r != null && a(r, P))) break;
                        r = r[P]
                    }
                    return m || ++h != g ? m : (g = r == null ? 0 : r.length, !!g && Mo(g) && li(P, g) && (Re(r) || Zi(r)))
                }

                function e0(r) {
                    var n = r.length,
                        a = new r.constructor(n);
                    return n && typeof r[0] == "string" && it.call(r, "index") && (a.index = r.index, a.input = r.input), a
                }

                function ul(r) {
                    return typeof r.constructor == "function" && !os(r) ? xn(uo(r)) : {}
                }

                function t0(r, n, a) {
                    var h = r.constructor;
                    switch (n) {
                        case Se:
                            return cc(r);
                        case z:
                        case j:
                            return new h(+r);
                        case Ce:
                            return Uy(r, a);
                        case He:
                        case Oe:
                        case ke:
                        case Ge:
                        case Ze:
                        case et:
                        case Je:
                        case er:
                        case lr:
                            return kh(r, a);
                        case Ie:
                            return new h;
                        case Fe:
                        case Ne:
                            return new h(r);
                        case Ue:
                            return qy(r);
                        case xe:
                            return new h;
                        case $e:
                            return zy(r)
                    }
                }

                function r0(r, n) {
                    var a = n.length;
                    if (!a) return r;
                    var h = a - 1;
                    return n[h] = (a > 1 ? "& " : "") + n[h], n = n.join(a > 2 ? ", " : " "), r.replace(Ot, `{
/* [wrapped with ` + n + `] */
`)
                }

                function i0(r) {
                    return Re(r) || Zi(r) || !!(ph && r && r[ph])
                }

                function li(r, n) {
                    var a = typeof r;
                    return n = n ? ? k, !!n && (a == "number" || a != "symbol" && _a.test(r)) && r > -1 && r % 1 == 0 && r < n
                }

                function nr(r, n, a) {
                    if (!wt(a)) return !1;
                    var h = typeof n;
                    return (h == "number" ? pr(a) && li(n, a.length) : h == "string" && n in a) ? Br(a[n], r) : !1
                }

                function yc(r, n) {
                    if (Re(r)) return !1;
                    var a = typeof r;
                    return a == "number" || a == "symbol" || a == "boolean" || r == null || Dr(r) ? !0 : $t.test(r) || !yt.test(r) || n != null && r in ct(n)
                }

                function n0(r) {
                    var n = typeof r;
                    return n == "string" || n == "number" || n == "symbol" || n == "boolean" ? r !== "__proto__" : r === null
                }

                function vc(r) {
                    var n = Co(r),
                        a = _[n];
                    if (typeof a != "function" || !(n in We.prototype)) return !1;
                    if (r === a) return !0;
                    var h = dc(a);
                    return !!h && r === h[0]
                }

                function s0(r) {
                    return !!hh && hh in r
                }
                var o0 = no ? fi : $c;

                function os(r) {
                    var n = r && r.constructor,
                        a = typeof n == "function" && n.prototype || Dn;
                    return r === a
                }

                function hl(r) {
                    return r === r && !wt(r)
                }

                function ll(r, n) {
                    return function(a) {
                        return a == null ? !1 : a[r] === n && (n !== t || r in ct(a))
                    }
                }

                function a0(r) {
                    var n = jo(r, function(h) {
                            return a.size === p && a.clear(), h
                        }),
                        a = n.cache;
                    return n
                }

                function c0(r, n) {
                    var a = r[1],
                        h = n[1],
                        g = a | h,
                        m = g < (K | ne | u),
                        P = h == u && a == U || h == u && a == b && r[7].length <= n[8] || h == (u | b) && n[7].length <= n[8] && a == U;
                    if (!(m || P)) return r;
                    h & K && (r[2] = n[2], g |= a & K ? 0 : $);
                    var N = n[3];
                    if (N) {
                        var q = r[3];
                        r[3] = q ? Gh(q, N, n[4]) : N, r[4] = q ? Pi(r[3], v) : n[4]
                    }
                    return N = n[5], N && (q = r[5], r[5] = q ? Wh(q, N, n[6]) : N, r[6] = q ? Pi(r[5], v) : n[6]), N = n[7], N && (r[7] = N), h & u && (r[8] = r[8] == null ? n[8] : Jt(r[8], n[8])), r[9] == null && (r[9] = n[9]), r[0] = n[0], r[1] = g, r
                }

                function u0(r) {
                    var n = [];
                    if (r != null)
                        for (var a in ct(r)) n.push(a);
                    return n
                }

                function h0(r) {
                    return oo.call(r)
                }

                function fl(r, n, a) {
                    return n = Ht(n === t ? r.length - 1 : n, 0),
                        function() {
                            for (var h = arguments, g = -1, m = Ht(h.length - n, 0), P = B(m); ++g < m;) P[g] = h[n + g];
                            g = -1;
                            for (var N = B(n + 1); ++g < n;) N[g] = h[g];
                            return N[n] = a(P), Bt(r, this, N)
                        }
                }

                function dl(r, n) {
                    return n.length < 2 ? r : Ji(r, $r(n, 0, -1))
                }

                function l0(r, n) {
                    for (var a = r.length, h = Jt(n.length, a), g = dr(r); h--;) {
                        var m = n[h];
                        r[h] = li(m, a) ? g[m] : t
                    }
                    return r
                }

                function _c(r, n) {
                    if (!(n === "constructor" && typeof r[n] == "function") && n != "__proto__") return r[n]
                }
                var pl = yl(Mh),
                    as = xg || function(r, n) {
                        return Qe.setTimeout(r, n)
                    },
                    mc = yl($y);

                function gl(r, n, a) {
                    var h = n + "";
                    return mc(r, r0(h, f0(Zy(h), a)))
                }

                function yl(r) {
                    var n = 0,
                        a = 0;
                    return function() {
                        var h = Tg(),
                            g = de - (h - a);
                        if (a = h, g > 0) {
                            if (++n >= ue) return arguments[0]
                        } else n = 0;
                        return r.apply(t, arguments)
                    }
                }

                function Ao(r, n) {
                    var a = -1,
                        h = r.length,
                        g = h - 1;
                    for (n = n === t ? h : n; ++a < n;) {
                        var m = tc(a, g),
                            P = r[m];
                        r[m] = r[a], r[a] = P
                    }
                    return r.length = n, r
                }
                var vl = a0(function(r) {
                    var n = [];
                    return r.charCodeAt(0) === 46 && n.push(""), r.replace(jt, function(a, h, g, m) {
                        n.push(g ? m.replace(fa, "$1") : h || a)
                    }), n
                });

                function Zr(r) {
                    if (typeof r == "string" || Dr(r)) return r;
                    var n = r + "";
                    return n == "0" && 1 / r == -Q ? "-0" : n
                }

                function Xi(r) {
                    if (r != null) {
                        try {
                            return so.call(r)
                        } catch {}
                        try {
                            return r + ""
                        } catch {}
                    }
                    return ""
                }

                function f0(r, n) {
                    return Tr(we, function(a) {
                        var h = "_." + a[0];
                        n & a[1] && !eo(r, h) && r.push(h)
                    }), r.sort()
                }

                function _l(r) {
                    if (r instanceof We) return r.clone();
                    var n = new Rr(r.__wrapped__, r.__chain__);
                    return n.__actions__ = dr(r.__actions__), n.__index__ = r.__index__, n.__values__ = r.__values__, n
                }

                function d0(r, n, a) {
                    (a ? nr(r, n, a) : n === t) ? n = 1: n = Ht(Me(n), 0);
                    var h = r == null ? 0 : r.length;
                    if (!h || n < 1) return [];
                    for (var g = 0, m = 0, P = B(fo(h / n)); g < h;) P[m++] = $r(r, g, g += n);
                    return P
                }

                function p0(r) {
                    for (var n = -1, a = r == null ? 0 : r.length, h = 0, g = []; ++n < a;) {
                        var m = r[n];
                        m && (g[h++] = m)
                    }
                    return g
                }

                function g0() {
                    var r = arguments.length;
                    if (!r) return [];
                    for (var n = B(r - 1), a = arguments[0], h = r; h--;) n[h - 1] = arguments[h];
                    return Oi(Re(a) ? dr(a) : [a], Gt(n, 1))
                }
                var y0 = Be(function(r, n) {
                        return At(r) ? ts(r, Gt(n, 1, At, !0)) : []
                    }),
                    v0 = Be(function(r, n) {
                        var a = jr(n);
                        return At(a) && (a = t), At(r) ? ts(r, Gt(n, 1, At, !0), me(a, 2)) : []
                    }),
                    _0 = Be(function(r, n) {
                        var a = jr(n);
                        return At(a) && (a = t), At(r) ? ts(r, Gt(n, 1, At, !0), t, a) : []
                    });

                function m0(r, n, a) {
                    var h = r == null ? 0 : r.length;
                    return h ? (n = a || n === t ? 1 : Me(n), $r(r, n < 0 ? 0 : n, h)) : []
                }

                function b0(r, n, a) {
                    var h = r == null ? 0 : r.length;
                    return h ? (n = a || n === t ? 1 : Me(n), n = h - n, $r(r, 0, n < 0 ? 0 : n)) : []
                }

                function w0(r, n) {
                    return r && r.length ? Do(r, me(n, 3), !0, !0) : []
                }

                function E0(r, n) {
                    return r && r.length ? Do(r, me(n, 3), !0) : []
                }

                function D0(r, n, a, h) {
                    var g = r == null ? 0 : r.length;
                    return g ? (a && typeof a != "number" && nr(r, n, a) && (a = 0, h = g), gy(r, n, a, h)) : []
                }

                function ml(r, n, a) {
                    var h = r == null ? 0 : r.length;
                    if (!h) return -1;
                    var g = a == null ? 0 : Me(a);
                    return g < 0 && (g = Ht(h + g, 0)), to(r, me(n, 3), g)
                }

                function bl(r, n, a) {
                    var h = r == null ? 0 : r.length;
                    if (!h) return -1;
                    var g = h - 1;
                    return a !== t && (g = Me(a), g = a < 0 ? Ht(h + g, 0) : Jt(g, h - 1)), to(r, me(n, 3), g, !0)
                }

                function wl(r) {
                    var n = r == null ? 0 : r.length;
                    return n ? Gt(r, 1) : []
                }

                function S0(r) {
                    var n = r == null ? 0 : r.length;
                    return n ? Gt(r, Q) : []
                }

                function I0(r, n) {
                    var a = r == null ? 0 : r.length;
                    return a ? (n = n === t ? 1 : Me(n), Gt(r, n)) : []
                }

                function x0(r) {
                    for (var n = -1, a = r == null ? 0 : r.length, h = {}; ++n < a;) {
                        var g = r[n];
                        h[g[0]] = g[1]
                    }
                    return h
                }

                function El(r) {
                    return r && r.length ? r[0] : t
                }

                function O0(r, n, a) {
                    var h = r == null ? 0 : r.length;
                    if (!h) return -1;
                    var g = a == null ? 0 : Me(a);
                    return g < 0 && (g = Ht(h + g, 0)), mn(r, n, g)
                }

                function P0(r) {
                    var n = r == null ? 0 : r.length;
                    return n ? $r(r, 0, -1) : []
                }
                var C0 = Be(function(r) {
                        var n = vt(r, oc);
                        return n.length && n[0] === r[0] ? Ja(n) : []
                    }),
                    T0 = Be(function(r) {
                        var n = jr(r),
                            a = vt(r, oc);
                        return n === jr(a) ? n = t : a.pop(), a.length && a[0] === r[0] ? Ja(a, me(n, 2)) : []
                    }),
                    A0 = Be(function(r) {
                        var n = jr(r),
                            a = vt(r, oc);
                        return n = typeof n == "function" ? n : t, n && a.pop(), a.length && a[0] === r[0] ? Ja(a, t, n) : []
                    });

                function R0(r, n) {
                    return r == null ? "" : Pg.call(r, n)
                }

                function jr(r) {
                    var n = r == null ? 0 : r.length;
                    return n ? r[n - 1] : t
                }

                function N0(r, n, a) {
                    var h = r == null ? 0 : r.length;
                    if (!h) return -1;
                    var g = h;
                    return a !== t && (g = Me(a), g = g < 0 ? Ht(h + g, 0) : Jt(g, h - 1)), n === n ? fg(r, n, g) : to(r, rh, g, !0)
                }

                function $0(r, n) {
                    return r && r.length ? Nh(r, Me(n)) : t
                }
                var j0 = Be(Dl);

                function Dl(r, n) {
                    return r && r.length && n && n.length ? ec(r, n) : r
                }

                function L0(r, n, a) {
                    return r && r.length && n && n.length ? ec(r, n, me(a, 2)) : r
                }

                function M0(r, n, a) {
                    return r && r.length && n && n.length ? ec(r, n, t, a) : r
                }
                var U0 = hi(function(r, n) {
                    var a = r == null ? 0 : r.length,
                        h = Va(r, n);
                    return Lh(r, vt(n, function(g) {
                        return li(g, a) ? +g : g
                    }).sort(Vh)), h
                });

                function q0(r, n) {
                    var a = [];
                    if (!(r && r.length)) return a;
                    var h = -1,
                        g = [],
                        m = r.length;
                    for (n = me(n, 3); ++h < m;) {
                        var P = r[h];
                        n(P, h, r) && (a.push(P), g.push(h))
                    }
                    return Lh(r, g), a
                }

                function bc(r) {
                    return r == null ? r : Rg.call(r)
                }

                function z0(r, n, a) {
                    var h = r == null ? 0 : r.length;
                    return h ? (a && typeof a != "number" && nr(r, n, a) ? (n = 0, a = h) : (n = n == null ? 0 : Me(n), a = a === t ? h : Me(a)), $r(r, n, a)) : []
                }

                function F0(r, n) {
                    return Eo(r, n)
                }

                function H0(r, n, a) {
                    return ic(r, n, me(a, 2))
                }

                function B0(r, n) {
                    var a = r == null ? 0 : r.length;
                    if (a) {
                        var h = Eo(r, n);
                        if (h < a && Br(r[h], n)) return h
                    }
                    return -1
                }

                function K0(r, n) {
                    return Eo(r, n, !0)
                }

                function k0(r, n, a) {
                    return ic(r, n, me(a, 2), !0)
                }

                function V0(r, n) {
                    var a = r == null ? 0 : r.length;
                    if (a) {
                        var h = Eo(r, n, !0) - 1;
                        if (Br(r[h], n)) return h
                    }
                    return -1
                }

                function G0(r) {
                    return r && r.length ? Uh(r) : []
                }

                function W0(r, n) {
                    return r && r.length ? Uh(r, me(n, 2)) : []
                }

                function Y0(r) {
                    var n = r == null ? 0 : r.length;
                    return n ? $r(r, 1, n) : []
                }

                function J0(r, n, a) {
                    return r && r.length ? (n = a || n === t ? 1 : Me(n), $r(r, 0, n < 0 ? 0 : n)) : []
                }

                function Q0(r, n, a) {
                    var h = r == null ? 0 : r.length;
                    return h ? (n = a || n === t ? 1 : Me(n), n = h - n, $r(r, n < 0 ? 0 : n, h)) : []
                }

                function X0(r, n) {
                    return r && r.length ? Do(r, me(n, 3), !1, !0) : []
                }

                function Z0(r, n) {
                    return r && r.length ? Do(r, me(n, 3)) : []
                }
                var ev = Be(function(r) {
                        return Ai(Gt(r, 1, At, !0))
                    }),
                    tv = Be(function(r) {
                        var n = jr(r);
                        return At(n) && (n = t), Ai(Gt(r, 1, At, !0), me(n, 2))
                    }),
                    rv = Be(function(r) {
                        var n = jr(r);
                        return n = typeof n == "function" ? n : t, Ai(Gt(r, 1, At, !0), t, n)
                    });

                function iv(r) {
                    return r && r.length ? Ai(r) : []
                }

                function nv(r, n) {
                    return r && r.length ? Ai(r, me(n, 2)) : []
                }

                function sv(r, n) {
                    return n = typeof n == "function" ? n : t, r && r.length ? Ai(r, t, n) : []
                }

                function wc(r) {
                    if (!(r && r.length)) return [];
                    var n = 0;
                    return r = xi(r, function(a) {
                        if (At(a)) return n = Ht(a.length, n), !0
                    }), Ua(n, function(a) {
                        return vt(r, ja(a))
                    })
                }

                function Sl(r, n) {
                    if (!(r && r.length)) return [];
                    var a = wc(r);
                    return n == null ? a : vt(a, function(h) {
                        return Bt(n, t, h)
                    })
                }
                var ov = Be(function(r, n) {
                        return At(r) ? ts(r, n) : []
                    }),
                    av = Be(function(r) {
                        return sc(xi(r, At))
                    }),
                    cv = Be(function(r) {
                        var n = jr(r);
                        return At(n) && (n = t), sc(xi(r, At), me(n, 2))
                    }),
                    uv = Be(function(r) {
                        var n = jr(r);
                        return n = typeof n == "function" ? n : t, sc(xi(r, At), t, n)
                    }),
                    hv = Be(wc);

                function lv(r, n) {
                    return Hh(r || [], n || [], es)
                }

                function fv(r, n) {
                    return Hh(r || [], n || [], ns)
                }
                var dv = Be(function(r) {
                    var n = r.length,
                        a = n > 1 ? r[n - 1] : t;
                    return a = typeof a == "function" ? (r.pop(), a) : t, Sl(r, a)
                });

                function Il(r) {
                    var n = _(r);
                    return n.__chain__ = !0, n
                }

                function pv(r, n) {
                    return n(r), r
                }

                function Ro(r, n) {
                    return n(r)
                }
                var gv = hi(function(r) {
                    var n = r.length,
                        a = n ? r[0] : 0,
                        h = this.__wrapped__,
                        g = function(m) {
                            return Va(m, r)
                        };
                    return n > 1 || this.__actions__.length || !(h instanceof We) || !li(a) ? this.thru(g) : (h = h.slice(a, +a + (n ? 1 : 0)), h.__actions__.push({
                        func: Ro,
                        args: [g],
                        thisArg: t
                    }), new Rr(h, this.__chain__).thru(function(m) {
                        return n && !m.length && m.push(t), m
                    }))
                });

                function yv() {
                    return Il(this)
                }

                function vv() {
                    return new Rr(this.value(), this.__chain__)
                }

                function _v() {
                    this.__values__ === t && (this.__values__ = ql(this.value()));
                    var r = this.__index__ >= this.__values__.length,
                        n = r ? t : this.__values__[this.__index__++];
                    return {
                        done: r,
                        value: n
                    }
                }

                function mv() {
                    return this
                }

                function bv(r) {
                    for (var n, a = this; a instanceof vo;) {
                        var h = _l(a);
                        h.__index__ = 0, h.__values__ = t, n ? g.__wrapped__ = h : n = h;
                        var g = h;
                        a = a.__wrapped__
                    }
                    return g.__wrapped__ = r, n
                }

                function wv() {
                    var r = this.__wrapped__;
                    if (r instanceof We) {
                        var n = r;
                        return this.__actions__.length && (n = new We(this)), n = n.reverse(), n.__actions__.push({
                            func: Ro,
                            args: [bc],
                            thisArg: t
                        }), new Rr(n, this.__chain__)
                    }
                    return this.thru(bc)
                }

                function Ev() {
                    return Fh(this.__wrapped__, this.__actions__)
                }
                var Dv = So(function(r, n, a) {
                    it.call(r, a) ? ++r[a] : ci(r, a, 1)
                });

                function Sv(r, n, a) {
                    var h = Re(r) ? eh : py;
                    return a && nr(r, n, a) && (n = t), h(r, me(n, 3))
                }

                function Iv(r, n) {
                    var a = Re(r) ? xi : Sh;
                    return a(r, me(n, 3))
                }
                var xv = Xh(ml),
                    Ov = Xh(bl);

                function Pv(r, n) {
                    return Gt(No(r, n), 1)
                }

                function Cv(r, n) {
                    return Gt(No(r, n), Q)
                }

                function Tv(r, n, a) {
                    return a = a === t ? 1 : Me(a), Gt(No(r, n), a)
                }

                function xl(r, n) {
                    var a = Re(r) ? Tr : Ti;
                    return a(r, me(n, 3))
                }

                function Ol(r, n) {
                    var a = Re(r) ? Yp : Dh;
                    return a(r, me(n, 3))
                }
                var Av = So(function(r, n, a) {
                    it.call(r, a) ? r[a].push(n) : ci(r, a, [n])
                });

                function Rv(r, n, a, h) {
                    r = pr(r) ? r : An(r), a = a && !h ? Me(a) : 0;
                    var g = r.length;
                    return a < 0 && (a = Ht(g + a, 0)), Uo(r) ? a <= g && r.indexOf(n, a) > -1 : !!g && mn(r, n, a) > -1
                }
                var Nv = Be(function(r, n, a) {
                        var h = -1,
                            g = typeof n == "function",
                            m = pr(r) ? B(r.length) : [];
                        return Ti(r, function(P) {
                            m[++h] = g ? Bt(n, P, a) : rs(P, n, a)
                        }), m
                    }),
                    $v = So(function(r, n, a) {
                        ci(r, a, n)
                    });

                function No(r, n) {
                    var a = Re(r) ? vt : Th;
                    return a(r, me(n, 3))
                }

                function jv(r, n, a, h) {
                    return r == null ? [] : (Re(n) || (n = n == null ? [] : [n]), a = h ? t : a, Re(a) || (a = a == null ? [] : [a]), $h(r, n, a))
                }
                var Lv = So(function(r, n, a) {
                    r[a ? 0 : 1].push(n)
                }, function() {
                    return [
                        [],
                        []
                    ]
                });

                function Mv(r, n, a) {
                    var h = Re(r) ? Na : nh,
                        g = arguments.length < 3;
                    return h(r, me(n, 4), a, g, Ti)
                }

                function Uv(r, n, a) {
                    var h = Re(r) ? Jp : nh,
                        g = arguments.length < 3;
                    return h(r, me(n, 4), a, g, Dh)
                }

                function qv(r, n) {
                    var a = Re(r) ? xi : Sh;
                    return a(r, Lo(me(n, 3)))
                }

                function zv(r) {
                    var n = Re(r) ? mh : Ry;
                    return n(r)
                }

                function Fv(r, n, a) {
                    (a ? nr(r, n, a) : n === t) ? n = 1: n = Me(n);
                    var h = Re(r) ? uy : Ny;
                    return h(r, n)
                }

                function Hv(r) {
                    var n = Re(r) ? hy : jy;
                    return n(r)
                }

                function Bv(r) {
                    if (r == null) return 0;
                    if (pr(r)) return Uo(r) ? wn(r) : r.length;
                    var n = Qt(r);
                    return n == Ie || n == xe ? r.size : Xa(r).length
                }

                function Kv(r, n, a) {
                    var h = Re(r) ? $a : Ly;
                    return a && nr(r, n, a) && (n = t), h(r, me(n, 3))
                }
                var kv = Be(function(r, n) {
                        if (r == null) return [];
                        var a = n.length;
                        return a > 1 && nr(r, n[0], n[1]) ? n = [] : a > 2 && nr(n[0], n[1], n[2]) && (n = [n[0]]), $h(r, Gt(n, 1), [])
                    }),
                    $o = Ig || function() {
                        return Qe.Date.now()
                    };

                function Vv(r, n) {
                    if (typeof n != "function") throw new Ar(l);
                    return r = Me(r),
                        function() {
                            if (--r < 1) return n.apply(this, arguments)
                        }
                }

                function Pl(r, n, a) {
                    return n = a ? t : n, n = r && n == null ? r.length : n, ui(r, u, t, t, t, t, n)
                }

                function Cl(r, n) {
                    var a;
                    if (typeof n != "function") throw new Ar(l);
                    return r = Me(r),
                        function() {
                            return --r > 0 && (a = n.apply(this, arguments)), r <= 1 && (n = t), a
                        }
                }
                var Ec = Be(function(r, n, a) {
                        var h = K;
                        if (a.length) {
                            var g = Pi(a, Cn(Ec));
                            h |= A
                        }
                        return ui(r, h, n, a, g)
                    }),
                    Tl = Be(function(r, n, a) {
                        var h = K | ne;
                        if (a.length) {
                            var g = Pi(a, Cn(Tl));
                            h |= A
                        }
                        return ui(n, h, r, a, g)
                    });

                function Al(r, n, a) {
                    n = a ? t : n;
                    var h = ui(r, U, t, t, t, t, t, n);
                    return h.placeholder = Al.placeholder, h
                }

                function Rl(r, n, a) {
                    n = a ? t : n;
                    var h = ui(r, C, t, t, t, t, t, n);
                    return h.placeholder = Rl.placeholder, h
                }

                function Nl(r, n, a) {
                    var h, g, m, P, N, q, X = 0,
                        Z = !1,
                        ie = !1,
                        he = !0;
                    if (typeof r != "function") throw new Ar(l);
                    n = Lr(n) || 0, wt(a) && (Z = !!a.leading, ie = "maxWait" in a, m = ie ? Ht(Lr(a.maxWait) || 0, n) : m, he = "trailing" in a ? !!a.trailing : he);

                    function ye(Rt) {
                        var Kr = h,
                            pi = g;
                        return h = g = t, X = Rt, P = r.apply(pi, Kr), P
                    }

                    function Ee(Rt) {
                        return X = Rt, N = as(Ve, n), Z ? ye(Rt) : P
                    }

                    function ze(Rt) {
                        var Kr = Rt - q,
                            pi = Rt - X,
                            Xl = n - Kr;
                        return ie ? Jt(Xl, m - pi) : Xl
                    }

                    function De(Rt) {
                        var Kr = Rt - q,
                            pi = Rt - X;
                        return q === t || Kr >= n || Kr < 0 || ie && pi >= m
                    }

                    function Ve() {
                        var Rt = $o();
                        if (De(Rt)) return Xe(Rt);
                        N = as(Ve, ze(Rt))
                    }

                    function Xe(Rt) {
                        return N = t, he && h ? ye(Rt) : (h = g = t, P)
                    }

                    function Sr() {
                        N !== t && Bh(N), X = 0, h = q = g = N = t
                    }

                    function sr() {
                        return N === t ? P : Xe($o())
                    }

                    function Ir() {
                        var Rt = $o(),
                            Kr = De(Rt);
                        if (h = arguments, g = this, q = Rt, Kr) {
                            if (N === t) return Ee(q);
                            if (ie) return Bh(N), N = as(Ve, n), ye(q)
                        }
                        return N === t && (N = as(Ve, n)), P
                    }
                    return Ir.cancel = Sr, Ir.flush = sr, Ir
                }
                var Gv = Be(function(r, n) {
                        return Eh(r, 1, n)
                    }),
                    Wv = Be(function(r, n, a) {
                        return Eh(r, Lr(n) || 0, a)
                    });

                function Yv(r) {
                    return ui(r, G)
                }

                function jo(r, n) {
                    if (typeof r != "function" || n != null && typeof n != "function") throw new Ar(l);
                    var a = function() {
                        var h = arguments,
                            g = n ? n.apply(this, h) : h[0],
                            m = a.cache;
                        if (m.has(g)) return m.get(g);
                        var P = r.apply(this, h);
                        return a.cache = m.set(g, P) || m, P
                    };
                    return a.cache = new(jo.Cache || ai), a
                }
                jo.Cache = ai;

                function Lo(r) {
                    if (typeof r != "function") throw new Ar(l);
                    return function() {
                        var n = arguments;
                        switch (n.length) {
                            case 0:
                                return !r.call(this);
                            case 1:
                                return !r.call(this, n[0]);
                            case 2:
                                return !r.call(this, n[0], n[1]);
                            case 3:
                                return !r.call(this, n[0], n[1], n[2])
                        }
                        return !r.apply(this, n)
                    }
                }

                function Jv(r) {
                    return Cl(2, r)
                }
                var Qv = My(function(r, n) {
                        n = n.length == 1 && Re(n[0]) ? vt(n[0], wr(me())) : vt(Gt(n, 1), wr(me()));
                        var a = n.length;
                        return Be(function(h) {
                            for (var g = -1, m = Jt(h.length, a); ++g < m;) h[g] = n[g].call(this, h[g]);
                            return Bt(r, this, h)
                        })
                    }),
                    Dc = Be(function(r, n) {
                        var a = Pi(n, Cn(Dc));
                        return ui(r, A, t, n, a)
                    }),
                    $l = Be(function(r, n) {
                        var a = Pi(n, Cn($l));
                        return ui(r, E, t, n, a)
                    }),
                    Xv = hi(function(r, n) {
                        return ui(r, b, t, t, t, n)
                    });

                function Zv(r, n) {
                    if (typeof r != "function") throw new Ar(l);
                    return n = n === t ? n : Me(n), Be(r, n)
                }

                function e_(r, n) {
                    if (typeof r != "function") throw new Ar(l);
                    return n = n == null ? 0 : Ht(Me(n), 0), Be(function(a) {
                        var h = a[n],
                            g = Ni(a, 0, n);
                        return h && Oi(g, h), Bt(r, this, g)
                    })
                }

                function t_(r, n, a) {
                    var h = !0,
                        g = !0;
                    if (typeof r != "function") throw new Ar(l);
                    return wt(a) && (h = "leading" in a ? !!a.leading : h, g = "trailing" in a ? !!a.trailing : g), Nl(r, n, {
                        leading: h,
                        maxWait: n,
                        trailing: g
                    })
                }

                function r_(r) {
                    return Pl(r, 1)
                }

                function i_(r, n) {
                    return Dc(ac(n), r)
                }

                function n_() {
                    if (!arguments.length) return [];
                    var r = arguments[0];
                    return Re(r) ? r : [r]
                }

                function s_(r) {
                    return Nr(r, x)
                }

                function o_(r, n) {
                    return n = typeof n == "function" ? n : t, Nr(r, x, n)
                }

                function a_(r) {
                    return Nr(r, D | x)
                }

                function c_(r, n) {
                    return n = typeof n == "function" ? n : t, Nr(r, D | x, n)
                }

                function u_(r, n) {
                    return n == null || wh(r, n, Kt(n))
                }

                function Br(r, n) {
                    return r === n || r !== r && n !== n
                }
                var h_ = Po(Ya),
                    l_ = Po(function(r, n) {
                        return r >= n
                    }),
                    Zi = Oh(function() {
                        return arguments
                    }()) ? Oh : function(r) {
                        return Pt(r) && it.call(r, "callee") && !dh.call(r, "callee")
                    },
                    Re = B.isArray,
                    f_ = rr ? wr(rr) : by;

                function pr(r) {
                    return r != null && Mo(r.length) && !fi(r)
                }

                function At(r) {
                    return Pt(r) && pr(r)
                }

                function d_(r) {
                    return r === !0 || r === !1 || Pt(r) && ir(r) == z
                }
                var $i = Og || $c,
                    p_ = zr ? wr(zr) : wy;

                function g_(r) {
                    return Pt(r) && r.nodeType === 1 && !cs(r)
                }

                function y_(r) {
                    if (r == null) return !0;
                    if (pr(r) && (Re(r) || typeof r == "string" || typeof r.splice == "function" || $i(r) || Tn(r) || Zi(r))) return !r.length;
                    var n = Qt(r);
                    if (n == Ie || n == xe) return !r.size;
                    if (os(r)) return !Xa(r).length;
                    for (var a in r)
                        if (it.call(r, a)) return !1;
                    return !0
                }

                function v_(r, n) {
                    return is(r, n)
                }

                function __(r, n, a) {
                    a = typeof a == "function" ? a : t;
                    var h = a ? a(r, n) : t;
                    return h === t ? is(r, n, t, a) : !!h
                }

                function Sc(r) {
                    if (!Pt(r)) return !1;
                    var n = ir(r);
                    return n == R || n == d || typeof r.message == "string" && typeof r.name == "string" && !cs(r)
                }

                function m_(r) {
                    return typeof r == "number" && gh(r)
                }

                function fi(r) {
                    if (!wt(r)) return !1;
                    var n = ir(r);
                    return n == ae || n == fe || n == H || n == pt
                }

                function jl(r) {
                    return typeof r == "number" && r == Me(r)
                }

                function Mo(r) {
                    return typeof r == "number" && r > -1 && r % 1 == 0 && r <= k
                }

                function wt(r) {
                    var n = typeof r;
                    return r != null && (n == "object" || n == "function")
                }

                function Pt(r) {
                    return r != null && typeof r == "object"
                }
                var Ll = Cr ? wr(Cr) : Dy;

                function b_(r, n) {
                    return r === n || Qa(r, n, pc(n))
                }

                function w_(r, n, a) {
                    return a = typeof a == "function" ? a : t, Qa(r, n, pc(n), a)
                }

                function E_(r) {
                    return Ml(r) && r != +r
                }

                function D_(r) {
                    if (o0(r)) throw new Te(c);
                    return Ph(r)
                }

                function S_(r) {
                    return r === null
                }

                function I_(r) {
                    return r == null
                }

                function Ml(r) {
                    return typeof r == "number" || Pt(r) && ir(r) == Fe
                }

                function cs(r) {
                    if (!Pt(r) || ir(r) != Le) return !1;
                    var n = uo(r);
                    if (n === null) return !0;
                    var a = it.call(n, "constructor") && n.constructor;
                    return typeof a == "function" && a instanceof a && so.call(a) == wg
                }
                var Ic = Jr ? wr(Jr) : Sy;

                function x_(r) {
                    return jl(r) && r >= -k && r <= k
                }
                var Ul = Gn ? wr(Gn) : Iy;

                function Uo(r) {
                    return typeof r == "string" || !Re(r) && Pt(r) && ir(r) == Ne
                }

                function Dr(r) {
                    return typeof r == "symbol" || Pt(r) && ir(r) == $e
                }
                var Tn = ki ? wr(ki) : xy;

                function O_(r) {
                    return r === t
                }

                function P_(r) {
                    return Pt(r) && Qt(r) == Pe
                }

                function C_(r) {
                    return Pt(r) && ir(r) == je
                }
                var T_ = Po(Za),
                    A_ = Po(function(r, n) {
                        return r <= n
                    });

                function ql(r) {
                    if (!r) return [];
                    if (pr(r)) return Uo(r) ? Fr(r) : dr(r);
                    if (Yn && r[Yn]) return ug(r[Yn]());
                    var n = Qt(r),
                        a = n == Ie ? za : n == xe ? ro : An;
                    return a(r)
                }

                function di(r) {
                    if (!r) return r === 0 ? r : 0;
                    if (r = Lr(r), r === Q || r === -Q) {
                        var n = r < 0 ? -1 : 1;
                        return n * V
                    }
                    return r === r ? r : 0
                }

                function Me(r) {
                    var n = di(r),
                        a = n % 1;
                    return n === n ? a ? n - a : n : 0
                }

                function zl(r) {
                    return r ? Yi(Me(r), 0, re) : 0
                }

                function Lr(r) {
                    if (typeof r == "number") return r;
                    if (Dr(r)) return J;
                    if (wt(r)) {
                        var n = typeof r.valueOf == "function" ? r.valueOf() : r;
                        r = wt(n) ? n + "" : n
                    }
                    if (typeof r != "string") return r === 0 ? r : +r;
                    r = sh(r);
                    var a = ga.test(r);
                    return a || va.test(r) ? Ae(r.slice(2), a ? 2 : 8) : pa.test(r) ? J : +r
                }

                function Fl(r) {
                    return Xr(r, gr(r))
                }

                function R_(r) {
                    return r ? Yi(Me(r), -k, k) : r === 0 ? r : 0
                }

                function rt(r) {
                    return r == null ? "" : Er(r)
                }
                var N_ = On(function(r, n) {
                        if (os(n) || pr(n)) {
                            Xr(n, Kt(n), r);
                            return
                        }
                        for (var a in n) it.call(n, a) && es(r, a, n[a])
                    }),
                    Hl = On(function(r, n) {
                        Xr(n, gr(n), r)
                    }),
                    qo = On(function(r, n, a, h) {
                        Xr(n, gr(n), r, h)
                    }),
                    $_ = On(function(r, n, a, h) {
                        Xr(n, Kt(n), r, h)
                    }),
                    j_ = hi(Va);

                function L_(r, n) {
                    var a = xn(r);
                    return n == null ? a : bh(a, n)
                }
                var M_ = Be(function(r, n) {
                        r = ct(r);
                        var a = -1,
                            h = n.length,
                            g = h > 2 ? n[2] : t;
                        for (g && nr(n[0], n[1], g) && (h = 1); ++a < h;)
                            for (var m = n[a], P = gr(m), N = -1, q = P.length; ++N < q;) {
                                var X = P[N],
                                    Z = r[X];
                                (Z === t || Br(Z, Dn[X]) && !it.call(r, X)) && (r[X] = m[X])
                            }
                        return r
                    }),
                    U_ = Be(function(r) {
                        return r.push(t, sl), Bt(Bl, t, r)
                    });

                function q_(r, n) {
                    return th(r, me(n, 3), Qr)
                }

                function z_(r, n) {
                    return th(r, me(n, 3), Wa)
                }

                function F_(r, n) {
                    return r == null ? r : Ga(r, me(n, 3), gr)
                }

                function H_(r, n) {
                    return r == null ? r : Ih(r, me(n, 3), gr)
                }

                function B_(r, n) {
                    return r && Qr(r, me(n, 3))
                }

                function K_(r, n) {
                    return r && Wa(r, me(n, 3))
                }

                function k_(r) {
                    return r == null ? [] : bo(r, Kt(r))
                }

                function V_(r) {
                    return r == null ? [] : bo(r, gr(r))
                }

                function xc(r, n, a) {
                    var h = r == null ? t : Ji(r, n);
                    return h === t ? a : h
                }

                function G_(r, n) {
                    return r != null && cl(r, n, yy)
                }

                function Oc(r, n) {
                    return r != null && cl(r, n, vy)
                }
                var W_ = el(function(r, n, a) {
                        n != null && typeof n.toString != "function" && (n = oo.call(n)), r[n] = a
                    }, Cc(yr)),
                    Y_ = el(function(r, n, a) {
                        n != null && typeof n.toString != "function" && (n = oo.call(n)), it.call(r, n) ? r[n].push(a) : r[n] = [a]
                    }, me),
                    J_ = Be(rs);

                function Kt(r) {
                    return pr(r) ? _h(r) : Xa(r)
                }

                function gr(r) {
                    return pr(r) ? _h(r, !0) : Oy(r)
                }

                function Q_(r, n) {
                    var a = {};
                    return n = me(n, 3), Qr(r, function(h, g, m) {
                        ci(a, n(h, g, m), h)
                    }), a
                }

                function X_(r, n) {
                    var a = {};
                    return n = me(n, 3), Qr(r, function(h, g, m) {
                        ci(a, g, n(h, g, m))
                    }), a
                }
                var Z_ = On(function(r, n, a) {
                        wo(r, n, a)
                    }),
                    Bl = On(function(r, n, a, h) {
                        wo(r, n, a, h)
                    }),
                    em = hi(function(r, n) {
                        var a = {};
                        if (r == null) return a;
                        var h = !1;
                        n = vt(n, function(m) {
                            return m = Ri(m, r), h || (h = m.length > 1), m
                        }), Xr(r, fc(r), a), h && (a = Nr(a, D | S | x, Wy));
                        for (var g = n.length; g--;) nc(a, n[g]);
                        return a
                    });

                function tm(r, n) {
                    return Kl(r, Lo(me(n)))
                }
                var rm = hi(function(r, n) {
                    return r == null ? {} : Cy(r, n)
                });

                function Kl(r, n) {
                    if (r == null) return {};
                    var a = vt(fc(r), function(h) {
                        return [h]
                    });
                    return n = me(n), jh(r, a, function(h, g) {
                        return n(h, g[0])
                    })
                }

                function im(r, n, a) {
                    n = Ri(n, r);
                    var h = -1,
                        g = n.length;
                    for (g || (g = 1, r = t); ++h < g;) {
                        var m = r == null ? t : r[Zr(n[h])];
                        m === t && (h = g, m = a), r = fi(m) ? m.call(r) : m
                    }
                    return r
                }

                function nm(r, n, a) {
                    return r == null ? r : ns(r, n, a)
                }

                function sm(r, n, a, h) {
                    return h = typeof h == "function" ? h : t, r == null ? r : ns(r, n, a, h)
                }
                var kl = il(Kt),
                    Vl = il(gr);

                function om(r, n, a) {
                    var h = Re(r),
                        g = h || $i(r) || Tn(r);
                    if (n = me(n, 4), a == null) {
                        var m = r && r.constructor;
                        g ? a = h ? new m : [] : wt(r) ? a = fi(m) ? xn(uo(r)) : {} : a = {}
                    }
                    return (g ? Tr : Qr)(r, function(P, N, q) {
                        return n(a, P, N, q)
                    }), a
                }

                function am(r, n) {
                    return r == null ? !0 : nc(r, n)
                }

                function cm(r, n, a) {
                    return r == null ? r : zh(r, n, ac(a))
                }

                function um(r, n, a, h) {
                    return h = typeof h == "function" ? h : t, r == null ? r : zh(r, n, ac(a), h)
                }

                function An(r) {
                    return r == null ? [] : qa(r, Kt(r))
                }

                function hm(r) {
                    return r == null ? [] : qa(r, gr(r))
                }

                function lm(r, n, a) {
                    return a === t && (a = n, n = t), a !== t && (a = Lr(a), a = a === a ? a : 0), n !== t && (n = Lr(n), n = n === n ? n : 0), Yi(Lr(r), n, a)
                }

                function fm(r, n, a) {
                    return n = di(n), a === t ? (a = n, n = 0) : a = di(a), r = Lr(r), _y(r, n, a)
                }

                function dm(r, n, a) {
                    if (a && typeof a != "boolean" && nr(r, n, a) && (n = a = t), a === t && (typeof n == "boolean" ? (a = n, n = t) : typeof r == "boolean" && (a = r, r = t)), r === t && n === t ? (r = 0, n = 1) : (r = di(r), n === t ? (n = r, r = 0) : n = di(n)), r > n) {
                        var h = r;
                        r = n, n = h
                    }
                    if (a || r % 1 || n % 1) {
                        var g = yh();
                        return Jt(r + g * (n - r + ot("1e-" + ((g + "").length - 1))), n)
                    }
                    return tc(r, n)
                }
                var pm = Pn(function(r, n, a) {
                    return n = n.toLowerCase(), r + (a ? Gl(n) : n)
                });

                function Gl(r) {
                    return Pc(rt(r).toLowerCase())
                }

                function Wl(r) {
                    return r = rt(r), r && r.replace(ni, ng).replace(Ta, "")
                }

                function gm(r, n, a) {
                    r = rt(r), n = Er(n);
                    var h = r.length;
                    a = a === t ? h : Yi(Me(a), 0, h);
                    var g = a;
                    return a -= n.length, a >= 0 && r.slice(a, g) == n
                }

                function ym(r) {
                    return r = rt(r), r && gt.test(r) ? r.replace(zi, sg) : r
                }

                function vm(r) {
                    return r = rt(r), r && Lt.test(r) ? r.replace(It, "\\$&") : r
                }
                var _m = Pn(function(r, n, a) {
                        return r + (a ? "-" : "") + n.toLowerCase()
                    }),
                    mm = Pn(function(r, n, a) {
                        return r + (a ? " " : "") + n.toLowerCase()
                    }),
                    bm = Qh("toLowerCase");

                function wm(r, n, a) {
                    r = rt(r), n = Me(n);
                    var h = n ? wn(r) : 0;
                    if (!n || h >= n) return r;
                    var g = (n - h) / 2;
                    return Oo(po(g), a) + r + Oo(fo(g), a)
                }

                function Em(r, n, a) {
                    r = rt(r), n = Me(n);
                    var h = n ? wn(r) : 0;
                    return n && h < n ? r + Oo(n - h, a) : r
                }

                function Dm(r, n, a) {
                    r = rt(r), n = Me(n);
                    var h = n ? wn(r) : 0;
                    return n && h < n ? Oo(n - h, a) + r : r
                }

                function Sm(r, n, a) {
                    return a || n == null ? n = 0 : n && (n = +n), Ag(rt(r).replace(xt, ""), n || 0)
                }

                function Im(r, n, a) {
                    return (a ? nr(r, n, a) : n === t) ? n = 1 : n = Me(n), rc(rt(r), n)
                }

                function xm() {
                    var r = arguments,
                        n = rt(r[0]);
                    return r.length < 3 ? n : n.replace(r[1], r[2])
                }
                var Om = Pn(function(r, n, a) {
                    return r + (a ? "_" : "") + n.toLowerCase()
                });

                function Pm(r, n, a) {
                    return a && typeof a != "number" && nr(r, n, a) && (n = a = t), a = a === t ? re : a >>> 0, a ? (r = rt(r), r && (typeof n == "string" || n != null && !Ic(n)) && (n = Er(n), !n && bn(r)) ? Ni(Fr(r), 0, a) : r.split(n, a)) : []
                }
                var Cm = Pn(function(r, n, a) {
                    return r + (a ? " " : "") + Pc(n)
                });

                function Tm(r, n, a) {
                    return r = rt(r), a = a == null ? 0 : Yi(Me(a), 0, r.length), n = Er(n), r.slice(a, a + n.length) == n
                }

                function Am(r, n, a) {
                    var h = _.templateSettings;
                    a && nr(r, n, a) && (n = t), r = rt(r), n = qo({}, n, h, nl);
                    var g = qo({}, n.imports, h.imports, nl),
                        m = Kt(g),
                        P = qa(g, m),
                        N, q, X = 0,
                        Z = n.interpolate || fn,
                        ie = "__p += '",
                        he = Fa((n.escape || fn).source + "|" + Z.source + "|" + (Z === bt ? da : fn).source + "|" + (n.evaluate || fn).source + "|$", "g"),
                        ye = "//# sourceURL=" + (it.call(n, "sourceURL") ? (n.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++Aa + "]") + `
`;
                    r.replace(he, function(De, Ve, Xe, Sr, sr, Ir) {
                        return Xe || (Xe = Sr), ie += r.slice(X, Ir).replace(ma, og), Ve && (N = !0, ie += `' +
__e(` + Ve + `) +
'`), sr && (q = !0, ie += `';
` + sr + `;
__p += '`), Xe && (ie += `' +
((__t = (` + Xe + `)) == null ? '' : __t) +
'`), X = Ir + De.length, De
                    }), ie += `';
`;
                    var Ee = it.call(n, "variable") && n.variable;
                    if (!Ee) ie = `with (obj) {
` + ie + `
}
`;
                    else if (la.test(Ee)) throw new Te(f);
                    ie = (q ? ie.replace(Wr, "") : ie).replace(tr, "$1").replace(ii, "$1;"), ie = "function(" + (Ee || "obj") + `) {
` + (Ee ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (N ? ", __e = _.escape" : "") + (q ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + ie + `return __p
}`;
                    var ze = Jl(function() {
                        return tt(m, ye + "return " + ie).apply(t, P)
                    });
                    if (ze.source = ie, Sc(ze)) throw ze;
                    return ze
                }

                function Rm(r) {
                    return rt(r).toLowerCase()
                }

                function Nm(r) {
                    return rt(r).toUpperCase()
                }

                function $m(r, n, a) {
                    if (r = rt(r), r && (a || n === t)) return sh(r);
                    if (!r || !(n = Er(n))) return r;
                    var h = Fr(r),
                        g = Fr(n),
                        m = oh(h, g),
                        P = ah(h, g) + 1;
                    return Ni(h, m, P).join("")
                }

                function jm(r, n, a) {
                    if (r = rt(r), r && (a || n === t)) return r.slice(0, uh(r) + 1);
                    if (!r || !(n = Er(n))) return r;
                    var h = Fr(r),
                        g = ah(h, Fr(n)) + 1;
                    return Ni(h, 0, g).join("")
                }

                function Lm(r, n, a) {
                    if (r = rt(r), r && (a || n === t)) return r.replace(xt, "");
                    if (!r || !(n = Er(n))) return r;
                    var h = Fr(r),
                        g = oh(h, Fr(n));
                    return Ni(h, g).join("")
                }

                function Mm(r, n) {
                    var a = W,
                        h = se;
                    if (wt(n)) {
                        var g = "separator" in n ? n.separator : g;
                        a = "length" in n ? Me(n.length) : a, h = "omission" in n ? Er(n.omission) : h
                    }
                    r = rt(r);
                    var m = r.length;
                    if (bn(r)) {
                        var P = Fr(r);
                        m = P.length
                    }
                    if (a >= m) return r;
                    var N = a - wn(h);
                    if (N < 1) return h;
                    var q = P ? Ni(P, 0, N).join("") : r.slice(0, N);
                    if (g === t) return q + h;
                    if (P && (N += q.length - N), Ic(g)) {
                        if (r.slice(N).search(g)) {
                            var X, Z = q;
                            for (g.global || (g = Fa(g.source, rt(Pr.exec(g)) + "g")), g.lastIndex = 0; X = g.exec(Z);) var ie = X.index;
                            q = q.slice(0, ie === t ? N : ie)
                        }
                    } else if (r.indexOf(Er(g), N) != N) {
                        var he = q.lastIndexOf(g);
                        he > -1 && (q = q.slice(0, he))
                    }
                    return q + h
                }

                function Um(r) {
                    return r = rt(r), r && Et.test(r) ? r.replace(Si, dg) : r
                }
                var qm = Pn(function(r, n, a) {
                        return r + (a ? " " : "") + n.toUpperCase()
                    }),
                    Pc = Qh("toUpperCase");

                function Yl(r, n, a) {
                    return r = rt(r), n = a ? t : n, n === t ? cg(r) ? yg(r) : Zp(r) : r.match(n) || []
                }
                var Jl = Be(function(r, n) {
                        try {
                            return Bt(r, t, n)
                        } catch (a) {
                            return Sc(a) ? a : new Te(a)
                        }
                    }),
                    zm = hi(function(r, n) {
                        return Tr(n, function(a) {
                            a = Zr(a), ci(r, a, Ec(r[a], r))
                        }), r
                    });

                function Fm(r) {
                    var n = r == null ? 0 : r.length,
                        a = me();
                    return r = n ? vt(r, function(h) {
                        if (typeof h[1] != "function") throw new Ar(l);
                        return [a(h[0]), h[1]]
                    }) : [], Be(function(h) {
                        for (var g = -1; ++g < n;) {
                            var m = r[g];
                            if (Bt(m[0], this, h)) return Bt(m[1], this, h)
                        }
                    })
                }

                function Hm(r) {
                    return dy(Nr(r, D))
                }

                function Cc(r) {
                    return function() {
                        return r
                    }
                }

                function Bm(r, n) {
                    return r == null || r !== r ? n : r
                }
                var Km = Zh(),
                    km = Zh(!0);

                function yr(r) {
                    return r
                }

                function Tc(r) {
                    return Ch(typeof r == "function" ? r : Nr(r, D))
                }

                function Vm(r) {
                    return Ah(Nr(r, D))
                }

                function Gm(r, n) {
                    return Rh(r, Nr(n, D))
                }
                var Wm = Be(function(r, n) {
                        return function(a) {
                            return rs(a, r, n)
                        }
                    }),
                    Ym = Be(function(r, n) {
                        return function(a) {
                            return rs(r, a, n)
                        }
                    });

                function Ac(r, n, a) {
                    var h = Kt(n),
                        g = bo(n, h);
                    a == null && !(wt(n) && (g.length || !h.length)) && (a = n, n = r, r = this, g = bo(n, Kt(n)));
                    var m = !(wt(a) && "chain" in a) || !!a.chain,
                        P = fi(r);
                    return Tr(g, function(N) {
                        var q = n[N];
                        r[N] = q, P && (r.prototype[N] = function() {
                            var X = this.__chain__;
                            if (m || X) {
                                var Z = r(this.__wrapped__),
                                    ie = Z.__actions__ = dr(this.__actions__);
                                return ie.push({
                                    func: q,
                                    args: arguments,
                                    thisArg: r
                                }), Z.__chain__ = X, Z
                            }
                            return q.apply(r, Oi([this.value()], arguments))
                        })
                    }), r
                }

                function Jm() {
                    return Qe._ === this && (Qe._ = Eg), this
                }

                function Rc() {}

                function Qm(r) {
                    return r = Me(r), Be(function(n) {
                        return Nh(n, r)
                    })
                }
                var Xm = uc(vt),
                    Zm = uc(eh),
                    eb = uc($a);

                function Ql(r) {
                    return yc(r) ? ja(Zr(r)) : Ty(r)
                }

                function tb(r) {
                    return function(n) {
                        return r == null ? t : Ji(r, n)
                    }
                }
                var rb = tl(),
                    ib = tl(!0);

                function Nc() {
                    return []
                }

                function $c() {
                    return !1
                }

                function nb() {
                    return {}
                }

                function sb() {
                    return ""
                }

                function ob() {
                    return !0
                }

                function ab(r, n) {
                    if (r = Me(r), r < 1 || r > k) return [];
                    var a = re,
                        h = Jt(r, re);
                    n = me(n), r -= re;
                    for (var g = Ua(h, n); ++a < r;) n(a);
                    return g
                }

                function cb(r) {
                    return Re(r) ? vt(r, Zr) : Dr(r) ? [r] : dr(vl(rt(r)))
                }

                function ub(r) {
                    var n = ++bg;
                    return rt(r) + n
                }
                var hb = xo(function(r, n) {
                        return r + n
                    }, 0),
                    lb = hc("ceil"),
                    fb = xo(function(r, n) {
                        return r / n
                    }, 1),
                    db = hc("floor");

                function pb(r) {
                    return r && r.length ? mo(r, yr, Ya) : t
                }

                function gb(r, n) {
                    return r && r.length ? mo(r, me(n, 2), Ya) : t
                }

                function yb(r) {
                    return ih(r, yr)
                }

                function vb(r, n) {
                    return ih(r, me(n, 2))
                }

                function _b(r) {
                    return r && r.length ? mo(r, yr, Za) : t
                }

                function mb(r, n) {
                    return r && r.length ? mo(r, me(n, 2), Za) : t
                }
                var bb = xo(function(r, n) {
                        return r * n
                    }, 1),
                    wb = hc("round"),
                    Eb = xo(function(r, n) {
                        return r - n
                    }, 0);

                function Db(r) {
                    return r && r.length ? Ma(r, yr) : 0
                }

                function Sb(r, n) {
                    return r && r.length ? Ma(r, me(n, 2)) : 0
                }
                return _.after = Vv, _.ary = Pl, _.assign = N_, _.assignIn = Hl, _.assignInWith = qo, _.assignWith = $_, _.at = j_, _.before = Cl, _.bind = Ec, _.bindAll = zm, _.bindKey = Tl, _.castArray = n_, _.chain = Il, _.chunk = d0, _.compact = p0, _.concat = g0, _.cond = Fm, _.conforms = Hm, _.constant = Cc, _.countBy = Dv, _.create = L_, _.curry = Al, _.curryRight = Rl, _.debounce = Nl, _.defaults = M_, _.defaultsDeep = U_, _.defer = Gv, _.delay = Wv, _.difference = y0, _.differenceBy = v0, _.differenceWith = _0, _.drop = m0, _.dropRight = b0, _.dropRightWhile = w0, _.dropWhile = E0, _.fill = D0, _.filter = Iv, _.flatMap = Pv, _.flatMapDeep = Cv, _.flatMapDepth = Tv, _.flatten = wl, _.flattenDeep = S0, _.flattenDepth = I0, _.flip = Yv, _.flow = Km, _.flowRight = km, _.fromPairs = x0, _.functions = k_, _.functionsIn = V_, _.groupBy = Av, _.initial = P0, _.intersection = C0, _.intersectionBy = T0, _.intersectionWith = A0, _.invert = W_, _.invertBy = Y_, _.invokeMap = Nv, _.iteratee = Tc, _.keyBy = $v, _.keys = Kt, _.keysIn = gr, _.map = No, _.mapKeys = Q_, _.mapValues = X_, _.matches = Vm, _.matchesProperty = Gm, _.memoize = jo, _.merge = Z_, _.mergeWith = Bl, _.method = Wm, _.methodOf = Ym, _.mixin = Ac, _.negate = Lo, _.nthArg = Qm, _.omit = em, _.omitBy = tm, _.once = Jv, _.orderBy = jv, _.over = Xm, _.overArgs = Qv, _.overEvery = Zm, _.overSome = eb, _.partial = Dc, _.partialRight = $l, _.partition = Lv, _.pick = rm, _.pickBy = Kl, _.property = Ql, _.propertyOf = tb, _.pull = j0, _.pullAll = Dl, _.pullAllBy = L0, _.pullAllWith = M0, _.pullAt = U0, _.range = rb, _.rangeRight = ib, _.rearg = Xv, _.reject = qv, _.remove = q0, _.rest = Zv, _.reverse = bc, _.sampleSize = Fv, _.set = nm, _.setWith = sm, _.shuffle = Hv, _.slice = z0, _.sortBy = kv, _.sortedUniq = G0, _.sortedUniqBy = W0, _.split = Pm, _.spread = e_, _.tail = Y0, _.take = J0, _.takeRight = Q0, _.takeRightWhile = X0, _.takeWhile = Z0, _.tap = pv, _.throttle = t_, _.thru = Ro, _.toArray = ql, _.toPairs = kl, _.toPairsIn = Vl, _.toPath = cb, _.toPlainObject = Fl, _.transform = om, _.unary = r_, _.union = ev, _.unionBy = tv, _.unionWith = rv, _.uniq = iv, _.uniqBy = nv, _.uniqWith = sv, _.unset = am, _.unzip = wc, _.unzipWith = Sl, _.update = cm, _.updateWith = um, _.values = An, _.valuesIn = hm, _.without = ov, _.words = Yl, _.wrap = i_, _.xor = av, _.xorBy = cv, _.xorWith = uv, _.zip = hv, _.zipObject = lv, _.zipObjectDeep = fv, _.zipWith = dv, _.entries = kl, _.entriesIn = Vl, _.extend = Hl, _.extendWith = qo, Ac(_, _), _.add = hb, _.attempt = Jl, _.camelCase = pm, _.capitalize = Gl, _.ceil = lb, _.clamp = lm, _.clone = s_, _.cloneDeep = a_, _.cloneDeepWith = c_, _.cloneWith = o_, _.conformsTo = u_, _.deburr = Wl, _.defaultTo = Bm, _.divide = fb, _.endsWith = gm, _.eq = Br, _.escape = ym, _.escapeRegExp = vm, _.every = Sv, _.find = xv, _.findIndex = ml, _.findKey = q_, _.findLast = Ov, _.findLastIndex = bl, _.findLastKey = z_, _.floor = db, _.forEach = xl, _.forEachRight = Ol, _.forIn = F_, _.forInRight = H_, _.forOwn = B_, _.forOwnRight = K_, _.get = xc, _.gt = h_, _.gte = l_, _.has = G_, _.hasIn = Oc, _.head = El, _.identity = yr, _.includes = Rv, _.indexOf = O0, _.inRange = fm, _.invoke = J_, _.isArguments = Zi, _.isArray = Re, _.isArrayBuffer = f_, _.isArrayLike = pr, _.isArrayLikeObject = At, _.isBoolean = d_, _.isBuffer = $i, _.isDate = p_, _.isElement = g_, _.isEmpty = y_, _.isEqual = v_, _.isEqualWith = __, _.isError = Sc, _.isFinite = m_, _.isFunction = fi, _.isInteger = jl, _.isLength = Mo, _.isMap = Ll, _.isMatch = b_, _.isMatchWith = w_, _.isNaN = E_, _.isNative = D_, _.isNil = I_, _.isNull = S_, _.isNumber = Ml, _.isObject = wt, _.isObjectLike = Pt, _.isPlainObject = cs, _.isRegExp = Ic, _.isSafeInteger = x_, _.isSet = Ul, _.isString = Uo, _.isSymbol = Dr, _.isTypedArray = Tn, _.isUndefined = O_, _.isWeakMap = P_, _.isWeakSet = C_, _.join = R0, _.kebabCase = _m, _.last = jr, _.lastIndexOf = N0, _.lowerCase = mm, _.lowerFirst = bm, _.lt = T_, _.lte = A_, _.max = pb, _.maxBy = gb, _.mean = yb, _.meanBy = vb, _.min = _b, _.minBy = mb, _.stubArray = Nc, _.stubFalse = $c, _.stubObject = nb, _.stubString = sb, _.stubTrue = ob, _.multiply = bb, _.nth = $0, _.noConflict = Jm, _.noop = Rc, _.now = $o, _.pad = wm, _.padEnd = Em, _.padStart = Dm, _.parseInt = Sm, _.random = dm, _.reduce = Mv, _.reduceRight = Uv, _.repeat = Im, _.replace = xm, _.result = im, _.round = wb, _.runInContext = M, _.sample = zv, _.size = Bv, _.snakeCase = Om, _.some = Kv, _.sortedIndex = F0, _.sortedIndexBy = H0, _.sortedIndexOf = B0, _.sortedLastIndex = K0, _.sortedLastIndexBy = k0, _.sortedLastIndexOf = V0, _.startCase = Cm, _.startsWith = Tm, _.subtract = Eb, _.sum = Db, _.sumBy = Sb, _.template = Am, _.times = ab, _.toFinite = di, _.toInteger = Me, _.toLength = zl, _.toLower = Rm, _.toNumber = Lr, _.toSafeInteger = R_, _.toString = rt, _.toUpper = Nm, _.trim = $m, _.trimEnd = jm, _.trimStart = Lm, _.truncate = Mm, _.unescape = Um, _.uniqueId = ub, _.upperCase = qm, _.upperFirst = Pc, _.each = xl, _.eachRight = Ol, _.first = El, Ac(_, function() {
                    var r = {};
                    return Qr(_, function(n, a) {
                        it.call(_.prototype, a) || (r[a] = n)
                    }), r
                }(), {
                    chain: !1
                }), _.VERSION = s, Tr(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(r) {
                    _[r].placeholder = _
                }), Tr(["drop", "take"], function(r, n) {
                    We.prototype[r] = function(a) {
                        a = a === t ? 1 : Ht(Me(a), 0);
                        var h = this.__filtered__ && !n ? new We(this) : this.clone();
                        return h.__filtered__ ? h.__takeCount__ = Jt(a, h.__takeCount__) : h.__views__.push({
                            size: Jt(a, re),
                            type: r + (h.__dir__ < 0 ? "Right" : "")
                        }), h
                    }, We.prototype[r + "Right"] = function(a) {
                        return this.reverse()[r](a).reverse()
                    }
                }), Tr(["filter", "map", "takeWhile"], function(r, n) {
                    var a = n + 1,
                        h = a == w || a == ee;
                    We.prototype[r] = function(g) {
                        var m = this.clone();
                        return m.__iteratees__.push({
                            iteratee: me(g, 3),
                            type: a
                        }), m.__filtered__ = m.__filtered__ || h, m
                    }
                }), Tr(["head", "last"], function(r, n) {
                    var a = "take" + (n ? "Right" : "");
                    We.prototype[r] = function() {
                        return this[a](1).value()[0]
                    }
                }), Tr(["initial", "tail"], function(r, n) {
                    var a = "drop" + (n ? "" : "Right");
                    We.prototype[r] = function() {
                        return this.__filtered__ ? new We(this) : this[a](1)
                    }
                }), We.prototype.compact = function() {
                    return this.filter(yr)
                }, We.prototype.find = function(r) {
                    return this.filter(r).head()
                }, We.prototype.findLast = function(r) {
                    return this.reverse().find(r)
                }, We.prototype.invokeMap = Be(function(r, n) {
                    return typeof r == "function" ? new We(this) : this.map(function(a) {
                        return rs(a, r, n)
                    })
                }), We.prototype.reject = function(r) {
                    return this.filter(Lo(me(r)))
                }, We.prototype.slice = function(r, n) {
                    r = Me(r);
                    var a = this;
                    return a.__filtered__ && (r > 0 || n < 0) ? new We(a) : (r < 0 ? a = a.takeRight(-r) : r && (a = a.drop(r)), n !== t && (n = Me(n), a = n < 0 ? a.dropRight(-n) : a.take(n - r)), a)
                }, We.prototype.takeRightWhile = function(r) {
                    return this.reverse().takeWhile(r).reverse()
                }, We.prototype.toArray = function() {
                    return this.take(re)
                }, Qr(We.prototype, function(r, n) {
                    var a = /^(?:filter|find|map|reject)|While$/.test(n),
                        h = /^(?:head|last)$/.test(n),
                        g = _[h ? "take" + (n == "last" ? "Right" : "") : n],
                        m = h || /^find/.test(n);
                    g && (_.prototype[n] = function() {
                        var P = this.__wrapped__,
                            N = h ? [1] : arguments,
                            q = P instanceof We,
                            X = N[0],
                            Z = q || Re(P),
                            ie = function(Ve) {
                                var Xe = g.apply(_, Oi([Ve], N));
                                return h && he ? Xe[0] : Xe
                            };
                        Z && a && typeof X == "function" && X.length != 1 && (q = Z = !1);
                        var he = this.__chain__,
                            ye = !!this.__actions__.length,
                            Ee = m && !he,
                            ze = q && !ye;
                        if (!m && Z) {
                            P = ze ? P : new We(this);
                            var De = r.apply(P, N);
                            return De.__actions__.push({
                                func: Ro,
                                args: [ie],
                                thisArg: t
                            }), new Rr(De, he)
                        }
                        return Ee && ze ? r.apply(this, N) : (De = this.thru(ie), Ee ? h ? De.value()[0] : De.value() : De)
                    })
                }), Tr(["pop", "push", "shift", "sort", "splice", "unshift"], function(r) {
                    var n = io[r],
                        a = /^(?:push|sort|unshift)$/.test(r) ? "tap" : "thru",
                        h = /^(?:pop|shift)$/.test(r);
                    _.prototype[r] = function() {
                        var g = arguments;
                        if (h && !this.__chain__) {
                            var m = this.value();
                            return n.apply(Re(m) ? m : [], g)
                        }
                        return this[a](function(P) {
                            return n.apply(Re(P) ? P : [], g)
                        })
                    }
                }), Qr(We.prototype, function(r, n) {
                    var a = _[n];
                    if (a) {
                        var h = a.name + "";
                        it.call(In, h) || (In[h] = []), In[h].push({
                            name: n,
                            func: a
                        })
                    }
                }), In[Io(t, ne).name] = [{
                    name: "wrapper",
                    func: t
                }], We.prototype.clone = Ug, We.prototype.reverse = qg, We.prototype.value = zg, _.prototype.at = gv, _.prototype.chain = yv, _.prototype.commit = vv, _.prototype.next = _v, _.prototype.plant = bv, _.prototype.reverse = wv, _.prototype.toJSON = _.prototype.valueOf = _.prototype.value = Ev, _.prototype.first = _.prototype.head, Yn && (_.prototype[Yn] = mv), _
            },
            En = vg();
        Tt ? ((Tt.exports = En)._ = En, at._ = En) : Qe._ = En
    }).call(gs)
})(Pu, Pu.exports);
var V6 = Object.defineProperty,
    G6 = Object.defineProperties,
    W6 = Object.getOwnPropertyDescriptors,
    Pd = Object.getOwnPropertySymbols,
    Y6 = Object.prototype.hasOwnProperty,
    J6 = Object.prototype.propertyIsEnumerable,
    Cd = (i, e, t) => e in i ? V6(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t,
    Ko = (i, e) => {
        for (var t in e || (e = {})) Y6.call(e, t) && Cd(i, t, e[t]);
        if (Pd)
            for (var t of Pd(e)) J6.call(e, t) && Cd(i, t, e[t]);
        return i
    },
    Q6 = (i, e) => G6(i, W6(e));

function Mi(i, e, t) {
    var s;
    const o = F1(i);
    return ((s = e.rpcMap) == null ? void 0 : s[o.reference]) || `${k6}?chainId=${o.namespace}:${o.reference}&projectId=${t}`
}

function ln(i) {
    return i.includes(":") ? i.split(":")[1] : i
}

function Vp(i) {
    return i.map(e => `${e.split(":")[0]}:${e.split(":")[1]}`)
}

function X6(i, e) {
    const t = Object.keys(e.namespaces).filter(o => o.includes(i));
    if (!t.length) return [];
    const s = [];
    return t.forEach(o => {
        const c = e.namespaces[o].accounts;
        s.push(...c)
    }), s
}

function Td(i = {}, e = {}) {
    const t = Ad(i),
        s = Ad(e);
    return Pu.exports.merge(t, s)
}

function Ad(i) {
    var e, t, s, o;
    const c = {};
    if (!Ds(i)) return c;
    for (const [l, f] of Object.entries(i)) {
        const y = Bu(l) ? [l] : f.chains,
            p = f.methods || [],
            v = f.events || [],
            D = f.rpcMap || {},
            S = ys(l);
        c[S] = Q6(Ko(Ko({}, c[S]), f), {
            chains: zc(y, (e = c[S]) == null ? void 0 : e.chains),
            methods: zc(p, (t = c[S]) == null ? void 0 : t.methods),
            events: zc(v, (s = c[S]) == null ? void 0 : s.events),
            rpcMap: Ko(Ko({}, D), (o = c[S]) == null ? void 0 : o.rpcMap)
        })
    }
    return c
}

function Z6(i) {
    return i.includes(":") ? i.split(":")[2] : i
}

function ex(i) {
    const e = {};
    for (const [t, s] of Object.entries(i)) {
        const o = s.methods || [],
            c = s.events || [],
            l = s.accounts || [],
            f = Bu(t) ? [t] : s.chains ? s.chains : Vp(s.accounts);
        e[t] = {
            chains: f,
            methods: o,
            events: c,
            accounts: l
        }
    }
    return e
}

function eu(i) {
    return typeof i == "number" ? i : i.includes("0x") ? parseInt(i, 16) : (i = i.includes(":") ? i.split(":")[1] : i, isNaN(Number(i)) ? i : Number(i))
}
const Gp = {},
    mt = i => Gp[i],
    tu = (i, e) => {
        Gp[i] = e
    };
class tx {
    constructor(e) {
        this.name = "polkadot", this.namespace = e.namespace, this.events = mt("events"), this.client = mt("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders()
    }
    updateNamespace(e) {
        this.namespace = Object.assign(this.namespace, e)
    }
    requestAccounts() {
        return this.getAccounts()
    }
    getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e) throw new Error("ChainId not found");
        return e.split(":")[1]
    }
    request(e) {
        return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request)
    }
    setDefaultChain(e, t) {
        this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(Di.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`)
    }
    getAccounts() {
        const e = this.namespace.accounts;
        return e ? e.filter(t => t.split(":")[1] === this.chainId.toString()).map(t => t.split(":")[2]) || [] : []
    }
    createHttpProviders() {
        const e = {};
        return this.namespace.chains.forEach(t => {
            var s;
            const o = ln(t);
            e[o] = this.createHttpProvider(o, (s = this.namespace.rpcMap) == null ? void 0 : s[t])
        }), e
    }
    getHttpProvider() {
        const e = `${this.name}:${this.chainId}`,
            t = this.httpProviders[e];
        if (typeof t > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
        return t
    }
    setHttpProvider(e, t) {
        const s = this.createHttpProvider(e, t);
        s && (this.httpProviders[e] = s)
    }
    createHttpProvider(e, t) {
        const s = t || Mi(e, this.namespace, this.client.core.projectId);
        if (!s) throw new Error(`No RPC url provided for chainId: ${e}`);
        return new Ei(new qi(s, mt("disableProviderPing")))
    }
}
class rx {
    constructor(e) {
        this.name = "eip155", this.namespace = e.namespace, this.events = mt("events"), this.client = mt("client"), this.httpProviders = this.createHttpProviders(), this.chainId = parseInt(this.getDefaultChain())
    }
    async request(e) {
        switch (e.request.method) {
            case "eth_requestAccounts":
                return this.getAccounts();
            case "eth_accounts":
                return this.getAccounts();
            case "wallet_switchEthereumChain":
                return await this.handleSwitchChain(e);
            case "eth_chainId":
                return parseInt(this.getDefaultChain())
        }
        return this.namespace.methods.includes(e.request.method) ? await this.client.request(e) : this.getHttpProvider().request(e.request)
    }
    updateNamespace(e) {
        this.namespace = Object.assign(this.namespace, e)
    }
    setDefaultChain(e, t) {
        this.httpProviders[e] || this.setHttpProvider(parseInt(e), t), this.chainId = parseInt(e), this.events.emit(Di.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`)
    }
    requestAccounts() {
        return this.getAccounts()
    }
    getDefaultChain() {
        if (this.chainId) return this.chainId.toString();
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e) throw new Error("ChainId not found");
        return e.split(":")[1]
    }
    createHttpProvider(e, t) {
        const s = t || Mi(`${this.name}:${e}`, this.namespace, this.client.core.projectId);
        if (!s) throw new Error(`No RPC url provided for chainId: ${e}`);
        return new Ei(new qi(s, mt("disableProviderPing")))
    }
    setHttpProvider(e, t) {
        const s = this.createHttpProvider(e, t);
        s && (this.httpProviders[e] = s)
    }
    createHttpProviders() {
        const e = {};
        return this.namespace.chains.forEach(t => {
            var s;
            const o = parseInt(ln(t));
            e[o] = this.createHttpProvider(o, (s = this.namespace.rpcMap) == null ? void 0 : s[t])
        }), e
    }
    getAccounts() {
        const e = this.namespace.accounts;
        return e ? [...new Set(e.filter(t => t.split(":")[1] === this.chainId.toString()).map(t => t.split(":")[2]))] : []
    }
    getHttpProvider() {
        const e = this.chainId,
            t = this.httpProviders[e];
        if (typeof t > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
        return t
    }
    async handleSwitchChain(e) {
        var t, s;
        let o = e.request.params ? (t = e.request.params[0]) == null ? void 0 : t.chainId : "0x0";
        o = o.startsWith("0x") ? o : `0x${o}`;
        const c = parseInt(o, 16);
        if (this.isChainApproved(c)) this.setDefaultChain(`${c}`);
        else if (this.namespace.methods.includes("wallet_switchEthereumChain")) await this.client.request({
            topic: e.topic,
            request: {
                method: e.request.method,
                params: [{
                    chainId: o
                }]
            },
            chainId: (s = this.namespace.chains) == null ? void 0 : s[0]
        }), this.setDefaultChain(`${c}`);
        else throw new Error(`Failed to switch to chain 'eip155:${c}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`);
        return null
    }
    isChainApproved(e) {
        return this.namespace.chains.includes(`${this.name}:${e}`)
    }
}
class ix {
    constructor(e) {
        this.name = "solana", this.namespace = e.namespace, this.events = mt("events"), this.client = mt("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders()
    }
    updateNamespace(e) {
        this.namespace = Object.assign(this.namespace, e)
    }
    requestAccounts() {
        return this.getAccounts()
    }
    request(e) {
        return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request)
    }
    setDefaultChain(e, t) {
        this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(Di.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`)
    }
    getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e) throw new Error("ChainId not found");
        return e.split(":")[1]
    }
    getAccounts() {
        const e = this.namespace.accounts;
        return e ? [...new Set(e.filter(t => t.split(":")[1] === this.chainId.toString()).map(t => t.split(":")[2]))] : []
    }
    createHttpProviders() {
        const e = {};
        return this.namespace.chains.forEach(t => {
            var s;
            const o = ln(t);
            e[o] = this.createHttpProvider(o, (s = this.namespace.rpcMap) == null ? void 0 : s[t])
        }), e
    }
    getHttpProvider() {
        const e = `${this.name}:${this.chainId}`,
            t = this.httpProviders[e];
        if (typeof t > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
        return t
    }
    setHttpProvider(e, t) {
        const s = this.createHttpProvider(e, t);
        s && (this.httpProviders[e] = s)
    }
    createHttpProvider(e, t) {
        const s = t || Mi(e, this.namespace, this.client.core.projectId);
        if (!s) throw new Error(`No RPC url provided for chainId: ${e}`);
        return new Ei(new qi(s, mt("disableProviderPing")))
    }
}
class nx {
    constructor(e) {
        this.name = "cosmos", this.namespace = e.namespace, this.events = mt("events"), this.client = mt("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders()
    }
    updateNamespace(e) {
        this.namespace = Object.assign(this.namespace, e)
    }
    requestAccounts() {
        return this.getAccounts()
    }
    getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e) throw new Error("ChainId not found");
        return e.split(":")[1]
    }
    request(e) {
        return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request)
    }
    setDefaultChain(e, t) {
        this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(Di.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`)
    }
    getAccounts() {
        const e = this.namespace.accounts;
        return e ? [...new Set(e.filter(t => t.split(":")[1] === this.chainId.toString()).map(t => t.split(":")[2]))] : []
    }
    createHttpProviders() {
        const e = {};
        return this.namespace.chains.forEach(t => {
            var s;
            const o = ln(t);
            e[o] = this.createHttpProvider(o, (s = this.namespace.rpcMap) == null ? void 0 : s[t])
        }), e
    }
    getHttpProvider() {
        const e = `${this.name}:${this.chainId}`,
            t = this.httpProviders[e];
        if (typeof t > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
        return t
    }
    setHttpProvider(e, t) {
        const s = this.createHttpProvider(e, t);
        s && (this.httpProviders[e] = s)
    }
    createHttpProvider(e, t) {
        const s = t || Mi(e, this.namespace, this.client.core.projectId);
        if (!s) throw new Error(`No RPC url provided for chainId: ${e}`);
        return new Ei(new qi(s, mt("disableProviderPing")))
    }
}
class sx {
    constructor(e) {
        this.name = "cip34", this.namespace = e.namespace, this.events = mt("events"), this.client = mt("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders()
    }
    updateNamespace(e) {
        this.namespace = Object.assign(this.namespace, e)
    }
    requestAccounts() {
        return this.getAccounts()
    }
    getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e) throw new Error("ChainId not found");
        return e.split(":")[1]
    }
    request(e) {
        return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request)
    }
    setDefaultChain(e, t) {
        this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(Di.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`)
    }
    getAccounts() {
        const e = this.namespace.accounts;
        return e ? [...new Set(e.filter(t => t.split(":")[1] === this.chainId.toString()).map(t => t.split(":")[2]))] : []
    }
    createHttpProviders() {
        const e = {};
        return this.namespace.chains.forEach(t => {
            const s = this.getCardanoRPCUrl(t),
                o = ln(t);
            e[o] = this.createHttpProvider(o, s)
        }), e
    }
    getHttpProvider() {
        const e = `${this.name}:${this.chainId}`,
            t = this.httpProviders[e];
        if (typeof t > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
        return t
    }
    getCardanoRPCUrl(e) {
        const t = this.namespace.rpcMap;
        if (t) return t[e]
    }
    setHttpProvider(e, t) {
        const s = this.createHttpProvider(e, t);
        s && (this.httpProviders[e] = s)
    }
    createHttpProvider(e, t) {
        const s = t || this.getCardanoRPCUrl(e);
        if (!s) throw new Error(`No RPC url provided for chainId: ${e}`);
        return new Ei(new qi(s, mt("disableProviderPing")))
    }
}
class ox {
    constructor(e) {
        this.name = "elrond", this.namespace = e.namespace, this.events = mt("events"), this.client = mt("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders()
    }
    updateNamespace(e) {
        this.namespace = Object.assign(this.namespace, e)
    }
    requestAccounts() {
        return this.getAccounts()
    }
    request(e) {
        return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request)
    }
    setDefaultChain(e, t) {
        this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(Di.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`)
    }
    getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e) throw new Error("ChainId not found");
        return e.split(":")[1]
    }
    getAccounts() {
        const e = this.namespace.accounts;
        return e ? [...new Set(e.filter(t => t.split(":")[1] === this.chainId.toString()).map(t => t.split(":")[2]))] : []
    }
    createHttpProviders() {
        const e = {};
        return this.namespace.chains.forEach(t => {
            var s;
            const o = ln(t);
            e[o] = this.createHttpProvider(o, (s = this.namespace.rpcMap) == null ? void 0 : s[t])
        }), e
    }
    getHttpProvider() {
        const e = `${this.name}:${this.chainId}`,
            t = this.httpProviders[e];
        if (typeof t > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
        return t
    }
    setHttpProvider(e, t) {
        const s = this.createHttpProvider(e, t);
        s && (this.httpProviders[e] = s)
    }
    createHttpProvider(e, t) {
        const s = t || Mi(e, this.namespace, this.client.core.projectId);
        if (!s) throw new Error(`No RPC url provided for chainId: ${e}`);
        return new Ei(new qi(s, mt("disableProviderPing")))
    }
}
class ax {
    constructor(e) {
        this.name = "multiversx", this.namespace = e.namespace, this.events = mt("events"), this.client = mt("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders()
    }
    updateNamespace(e) {
        this.namespace = Object.assign(this.namespace, e)
    }
    requestAccounts() {
        return this.getAccounts()
    }
    request(e) {
        return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request)
    }
    setDefaultChain(e, t) {
        this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(Di.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`)
    }
    getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e) throw new Error("ChainId not found");
        return e.split(":")[1]
    }
    getAccounts() {
        const e = this.namespace.accounts;
        return e ? [...new Set(e.filter(t => t.split(":")[1] === this.chainId.toString()).map(t => t.split(":")[2]))] : []
    }
    createHttpProviders() {
        const e = {};
        return this.namespace.chains.forEach(t => {
            var s;
            const o = ln(t);
            e[o] = this.createHttpProvider(o, (s = this.namespace.rpcMap) == null ? void 0 : s[t])
        }), e
    }
    getHttpProvider() {
        const e = `${this.name}:${this.chainId}`,
            t = this.httpProviders[e];
        if (typeof t > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
        return t
    }
    setHttpProvider(e, t) {
        const s = this.createHttpProvider(e, t);
        s && (this.httpProviders[e] = s)
    }
    createHttpProvider(e, t) {
        const s = t || Mi(e, this.namespace, this.client.core.projectId);
        if (!s) throw new Error(`No RPC url provided for chainId: ${e}`);
        return new Ei(new qi(s, mt("disableProviderPing")))
    }
}
class cx {
    constructor(e) {
        this.name = "near", this.namespace = e.namespace, this.events = mt("events"), this.client = mt("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders()
    }
    updateNamespace(e) {
        this.namespace = Object.assign(this.namespace, e)
    }
    requestAccounts() {
        return this.getAccounts()
    }
    getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e) throw new Error("ChainId not found");
        return e.split(":")[1]
    }
    request(e) {
        return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request)
    }
    setDefaultChain(e, t) {
        if (this.chainId = e, !this.httpProviders[e]) {
            const s = t || Mi(`${this.name}:${e}`, this.namespace);
            if (!s) throw new Error(`No RPC url provided for chainId: ${e}`);
            this.setHttpProvider(e, s)
        }
        this.events.emit(Di.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`)
    }
    getAccounts() {
        const e = this.namespace.accounts;
        return e ? e.filter(t => t.split(":")[1] === this.chainId.toString()).map(t => t.split(":")[2]) || [] : []
    }
    createHttpProviders() {
        const e = {};
        return this.namespace.chains.forEach(t => {
            var s;
            e[t] = this.createHttpProvider(t, (s = this.namespace.rpcMap) == null ? void 0 : s[t])
        }), e
    }
    getHttpProvider() {
        const e = `${this.name}:${this.chainId}`,
            t = this.httpProviders[e];
        if (typeof t > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
        return t
    }
    setHttpProvider(e, t) {
        const s = this.createHttpProvider(e, t);
        s && (this.httpProviders[e] = s)
    }
    createHttpProvider(e, t) {
        const s = t || Mi(e, this.namespace);
        return typeof s > "u" ? void 0 : new Ei(new qi(s, mt("disableProviderPing")))
    }
}
var ux = Object.defineProperty,
    hx = Object.defineProperties,
    lx = Object.getOwnPropertyDescriptors,
    Rd = Object.getOwnPropertySymbols,
    fx = Object.prototype.hasOwnProperty,
    dx = Object.prototype.propertyIsEnumerable,
    Nd = (i, e, t) => e in i ? ux(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t,
    ko = (i, e) => {
        for (var t in e || (e = {})) fx.call(e, t) && Nd(i, t, e[t]);
        if (Rd)
            for (var t of Rd(e)) dx.call(e, t) && Nd(i, t, e[t]);
        return i
    },
    ru = (i, e) => hx(i, lx(e));
class Xu {
    constructor(e) {
        this.events = new Ru, this.rpcProviders = {}, this.shouldAbortPairingAttempt = !1, this.maxPairingAttempts = 10, this.disableProviderPing = !1, this.providerOpts = e, this.logger = typeof(e == null ? void 0 : e.logger) < "u" && typeof(e == null ? void 0 : e.logger) != "string" ? e.logger : Ye.pino(Ye.getDefaultLoggerOptions({
            level: (e == null ? void 0 : e.logger) || xd
        })), this.disableProviderPing = (e == null ? void 0 : e.disableProviderPing) || !1
    }
    static async init(e) {
        const t = new Xu(e);
        return await t.initialize(), t
    }
    async request(e, t, s) {
        const [o, c] = this.validateChain(t);
        if (!this.session) throw new Error("Please call connect() before request()");
        return await this.getProvider(o).request({
            request: ko({}, e),
            chainId: `${o}:${c}`,
            topic: this.session.topic,
            expiry: s
        })
    }
    sendAsync(e, t, s, o) {
        const c = new Date().getTime();
        this.request(e, s, o).then(l => t(null, oa(c, l))).catch(l => t(l, void 0))
    }
    async enable() {
        if (!this.client) throw new Error("Sign Client not initialized");
        return this.session || await this.connect({
            namespaces: this.namespaces,
            optionalNamespaces: this.optionalNamespaces,
            sessionProperties: this.sessionProperties
        }), await this.requestAccounts()
    }
    async disconnect() {
        var e;
        if (!this.session) throw new Error("Please call connect() before enable()");
        await this.client.disconnect({
            topic: (e = this.session) == null ? void 0 : e.topic,
            reason: _t("USER_DISCONNECTED")
        }), await this.cleanup()
    }
    async connect(e) {
        if (!this.client) throw new Error("Sign Client not initialized");
        if (this.setNamespaces(e), await this.cleanupPendingPairings(), !e.skipPairing) return await this.pair(e.pairingTopic)
    }
    on(e, t) {
        this.events.on(e, t)
    }
    once(e, t) {
        this.events.once(e, t)
    }
    removeListener(e, t) {
        this.events.removeListener(e, t)
    }
    off(e, t) {
        this.events.off(e, t)
    }
    get isWalletConnect() {
        return !0
    }
    async pair(e) {
        this.shouldAbortPairingAttempt = !1;
        let t = 0;
        do {
            if (this.shouldAbortPairingAttempt) throw new Error("Pairing aborted");
            if (t >= this.maxPairingAttempts) throw new Error("Max auto pairing attempts reached");
            const {
                uri: s,
                approval: o
            } = await this.client.connect({
                pairingTopic: e,
                requiredNamespaces: this.namespaces,
                optionalNamespaces: this.optionalNamespaces,
                sessionProperties: this.sessionProperties
            });
            s && (this.uri = s, this.events.emit("display_uri", s)), await o().then(c => {
                this.session = c;
                const l = ex(c.namespaces);
                this.namespaces = Td(this.namespaces, l), this.persist("namespaces", this.namespaces)
            }).catch(c => {
                if (c.message !== Kp) throw c;
                t++
            })
        } while (!this.session);
        return this.onConnect(), this.session
    }
    setDefaultChain(e, t) {
        try {
            if (!this.session) return;
            const [s, o] = this.validateChain(e);
            this.getProvider(s).setDefaultChain(o, t)
        } catch (s) {
            if (!/Please call connect/.test(s.message)) throw s
        }
    }
    async cleanupPendingPairings(e = {}) {
        this.logger.info("Cleaning up inactive pairings...");
        const t = this.client.pairing.getAll();
        if (ri(t)) {
            for (const s of t) e.deletePairings ? this.client.core.expirer.set(s.topic, 0) : await this.client.core.relayer.subscriber.unsubscribe(s.topic);
            this.logger.info(`Inactive pairings cleared: ${t.length}`)
        }
    }
    abortPairingAttempt() {
        this.shouldAbortPairingAttempt = !0
    }
    async checkStorage() {
        if (this.namespaces = await this.getFromStore("namespaces"), this.optionalNamespaces = await this.getFromStore("optionalNamespaces") || {}, this.client.session.length) {
            const e = this.client.session.keys.length - 1;
            this.session = this.client.session.get(this.client.session.keys[e]), this.createProviders()
        }
    }
    async initialize() {
        this.logger.trace("Initialized"), await this.createClient(), await this.checkStorage(), this.registerEventListeners()
    }
    async createClient() {
        this.client = this.providerOpts.client || await U6.init({
            logger: this.providerOpts.logger || xd,
            relayUrl: this.providerOpts.relayUrl || H6,
            projectId: this.providerOpts.projectId,
            metadata: this.providerOpts.metadata,
            storageOptions: this.providerOpts.storageOptions,
            storage: this.providerOpts.storage,
            name: this.providerOpts.name
        }), this.logger.trace("SignClient Initialized")
    }
    createProviders() {
        if (!this.client) throw new Error("Sign Client not initialized");
        if (!this.session) throw new Error("Session not initialized. Please call connect() before enable()");
        const e = [...new Set(Object.keys(this.session.namespaces).map(t => ys(t)))];
        tu("client", this.client), tu("events", this.events), tu("disableProviderPing", this.disableProviderPing), e.forEach(t => {
            if (!this.session) return;
            const s = X6(t, this.session),
                o = Vp(s),
                c = Td(this.namespaces, this.optionalNamespaces),
                l = ru(ko({}, c[t]), {
                    accounts: s,
                    chains: o
                });
            switch (t) {
                case "eip155":
                    this.rpcProviders[t] = new rx({
                        namespace: l
                    });
                    break;
                case "solana":
                    this.rpcProviders[t] = new ix({
                        namespace: l
                    });
                    break;
                case "cosmos":
                    this.rpcProviders[t] = new nx({
                        namespace: l
                    });
                    break;
                case "polkadot":
                    this.rpcProviders[t] = new tx({
                        namespace: l
                    });
                    break;
                case "cip34":
                    this.rpcProviders[t] = new sx({
                        namespace: l
                    });
                    break;
                case "elrond":
                    this.rpcProviders[t] = new ox({
                        namespace: l
                    });
                    break;
                case "multiversx":
                    this.rpcProviders[t] = new ax({
                        namespace: l
                    });
                    break;
                case "near":
                    this.rpcProviders[t] = new cx({
                        namespace: l
                    });
                    break
            }
        })
    }
    registerEventListeners() {
        if (typeof this.client > "u") throw new Error("Sign Client is not initialized");
        this.client.on("session_ping", e => {
            this.events.emit("session_ping", e)
        }), this.client.on("session_event", e => {
            const {
                params: t
            } = e, {
                event: s
            } = t;
            if (s.name === "accountsChanged") {
                const o = s.data;
                o && ri(o) && this.events.emit("accountsChanged", o.map(Z6))
            } else if (s.name === "chainChanged") {
                const o = t.chainId,
                    c = t.event.data,
                    l = ys(o),
                    f = eu(o) !== eu(c) ? `${l}:${eu(c)}` : o;
                this.onChainChanged(f)
            } else this.events.emit(s.name, s.data);
            this.events.emit("session_event", e)
        }), this.client.on("session_update", ({
            topic: e,
            params: t
        }) => {
            var s;
            const {
                namespaces: o
            } = t, c = (s = this.client) == null ? void 0 : s.session.get(e);
            this.session = ru(ko({}, c), {
                namespaces: o
            }), this.onSessionUpdate(), this.events.emit("session_update", {
                topic: e,
                params: t
            })
        }), this.client.on("session_delete", async e => {
            await this.cleanup(), this.events.emit("session_delete", e), this.events.emit("disconnect", ru(ko({}, _t("USER_DISCONNECTED")), {
                data: e.topic
            }))
        }), this.on(Di.DEFAULT_CHAIN_CHANGED, e => {
            this.onChainChanged(e, !0)
        })
    }
    getProvider(e) {
        if (!this.rpcProviders[e]) throw new Error(`Provider not found: ${e}`);
        return this.rpcProviders[e]
    }
    onSessionUpdate() {
        Object.keys(this.rpcProviders).forEach(e => {
            var t;
            this.getProvider(e).updateNamespace((t = this.session) == null ? void 0 : t.namespaces[e])
        })
    }
    setNamespaces(e) {
        const {
            namespaces: t,
            optionalNamespaces: s,
            sessionProperties: o
        } = e;
        t && Object.keys(t).length && (this.namespaces = t), s && Object.keys(s).length && (this.optionalNamespaces = s), this.sessionProperties = o, this.persist("namespaces", t), this.persist("optionalNamespaces", s)
    }
    validateChain(e) {
        const [t, s] = (e == null ? void 0 : e.split(":")) || ["", ""];
        if (!this.namespaces || !Object.keys(this.namespaces).length) return [t, s];
        if (t && !Object.keys(this.namespaces || {}).map(l => ys(l)).includes(t)) throw new Error(`Namespace '${t}' is not configured. Please call connect() first with namespace config.`);
        if (t && s) return [t, s];
        const o = ys(Object.keys(this.namespaces)[0]),
            c = this.rpcProviders[o].getDefaultChain();
        return [o, c]
    }
    async requestAccounts() {
        const [e] = this.validateChain();
        return await this.getProvider(e).requestAccounts()
    }
    onChainChanged(e, t = !1) {
        if (!this.namespaces) return;
        const [s, o] = this.validateChain(e);
        o && (t || this.getProvider(s).setDefaultChain(o), this.namespaces[s] ? this.namespaces[s].defaultChain = o : this.namespaces[`${s}:${o}`] ? this.namespaces[`${s}:${o}`].defaultChain = o : this.namespaces[`${s}:${o}`] = {
            defaultChain: o
        }, this.persist("namespaces", this.namespaces), this.events.emit("chainChanged", o))
    }
    onConnect() {
        this.createProviders(), this.events.emit("connect", {
            session: this.session
        })
    }
    async cleanup() {
        this.session = void 0, this.namespaces = void 0, this.optionalNamespaces = void 0, this.sessionProperties = void 0, this.persist("namespaces", void 0), this.persist("optionalNamespaces", void 0), this.persist("sessionProperties", void 0), await this.cleanupPendingPairings({
            deletePairings: !0
        })
    }
    persist(e, t) {
        this.client.core.storage.setItem(`${Od}/${e}`, t)
    }
    async getFromStore(e) {
        return await this.client.core.storage.getItem(`${Od}/${e}`)
    }
}
const px = Xu,
    gx = "wc",
    yx = "ethereum_provider",
    vx = `${gx}@2:${yx}:`,
    _x = "https://rpc.walletconnect.com/v1/",
    Cu = ["eth_sendTransaction", "personal_sign"],
    mx = ["eth_accounts", "eth_requestAccounts", "eth_sendRawTransaction", "eth_sign", "eth_signTransaction", "eth_signTypedData", "eth_signTypedData_v3", "eth_signTypedData_v4", "eth_sendTransaction", "personal_sign", "wallet_switchEthereumChain", "wallet_addEthereumChain", "wallet_getPermissions", "wallet_requestPermissions", "wallet_registerOnboarding", "wallet_watchAsset", "wallet_scanQRCode"],
    Tu = ["chainChanged", "accountsChanged"],
    bx = ["chainChanged", "accountsChanged", "message", "disconnect", "connect"];
var wx = Object.defineProperty,
    Ex = Object.defineProperties,
    Dx = Object.getOwnPropertyDescriptors,
    $d = Object.getOwnPropertySymbols,
    Sx = Object.prototype.hasOwnProperty,
    Ix = Object.prototype.propertyIsEnumerable,
    jd = (i, e, t) => e in i ? wx(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t,
    _s = (i, e) => {
        for (var t in e || (e = {})) Sx.call(e, t) && jd(i, t, e[t]);
        if ($d)
            for (var t of $d(e)) Ix.call(e, t) && jd(i, t, e[t]);
        return i
    },
    Ld = (i, e) => Ex(i, Dx(e));

function Zo(i) {
    return Number(i[0].split(":")[1])
}

function iu(i) {
    return `0x${i.toString(16)}`
}

function xx(i) {
    const {
        chains: e,
        optionalChains: t,
        methods: s,
        optionalMethods: o,
        events: c,
        optionalEvents: l,
        rpcMap: f
    } = i;
    if (!ri(e)) throw new Error("Invalid chains");
    const y = {
            chains: e,
            methods: s || Cu,
            events: c || Tu,
            rpcMap: _s({}, e.length ? {
                [Zo(e)]: f[Zo(e)]
            } : {})
        },
        p = c == null ? void 0 : c.filter(x => !Tu.includes(x)),
        v = s == null ? void 0 : s.filter(x => !Cu.includes(x));
    if (!t && !l && !o && !(p != null && p.length) && !(v != null && v.length)) return {
        required: e.length ? y : void 0
    };
    const D = (p == null ? void 0 : p.length) && (v == null ? void 0 : v.length) || !t,
        S = {
            chains: [...new Set(D ? y.chains.concat(t || []) : t)],
            methods: [...new Set(y.methods.concat(o != null && o.length ? o : mx))],
            events: [...new Set(y.events.concat(l != null && l.length ? l : bx))],
            rpcMap: f
        };
    return {
        required: e.length ? y : void 0,
        optional: t.length ? S : void 0
    }
}
class Zu {
    constructor() {
        this.events = new Ur.EventEmitter, this.namespace = "eip155", this.accounts = [], this.chainId = 1, this.STORAGE_KEY = vx, this.on = (e, t) => (this.events.on(e, t), this), this.once = (e, t) => (this.events.once(e, t), this), this.removeListener = (e, t) => (this.events.removeListener(e, t), this), this.off = (e, t) => (this.events.off(e, t), this), this.parseAccount = e => this.isCompatibleChainId(e) ? this.parseAccountId(e).address : e, this.signer = {}, this.rpc = {}
    }
    static async init(e) {
        const t = new Zu;
        return await t.initialize(e), t
    }
    async request(e, t) {
        return await this.signer.request(e, this.formatChainId(this.chainId), t)
    }
    sendAsync(e, t, s) {
        this.signer.sendAsync(e, t, this.formatChainId(this.chainId), s)
    }
    get connected() {
        return this.signer.client ? this.signer.client.core.relayer.connected : !1
    }
    get connecting() {
        return this.signer.client ? this.signer.client.core.relayer.connecting : !1
    }
    async enable() {
        return this.session || await this.connect(), await this.request({
            method: "eth_requestAccounts"
        })
    }
    async connect(e) {
        if (!this.signer.client) throw new Error("Provider not initialized. Call init() first");
        this.loadConnectOpts(e);
        const {
            required: t,
            optional: s
        } = xx(this.rpc);
        try {
            const o = await new Promise(async (l, f) => {
                var y;
                this.rpc.showQrModal && ((y = this.modal) == null || y.subscribeModal(p => {
                    !p.open && !this.signer.session && (this.signer.abortPairingAttempt(), f(new Error("Connection request reset. Please try again.")))
                })), await this.signer.connect(Ld(_s({
                    namespaces: _s({}, t && {
                        [this.namespace]: t
                    })
                }, s && {
                    optionalNamespaces: {
                        [this.namespace]: s
                    }
                }), {
                    pairingTopic: e == null ? void 0 : e.pairingTopic
                })).then(p => {
                    l(p)
                }).catch(p => {
                    f(new Error(p.message))
                })
            });
            if (!o) return;
            const c = H1(o.namespaces, [this.namespace]);
            this.setChainIds(this.rpc.chains.length ? this.rpc.chains : c), this.setAccounts(c), this.events.emit("connect", {
                chainId: iu(this.chainId)
            })
        } catch (o) {
            throw this.signer.logger.error(o), o
        } finally {
            this.modal && this.modal.closeModal()
        }
    }
    async disconnect() {
        this.session && await this.signer.disconnect(), this.reset()
    }
    get isWalletConnect() {
        return !0
    }
    get session() {
        return this.signer.session
    }
    registerEventListeners() {
        this.signer.on("session_event", e => {
            const {
                params: t
            } = e, {
                event: s
            } = t;
            s.name === "accountsChanged" ? (this.accounts = this.parseAccounts(s.data), this.events.emit("accountsChanged", this.accounts)) : s.name === "chainChanged" ? this.setChainId(this.formatChainId(s.data)) : this.events.emit(s.name, s.data), this.events.emit("session_event", e)
        }), this.signer.on("chainChanged", e => {
            const t = parseInt(e);
            this.chainId = t, this.events.emit("chainChanged", iu(this.chainId)), this.persist()
        }), this.signer.on("session_update", e => {
            this.events.emit("session_update", e)
        }), this.signer.on("session_delete", e => {
            this.reset(), this.events.emit("session_delete", e), this.events.emit("disconnect", Ld(_s({}, _t("USER_DISCONNECTED")), {
                data: e.topic,
                name: "USER_DISCONNECTED"
            }))
        }), this.signer.on("display_uri", e => {
            var t, s;
            this.rpc.showQrModal && ((t = this.modal) == null || t.closeModal(), (s = this.modal) == null || s.openModal({
                uri: e
            })), this.events.emit("display_uri", e)
        })
    }
    switchEthereumChain(e) {
        this.request({
            method: "wallet_switchEthereumChain",
            params: [{
                chainId: e.toString(16)
            }]
        })
    }
    isCompatibleChainId(e) {
        return typeof e == "string" ? e.startsWith(`${this.namespace}:`) : !1
    }
    formatChainId(e) {
        return `${this.namespace}:${e}`
    }
    parseChainId(e) {
        return Number(e.split(":")[1])
    }
    setChainIds(e) {
        const t = e.filter(s => this.isCompatibleChainId(s)).map(s => this.parseChainId(s));
        t.length && (this.chainId = t[0], this.events.emit("chainChanged", iu(this.chainId)), this.persist())
    }
    setChainId(e) {
        if (this.isCompatibleChainId(e)) {
            const t = this.parseChainId(e);
            this.chainId = t, this.switchEthereumChain(t)
        }
    }
    parseAccountId(e) {
        const [t, s, o] = e.split(":");
        return {
            chainId: `${t}:${s}`,
            address: o
        }
    }
    setAccounts(e) {
        this.accounts = e.filter(t => this.parseChainId(this.parseAccountId(t).chainId) === this.chainId).map(t => this.parseAccountId(t).address), this.events.emit("accountsChanged", this.accounts)
    }
    getRpcConfig(e) {
        var t, s;
        const o = (t = e == null ? void 0 : e.chains) != null ? t : [],
            c = (s = e == null ? void 0 : e.optionalChains) != null ? s : [],
            l = o.concat(c);
        if (!l.length) throw new Error("No chains specified in either `chains` or `optionalChains`");
        const f = o.length ? (e == null ? void 0 : e.methods) || Cu : [],
            y = o.length ? (e == null ? void 0 : e.events) || Tu : [],
            p = (e == null ? void 0 : e.optionalMethods) || [],
            v = (e == null ? void 0 : e.optionalEvents) || [],
            D = (e == null ? void 0 : e.rpcMap) || this.buildRpcMap(l, e.projectId),
            S = (e == null ? void 0 : e.qrModalOptions) || void 0;
        return {
            chains: o == null ? void 0 : o.map(x => this.formatChainId(x)),
            optionalChains: c.map(x => this.formatChainId(x)),
            methods: f,
            events: y,
            optionalMethods: p,
            optionalEvents: v,
            rpcMap: D,
            showQrModal: !!(e != null && e.showQrModal),
            qrModalOptions: S,
            projectId: e.projectId,
            metadata: e.metadata
        }
    }
    buildRpcMap(e, t) {
        const s = {};
        return e.forEach(o => {
            s[o] = this.getRpcUrl(o, t)
        }), s
    }
    async initialize(e) {
        if (this.rpc = this.getRpcConfig(e), this.chainId = this.rpc.chains.length ? Zo(this.rpc.chains) : Zo(this.rpc.optionalChains), this.signer = await px.init({
                projectId: this.rpc.projectId,
                metadata: this.rpc.metadata,
                disableProviderPing: e.disableProviderPing,
                relayUrl: e.relayUrl,
                storageOptions: e.storageOptions
            }), this.registerEventListeners(), await this.loadPersistedSession(), this.rpc.showQrModal) {
            let t;
            try {
                const {
                    WalletConnectModal: s
                } = await Ib(() =>
                    import ("./DveOF59V.js").then(o => o.i), __vite__mapDeps([0, 1, 2]),
                    import.meta.url);
                t = s
            } catch {
                throw new Error("To use QR modal, please install @walletconnect/modal package")
            }
            if (t) try {
                this.modal = new t(_s({
                    projectId: this.rpc.projectId
                }, this.rpc.qrModalOptions))
            } catch (s) {
                throw this.signer.logger.error(s), new Error("Could not generate WalletConnectModal Instance")
            }
        }
    }
    loadConnectOpts(e) {
        if (!e) return;
        const {
            chains: t,
            optionalChains: s,
            rpcMap: o
        } = e;
        t && ri(t) && (this.rpc.chains = t.map(c => this.formatChainId(c)), t.forEach(c => {
            this.rpc.rpcMap[c] = (o == null ? void 0 : o[c]) || this.getRpcUrl(c)
        })), s && ri(s) && (this.rpc.optionalChains = [], this.rpc.optionalChains = s == null ? void 0 : s.map(c => this.formatChainId(c)), s.forEach(c => {
            this.rpc.rpcMap[c] = (o == null ? void 0 : o[c]) || this.getRpcUrl(c)
        }))
    }
    getRpcUrl(e, t) {
        var s;
        return ((s = this.rpc.rpcMap) == null ? void 0 : s[e]) || `${_x}?chainId=eip155:${e}&projectId=${t||this.rpc.projectId}`
    }
    async loadPersistedSession() {
        if (!this.session) return;
        const e = await this.signer.client.core.storage.getItem(`${this.STORAGE_KEY}/chainId`),
            t = this.session.namespaces[`${this.namespace}:${e}`] ? this.session.namespaces[`${this.namespace}:${e}`] : this.session.namespaces[this.namespace];
        this.setChainIds(e ? [this.formatChainId(e)] : t == null ? void 0 : t.accounts), this.setAccounts(t == null ? void 0 : t.accounts)
    }
    reset() {
        this.chainId = 1, this.accounts = []
    }
    persist() {
        this.session && this.signer.client.core.storage.setItem(`${this.STORAGE_KEY}/chainId`, this.chainId)
    }
    parseAccounts(e) {
        return typeof e == "string" || e instanceof String ? [this.parseAccount(e)] : e.map(t => this.parseAccount(t))
    }
}
const kx = Zu;
export {
    kx as EthereumProvider, bx as OPTIONAL_EVENTS, mx as OPTIONAL_METHODS, Tu as REQUIRED_EVENTS, Cu as REQUIRED_METHODS, Zu as
    default
};